{
  "sections": [
    {
      "id": "intro",
      "section": "introduction",
      "description": "Symmetry can be seen everywhere in nature – but it also underlies completely invisible laws of nature. Mathematics can explain why that is the case.",
      "color": "\"#2274E8\"",
      "level": "Intermediate",
      "next": "triangles",
      "content": "# Transformations and Symmetry\n\n## Introduction\n\n\nMany geometric concepts like [lines](gloss:line) or [polygons](gloss:polygon)\nwere “invented” by mathematicians. Symmetry, on the other hand, is everywhere\naround us. Almost all plants, animals, and even we humans are symmetric.\n\n::: column(width=200)\n\n    x-img(src=\"images/butterfly.jpg\" width=200 height=200 lightbox alt=\"Butterfly\")\n\n::: column(width=200)\n\n    x-img(src=\"images/lion.jpg\" width=200 height=200 lightbox alt=\"Lion\")\n\n::: column(width=200)\n\n    x-img(src=\"images/starfish.jpg\" width=200 height=200 lightbox alt=\"Starfish\")\n\n:::\n\nOver time, we’ve imitated nature’s symmetry in art, architecture, technology\nand design. Symmetric shapes and patterns just seems to look _more beautiful_\nthan non-symmetric ones.\n\n::: column(width=200)\n\n    x-img(src=\"images/taj-mahal.jpg\" credit=\"© Yann Forget / Wikimedia Commons\" width=200 height=200 lightbox alt=\"Taj Mahal\")\n\n::: column(width=200)\n\n    x-img(src=\"images/capitol.jpg\" credit=\"© Martin Falbisoner\" width=200 height=200 lightbox alt=\"US Capitol\")\n\n::: column(width=200)\n\n    x-img(src=\"images/window.jpg\" width=200 height=200 lightbox alt=\"Mosaic Church Window\")\n\n:::\n\nBut symmetry is much more important than simply _looking beautiful_. It lies at\nthe very foundations of our universe, and can even explain the most fundamental\nlaws of physics.\n\n[Continue](btn:next)"
    },
    {
      "id": "transformations",
      "goals": "t1 t2 t3",
      "content": "While symmetry is a very intuitive concept, describing it mathematically is more\ndifficult than you might think. First, we have to learn about\n[__transformations__](gloss:transformation), which are ways to convert one\ngeometric figure into another one. Here are a few examples:\n\n::: column.r(width=200 parent=\"padded-thin\")\n\n    .animation\n      include svg/transform-1.svg\n      x-play-btn\n\n::: column.r(width=200)\n\n    .animation\n      include svg/transform-2.svg\n      x-play-btn\n\n::: column.r(width=200)\n\n    .animation\n      include svg/transform-3.svg\n      x-play-btn\n\n:::"
    },
    {
      "id": "transformations-1",
      "content": "The result of a transformation is called the [__image__](gloss:transformation-image). We often\ndenote the image of a shape `A` as `A'`, pronounced “A prime”. There are many different types of\ntransformation, which we’ll explore in more detail throughout this course."
    },
    {
      "id": "rigid",
      "section": "rigid",
      "content": "## Rigid Transformations\n\n\nA [__rigid transformation__](gloss:rigid-transformation) is a special kind of transformation that\ndoesn’t change the size or shape of a figure. We could imagine that it is made out of a solid material\nlike wood or metal: we can move it, turn it, or flip it over, but we can’t stretch, bend, or\notherwise deform it.\n\nWhich of these five transformations are rigid?\n\n    x-picker.rigid\n      .item: img(src=\"images/picker-1.svg\" width=130 height=240)\n      .item(data-error=\"not-rigid-1\"): img(src=\"images/picker-2.svg\" width=130 height=240)\n      .item: img(src=\"images/picker-3.svg\" width=130 height=240)\n      .item(data-error=\"not-rigid-2\"): img(src=\"images/picker-4.svg\" width=130 height=240)\n      .item: img(src=\"images/picker-5.svg\" width=130 height=240)"
    },
    {
      "id": "rigid-1",
      "goals": "t1 t2 t3",
      "content": "It turns out that there are just three different types of rigid transformations:\n\n::: column.r(width=200)\n\n    .animation\n      include svg/rigid-1.svg\n      x-play-btn\n\n{.text-center} A transformation that simply _moves_ a shape is called a\n[__translation__](gloss:translation).\n\n::: column.r(width=200)\n\n    .animation\n      include svg/rigid-2.svg\n      x-play-btn\n\n{.text-center} A transformation that _flips_ a shape over is called a\n[__reflection__](gloss:reflection).\n\n::: column.r(width=200)\n\n    .animation\n      include svg/rigid-3.svg\n      x-play-btn\n\n{.text-center} A transformation that _spins_ a shape is called a\n[__rotation__](gloss:rotation).\n\n:::"
    },
    {
      "id": "rigid-2",
      "content": "We can also combine multiple types of transformation to create more complex\nones – for example, a translation followed by a rotation.\n\nBut first, let’s have a look at each of these types of transformations in more\ndetail."
    },
    {
      "id": "translations",
      "content": "### Translations\n\nA [__translation__](gloss:translation) is a transformation that moves every\npoint of a figure by the same distance in the same direction.\n\nIn the coordinate plane, we can specify a translation by how far the shape is\nmoved along the _x_-axis and the _y_-axis. For example, a transformation by\n(3, 5) moves a shape by 3 along the _x_-axis and by 5 along the _y_-axis.\n\n::: column(width=220)\n\n    x-geopad(width=220 height=140 grid=20 no-points): svg\n      path.fill.orange.light(x=\"polygon(point(2,2),point(1,5),point(4,5),point(3,2))\" name=\"s1\" label=\"A\" label-class=\"white\")\n      path.fill.orange(x=\"s1.shift(5,-1)\" label=\"A'\" label-class=\"white\")\n      path.reveal(x=\"segment(point(4,5),point(9,5))\" mark=\"arrow\" when=\"blank-0\" animation=\"draw\")\n      path.reveal(x=\"segment(point(9,5),point(9,4))\" mark=\"arrow\" when=\"blank-1\" animation=\"draw\")\n\n{.caption} Translated by ([[5]], [[1]])\n::: column(width=220)\n\n    x-geopad(width=220 height=140 grid=20 no-points): svg\n      path.fill.red.light(x=\"circle(point(7,4),1.5)\" name=\"s2\" label=\"B\" label-class=\"white\")\n      path.fill.red(x=\"s2.shift(-4,-2)\" label=\"B'\" label-class=\"white\")\n      path.reveal(x=\"segment(point(6,5),point(2,5))\" mark=\"arrow\" when=\"blank-2\" animation=\"draw\")\n      path.reveal(x=\"segment(point(2,5),point(2,3))\" mark=\"arrow\" when=\"blank-3\" animation=\"draw\")\n\n{.caption} Translated by ([[-4]], [[2]])\n::: column(width=220)\n\n    x-geopad(width=220 height=140 grid=20 no-points): svg\n      path.fill.light.purple(x=\"polygon(point(2,0),point(5,0),point(5,2),point(4,2),point(4,1),point(3,1),point(3,4),point(2,4))\" name=\"s3\" label=\"C\")\n      path.fill.purple(x=\"s3.shift(4,2)\" label=\"C'\")\n      path.reveal(x=\"segment(point(2,6),point(6,6))\" mark=\"arrow\" when=\"blank-4\" animation=\"draw\")\n      path.reveal(x=\"segment(point(2,4),point(2,6))\" mark=\"arrow\" when=\"blank-5\" animation=\"draw\")\n\n{.caption} Translated by ([[4]], [[-2]])\n:::"
    },
    {
      "id": "translations-1",
      "goals": "drag-0 drag-1 drag-2",
      "content": "Now it’s your turn – translate the following shapes as shown:\n\n::: column(width=220)\n\n    svg(width=220 height=140)\n      each i in [10,30,50,70,90,110,130,150,170,190,210]\n        line(x1=i x2=i y1=0 y2=140 stroke=\"#e6e6e6\" stroke-width=2)\n      each i in [10,30,50,70,90,110,130]\n        line(x1=0 x2=220 y1=i y2=i stroke=\"#e6e6e6\" stroke-width=2)\n      polygon(points=\"30,10 10,70 70,70 50,10\" style=\"fill: #289782; opacity: .5;\")\n      polygon(points=\"30,10 10,70 70,70 50,10\" style=\"fill: #289782; cursor: move\")\n\n{.caption} Translate by (3, 1) _{span.check(when=\"drag-0\")}_\n::: column(width=220)\n\n    svg(width=220 height=140)\n      each i in [10,30,50,70,90,110,130,150,170,190,210]\n        line(x1=i x2=i y1=0 y2=140 stroke=\"#e6e6e6\" stroke-width=2)\n      each i in [10,30,50,70,90,110,130]\n        line(x1=0 x2=220 y1=i y2=i stroke=\"#e6e6e6\" stroke-width=2)\n      polygon(points=\"50,10 90,50 50,90 10,50\" style=\"fill: #2ba058; opacity: .5;\")\n      polygon(points=\"50,10 90,50 50,90 10,50\" style=\"fill: #2ba058; cursor: move\")\n\n{.caption} Translate by (–4, –2) _{span.check(when=\"drag-1\")}_\n::: column(width=220)\n\n    svg(width=220 height=140)\n      each i in [10,30,50,70,90,110,130,150,170,190,210]\n        line(x1=i x2=i y1=0 y2=140 stroke=\"#e6e6e6\" stroke-width=2)\n      each i in [10,30,50,70,90,110,130]\n        line(x1=0 x2=220 y1=i y2=i stroke=\"#e6e6e6\" stroke-width=2)\n      polygon(points=\"10,10 30,10 30,50 50,50 50,10 70,10 70,70 10,70\" style=\"fill: #2ea92e; opacity: .5;\")\n      polygon(points=\"10,10 30,10 30,50 50,50 50,10 70,10 70,70 10,70\" style=\"fill: #2ea92e; cursor: move\")\n\n{.caption} Translate by (5, –1) _{span.check(when=\"drag-2\")}_\n:::"
    },
    {
      "id": "reflections",
      "goals": "r0 r1 r2",
      "content": "### Reflections\n\nA [__reflection__](gloss:reflection) is a transformation that “flips” or\n“mirrors” a shape across a line. This line is called the __line of reflection__.\n\nDraw the line of reflection in each of these examples:\n\n::: column(width=220)\n\n    x-geopad.draw.reflection(width=220 height=180 grid=20 no-points): svg\n      path(x=\"polygon(point(2,1),point(1,2),point(2,3),point(8,2))\" style=\"stroke: #363644; stroke-width: 3px; fill: rgba(179,4,105,0.4)\" name=\"from0\")\n      path(hidden name=\"line0\" x=\"line(point(-1,4),point(11,4))\")\n      path(x=\"from0.reflect(line0)\" style=\"stroke: #363644; stroke-width: 3px; fill: rgba(179,4,105,0.4)\")\n\n::: column(width=220)\n\n    x-geopad.draw.reflection(width=220 height=180 grid=20 no-points): svg\n      path(x=\"polygon(point(1,1),point(1,5),point(3,5),point(2,3),point(4,1))\" style=\"stroke: #363644; stroke-width: 3px; fill: rgba(154,24,130,0.4)\" name=\"from1\")\n      path(hidden name=\"line1\" x=\"line(point(9,-1),point(-1,9))\")\n      path(x=\"from1.reflect(line1)\" style=\"stroke: #363644; stroke-width: 3px; fill: rgba(154,24,130,0.4)\")\n\n::: column(width=220)\n\n    x-geopad.draw.reflection(width=220 height=180 grid=20 no-points)\n      x-img.background(src=\"images/rorschach.jpg\" width=220 height=180 alt=\"Rorschach Test\")\n      svg\n        path(hidden name=\"line2\" x=\"line(point(5,-1),point(5,9))\")\n\n:::"
    },
    {
      "id": "reflections-1",
      "goals": "r0 r1 r2",
      "content": "Now it’s your turn – draw the reflection of each of these shapes:\n\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      path(x=\"polygon(point(1,2),point(3,1),point(4,3),point(4,5),point(2,6),point(1,4))\" name=\"from0\" style=\"fill: rgba(105,63,180,0.4)\")\n      path.red(x=\"line(point(5,0), point(5,1))\" name=\"line0\")\n      path.finished(hidden x=\"from0.reflect(line0)\" name=\"to0\" style=\"fill: rgba(105,63,180,0.4)\")\n\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      path(x=\"polygon(point(2,6),point(6,4),point(8,6),point(5,7))\" name=\"from1\" style=\"fill: rgba(80,83,205,0.4)\")\n      path.red(x=\"line(point(-1,4), point(11,4))\" name=\"line1\")\n      path.finished(hidden x=\"from1.reflect(line1)\" name=\"to1\" style=\"fill: rgba(80,83,205,0.4)\")\n\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      path(x=\"polygon(point(2,3),point(3,3),point(3,5),point(5,5),point(5,6),point(2,6))\" name=\"from2\" style=\"fill: rgba(56,102,230,0.4)\")\n      path.red(x=\"line(point(2,1), point(3,2))\" name=\"line2\")\n      path.finished(hidden x=\"from2.reflect(line2)\" name=\"to2\" style=\"fill: rgba(56,102,230,0.4)\")\n\n:::"
    },
    {
      "id": "reflections-2",
      "content": "Notice that if a point lies on the line of reflection, it [[doesn’t move|rotates|flips over]] when\nbeing reflected: _{span.reveal(when=\"blank-0\")} its image is the same point as the original._"
    },
    {
      "id": "reflections-3",
      "content": "In all of the examples above, the line of reflection was horizontal, vertical,\nor at a 45° angle – which made it easy to draw the reflections. If that is not\nthe case, the construction requires a bit more work:\n\n::: column(width=300)\n\n    x-geopad.sticky(width=300): svg\n      circle.move.pulsate(name=\"l1\" cx=\"180\" cy=\"30\" target=\"refl\")\n      circle.move.pulsate(name=\"l2\" cx=\"120\" cy=\"270\" target=\"refl\")\n      path(name=\"refl\" x=\"line(l1,l2)\" target=\"refl\")\n\n      circle.reveal(name=\"a\" x=\"point(60,50)\" when=\"next-0\" animation=\"pop\" target=\"circ\")\n      circle(name=\"b\" x=\"point(120,100)\" hidden)\n      circle(name=\"c\" x=\"point(110,170)\" hidden)\n      circle(name=\"d\" x=\"point(65,200)\" hidden)\n      circle(name=\"e\" x=\"point(30,120)\" hidden)\n\n      circle.reveal(name=\"p\" x=\"refl.project(a)\" when=\"next-0\" animation=\"pop\" delay=1500)\n      path.reveal.fill.light(x=\"angle(a,p,l1)\" size=16 when=\"next-0\" delay=1500)\n\n      circle.reveal(name=\"a1\" x=\"a.reflect(refl)\" when=\"next-1\" animation=\"pop\" target=\"circ\")\n      circle(name=\"b1\" x=\"b.reflect(refl)\" hidden)\n      circle(name=\"c1\" x=\"c.reflect(refl)\" hidden)\n      circle(name=\"d1\" x=\"d.reflect(refl)\" hidden)\n      circle(name=\"e1\" x=\"e.reflect(refl)\" hidden)\n\n      path.fill.blue(x=\"polygon(a,b,c,d,e)\")\n      path.fill.reveal.blue1(x=\"polygon(a1,b1,c1,d1,e1)\" when=\"next-3\")\n\n      path.reveal(x=\"line(a,a1)\" when=\"next-0\" animation=\"draw\" delay=1000)\n      path.reveal.thin.light(x=\"segment(b,b1)\" when=\"next-2\" animation=\"draw\" delay=400)\n      path.reveal.thin.light(x=\"segment(c,c1)\" when=\"next-2\" animation=\"draw\" delay=500)\n      path.reveal.thin.light(x=\"segment(d,d1)\" when=\"next-2\" animation=\"draw\" delay=600)\n      path.reveal.thin.light(x=\"segment(e,e1)\" when=\"next-2\" animation=\"draw\" delay=700)\n\n      circle.transparent(name=\"ax\" x=\"refl.project(a)\" target=\"circ\")\n      path.transparent(x=\"segment(a,ax)\" target=\"d1 circ\")\n      path.transparent(x=\"segment(a1,ax)\" target=\"d2 circ\")\n      path.transparent(x=\"circle(ax,distance(a,ax))\" target=\"circ\")\n\n::: column.grow\n{.r} To reflect this shape across the [line of reflection](target:refl), we have\nto reflect every [vertex](gloss:polygon-vertex) individually and then connect\nthem again.\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-0\")} Let’s pick one of the vertices and draw the line\nthrough this vertex that is perpendicular to the line of reflection.\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-1\")} Now we can measure the [distance](target:d1) from the\nvertex to the line of the reflection, and make the point that has the [same\ndistance](target:d2) on the other side. _{span.lgrey}(We can either use a ruler\nor a [compass](target:circ) to do this.)_\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-2\")} We can do the same for all the other vertices of our\nshape.\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-3\")} Now we just have to connect the reflected vertices in\nthe correct order, and we’ve found the reflection!\n:::"
    },
    {
      "id": "rotations",
      "goals": "r0 r1 r2",
      "content": "### Rotations\n\nA [__rotation__](gloss:rotation) is a transformation that “turns” a shape by a\ncertain angle around a fixed point. That point is called the [__center of\nrotation__](gloss:center-of-rotation). Rotations can be clockwise or\ncounterclockwise.\n\nTry to rotate the shapes below around the red center of rotation:\n\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      path(x=\"polygon(point(2,2),point(2,5),point(5,5),point(5,2))\" name=\"from0\" style=\"fill: rgba(34,132,213,0.4)\")\n      circle.red(x=\"point(5,6)\" name=\"c0\")\n      path.finished(hidden x=\"from0.rotate(pi/2,c0)\" name=\"to0\" style=\"fill: rgba(34,132,213,0.4)\")\n\n{.caption} Rotate by 90° clockwise.\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      path(x=\"polygon(point(3,2),point(8,1),point(9,4))\" name=\"from1\" style=\"fill: rgba(40,151,130,0.4)\")\n      circle.red(x=\"point(5,4)\" name=\"c1\")\n      path.finished(hidden x=\"from1.rotate(pi,c1)\" name=\"to1\" style=\"fill: rgba(40,151,130,0.4)\")\n\n{.caption} Rotate by 180°.\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      path(x=\"polygon(point(3,0),point(8,0),point(8,4),point(1,4))\" name=\"from2\" style=\"fill: rgba(46,169,46,0.4)\")\n      circle.red(x=\"point(6,3)\" name=\"c2\")\n      path.finished(hidden x=\"from2.rotate(-pi/2,c2)\" name=\"to2\" style=\"fill: rgba(46,169,46,0.4)\")\n\n{.caption} Rotate by 90° anti-clockwise.\n:::"
    },
    {
      "id": "rotations-1",
      "content": "::: column(width=300)\n\n    x-geopad.sticky(width=300): svg\n      circle.move.pulsate(name=\"rot\" cx=\"150\" cy=\"250\" target=\"rot angle compass protractor\")\n\n      circle.reveal(name=\"a\" x=\"point(270,190)\" when=\"next-0\" animation=\"pop\" target=\"compass\")\n      circle(name=\"b\" x=\"point(280,110)\" hidden)\n      circle(name=\"c\" x=\"point(210,80)\" hidden)\n      circle(name=\"d\" x=\"point(190,170)\" hidden)\n      circle(name=\"e\" x=\"point(220,200)\" hidden)\n\n      circle.reveal(name=\"a1\" x=\"a.rotate(-ang/18*pi,rot)\" when=\"next-2\" animation=\"pop\" target=\"a1 compass\")\n      circle(name=\"b1\" x=\"b.rotate(-ang/18*pi,rot)\" hidden)\n      circle(name=\"c1\" x=\"c.rotate(-ang/18*pi,rot)\" hidden)\n      circle(name=\"d1\" x=\"d.rotate(-ang/18*pi,rot)\" hidden)\n      circle(name=\"e1\" x=\"e.rotate(-ang/18*pi,rot)\" hidden)\n\n      path.fill.green(x=\"polygon(a,b,c,d,e)\")\n      path.fill.reveal.green1(x=\"polygon(a1,b1,c1,d1,e1)\" when=\"next-4\")\n\n      path.transparent.light.fill(x=\"arc(rot,a.rotate(pi,rot),pi)\" target=\"protractor\")\n      path.reveal.light.fill(x=\"angle(a1,rot,a)\" when=\"next-1\" target=\"angle protractor\")\n\n      path.reveal(x=\"segment(a,rot)\" when=\"next-0\" animation=\"draw\" delay=500 target=\"angle compass protractor\")\n      path.reveal.thin.light(x=\"segment(rot,b)\" when=\"next-3\" animation=\"draw\" delay=400)\n      path.reveal.thin.light(x=\"segment(rot,c)\" when=\"next-3\" animation=\"draw\" delay=500)\n      path.reveal.thin.light(x=\"segment(rot,d)\" when=\"next-3\" animation=\"draw\" delay=600)\n      path.reveal.thin.light(x=\"segment(rot,e)\" when=\"next-3\" animation=\"draw\" delay=700)\n\n      path.reveal(x=\"ray(rot,a1)\" when=\"next-1\" animation=\"draw\" delay=500 target=\"angle l2\")\n      path.reveal.thin.light(x=\"segment(rot,b1)\" when=\"next-3\" animation=\"draw\" delay=800)\n      path.reveal.thin.light(x=\"segment(rot,c1)\" when=\"next-3\" animation=\"draw\" delay=900 )\n      path.reveal.thin.light(x=\"segment(rot,d1)\" when=\"next-3\" animation=\"draw\" delay=1000)\n      path.reveal.thin.light(x=\"segment(rot,e1)\" when=\"next-3\" animation=\"draw\" delay=1100)\n\n      path.transparent(x=\"segment(rot,a1)\" target=\"compass protractor\")\n      path.transparent(x=\"circle(rot,distance(rot,a))\" target=\"compass\")\n\n\n::: column.grow\nIt is more difficult to draw rotations that are not exactly 90° or 180°. Let's\ntry to rotate this shape by ${10*ang}{ang|6|-18,18,1}° around the [center of\nrotation](target:rot).\n\n{.r} Like for reflections, we have to rotate every point in a shape individually.\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-0\")} We start by picking one of the vertices and drawing a line to the center of\nrotation.\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-1\")} Using a [protractor](target:protractor), we can\nmeasure an [angle of ${ang*10}°](target:angle) around the center of rotation.\nLet’s draw a [second line](target:l2) at that angle.\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-2\")} Using a [compass](target:compass) or ruler, we can\nfind a [point](target:a1) on this line that has the same distance from the\ncenter of rotation as the original point.\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-3\")} Now we have to repeat these steps for all other vertices of our shape.\n[Continue](btn:next)\n\n{.reveal(when=\"next-4\")} And finally, like before, we can connect the individual\nvertices to get the rotated image of our original shape.\n:::"
    },
    {
      "id": "composition-1",
      "content": "Transformations are an important concept in many parts of mathematics, not just\ngeometry. For example, you can transform [_functions_](gloss:function) by\nshifting or rotating their [graphs](gloss:function-graph). You can also use\ntransformations to determine whether two shapes are [congruent](gloss:congruent)."
    },
    {
      "section": "congruence",
      "sectionStatus": "dev",
      "content": "## Congruence\n\n\nTODO"
    },
    {
      "content": "### Composition of Transformations\n\nOf course, we can combine multiple translations, reflections and rotations to\ncreate more complex transformations.\n\n{.todo} TODO Example\n\nHowever, as it turns out, it doesn’t matter how many different transformations\nyou combine: you can always find another transformation that does the same in\none go!\n\n{.todo} TODO Transformation composition calculator\n\nCombining two reflections is particularly interesting. There are two different\ncases we need to consider:\n\n::: column.grow\nIf the two lines of reflection are parallel, the result is a single translation.\nThe direction of the translation is perpendicular to the lines of reflection,\nand the distance is twice the distance between the lines of reflection.\n\n{.todo} TODO Animation\n::: column.grow\nIf the two lines of reflection intersect, the result is a single rotation. The\ncenter of rotation is the intersection between the lines of reflection, and the\nangle is twice the angle between the lines of reflection.\n\n{.todo} TODO Animation\n:::"
    },
    {
      "id": "symmetry",
      "goals": "play-0 play-1",
      "section": "symmetry",
      "content": "## Symmetry\n\n\n[__Symmetry__](gloss:symmetry) is everywhere around us, and an intuitive\nconcept: different parts of an object look _the same_ in some way. But using\ntransformations, we can give a much more precise, mathematical definition of\nwhat symmetry _really_ means:\n\n{.definition} An object is _symmetric_ if it looks the same, even after applying\na certain transformation.\n\n::: column.grow\n\n    .symmetry\n      img(src=\"images/symmetry-1.png\" width=320 height=240)\n      img(src=\"images/symmetry-1.png\" width=320 height=240)\n      x-play-btn\n\n{.text-center} We can reflect this butterfly, and it looks the same afterwards.\nWe say that it has __reflectional symmetry__.\n\n::: column.grow\n\n    .symmetry\n      img(src=\"images/symmetry-2.jpg\" width=320 height=240)\n      img(src=\"images/symmetry-2.jpg\" width=320 height=240)\n      x-play-btn\n\n{.text-center} We can rotate this flower, and it looks the same afterwards. We\nsay that it has __rotational symmetry__.\n:::"
    },
    {
      "id": "reflectional-symmetry",
      "content": "### Reflectional Symmetry\n\nA shape has [__reflectional symmetry__](gloss:reflectional-symmetry) if it looks\nthe same after being reflected. The line of reflection is called the [__axis of\nsymmetry__](gloss:axis-of-symmetry), and it splits the shape into two\n[[congruent|equal|similar]] halves. Some figures can also have more than one\naxis of symmetry."
    },
    {
      "id": "reflectional-symmetry-1",
      "goals": "r0 r1 r2 r3 r4 r5",
      "content": "Draw all axes of symmetry in these six images and shapes:\n\n::: column(width=220)\n\n    x-geopad.draw.reflection(width=220 height=180 grid=20 no-points)\n      x-img.background(src=\"images/lake.jpg\" width=220 height=180 alt=\"Lake\")\n      svg\n        path(hidden name=\"line0\" x=\"line(point(-1,4),point(11,4))\")\n\n::: column(width=220)\n\n    x-geopad.draw.reflection(width=220 height=180 grid=20 no-points)\n      x-img.background(src=\"images/beijing.jpg\" width=220 height=180 alt=\"Forbidden City in Beijing\")\n      svg\n        path(hidden name=\"line1\" x=\"line(point(5,-1),point(5,9))\")\n\n::: column(width=220)\n\n    x-geopad.draw.reflection(width=220 height=180 grid=20 no-points)\n      x-img.background(src=\"images/blue-butterfly.jpg\" width=220 height=180 alt=\"Butterfly\")\n      svg\n        path(hidden name=\"line2\" x=\"line(point(1,-1),point(11,9))\")\n\n::: column(width=220)\n\n    x-geopad.draw.reflection(width=220 height=180 grid=20 no-points): svg\n      path(x=\"polygon(point(2,2),point(5,1),point(8,2),point(9,4),point(8,6),point(5,7),point(2,6),point(1,4))\" style=\"stroke: #363644; stroke-width: 3px; fill: rgba(255,148,31,0.4)\")\n      path(hidden name=\"line3a\" x=\"line(point(-1,4),point(11,4))\")\n      path(hidden name=\"line3b\" x=\"line(point(5,-1),point(5,9))\")\n\n{.caption} This shape has [[2]] axes of symmetry.\n::: column(width=220)\n\n    x-geopad.draw.reflection(width=220 height=180 grid=20 no-points): svg\n      path(x=\"polygon(point(3,2),point(7,2),point(7,6),point(3,6))\" style=\"stroke: #363644; stroke-width: 3px; fill: rgba(242,124,43,0.4)\")\n      path(hidden name=\"line4a\" x=\"line(point(-1,4),point(11,4))\")\n      path(hidden name=\"line4b\" x=\"line(point(5,-1),point(5,9))\")\n      path(hidden name=\"line4c\" x=\"line(point(0,-1),point(10,9))\")\n      path(hidden name=\"line4d\" x=\"line(point(10,-1),point(0,9))\")\n\n{.caption} A square has [[4]] axes of symmetry.\n::: column(width=220)\n\n    x-geopad.draw.reflection(width=220 height=180 grid=20 no-points): svg\n      path(x=\"polygon(point(3,1),point(9,3),point(8,6),point(2,4))\" style=\"stroke: #363644; stroke-width: 3px; fill: rgba(230,100,56,0.4)\")\n      path(hidden name=\"line5a\" x=\"line(point(-2,1),point(13,6))\")\n      path(hidden name=\"line5b\" x=\"line(point(7,-1),point(3,11))\")\n\n{.caption} This shape has [[2]] axes of symmetry.\n:::"
    },
    {
      "id": "alphabet",
      "content": "Many letters in the alphabet have reflectional symmetry. Select all the ones\nthat do:\n\n    x-picker.letters\n      - let c = ['#D92120', '#E6642C', '#E68E34', '#D9AD3C', '#B5BD4C', '#7FB972', '#63AD99', '#55A1B1', '#488BC2', '#4065B1', '#413B93', '#781C81']\n      for l, i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('')\n        if 'FGJKLNPQRSZ'.indexOf(l) < 0\n          .item(style=`color: ${c[i%12]}`)= l\n        else\n          .item(data-error=\"letter-not-symmetric\" style=`color: ${c[i%12]}`)= l"
    },
    {
      "id": "reflectional-symmetry-2",
      "goals": "r0 r1 r2",
      "content": "Here are some more shapes. Complete them so that they have reflectional\nsymmetry:\n\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      path.fill.finished(hidden x=\"polygon(point(8,5),point(9,3),point(9,2),point(8,1),point(6,1),point(5,2),point(4,1),point(2,1),point(1,2),point(1,3),point(2,5),point(5,7))\" style=\"fill: rgba(179,4,105,0.4)\")\n      path(x=\"polyline(point(5,2),point(4,1),point(2,1),point(1,2),point(1,3),point(2,5),point(5,7))\" name=\"from0\")\n      path.red(x=\"line(point(5,-1),point(5,9))\" name=\"line0\")\n      path(hidden x=\"from0.reflect(line0)\" name=\"to0\")\n\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      path.fill.finished(hidden x=\"polygon(point(1,5),point(1,3),point(6,3),point(4,1),point(5,0),point(9,4),point(5,8),point(4,7),point(6,5))\" style=\"fill: rgba(154,24,130,0.4)\")\n      path(x=\"polyline(point(1,4),point(1,3),point(6,3),point(4,1),point(5,0),point(9,4))\" name=\"from1\")\n      path.red(x=\"line(point(-1,4),point(11,4))\" name=\"line1\")\n      path(hidden x=\"from1.reflect(line1)\" name=\"to1\")\n\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      path.fill.finished(hidden x=\"polygon(point(2,1),point(8,1),point(9,2),point(9,6),point(8,7),point(2,7),point(1,6),point(1,2))\" style=\"fill: rgba(130,43,155,0.4)\")\n      path(x=\"polyline(point(5,1),point(8,1),point(9,2),point(9,4))\")\n      path.red(x=\"line(point(5,-1),point(5,9))\")\n      path.red(x=\"line(point(-1,4),point(11,4))\")\n      path(hidden x=\"polyline(point(5,1),point(2,1),point(1,2),point(1,6),point(2,7),point(8,7),point(9,6),point(9,4))\" name=\"to2\")\n\n:::"
    },
    {
      "id": "palindromes",
      "goals": "p0 p1 p2",
      "content": "Shapes, letters and images can have reflectional symmetry, but so can entire\nnumbers, words and sentences!\n\nFor example “25352” and “ANNA” both read the same from back to front. Numbers\nor words like this are called [__Palindromes__](gloss:palindrome). Can you think\nof any other palindromes?\n\n    form.palindromes.text-center.form-field\n      input(type=\"text\")\n      span.check(when=\"p0\")\n      input(type=\"text\")\n      span.check(when=\"p1\")\n      input(type=\"text\")\n      span.check(when=\"p2\")"
    },
    {
      "id": "palindromes-1",
      "content": "If we ignore spaces and punctuation, the short sentences below also have\nreflectional symmetry. Can you come up with your own?\n\n{.text-center} Never odd or even.<br>\nA [[nut]] for a jar of tuna.<br>\nYo, banana [[boy]]!\n\n{.reveal(when=\"blank-0 blank-1\")} But Palindromes are not just fun, they\nactually have practical importance. A few years ago, scientists discovered that\nparts of our [DNA](gloss:dna) are palindromic. This makes them more resilient to\nmutations or damage – because there is a second backup copy of every piece."
    },
    {
      "id": "rotational-symmetry",
      "content": "### Rotational Symmetry\n\n::: column.grow\nA shape has [__rotational symmetry__](gloss:rotational-symmetry) if it looks the\nsame after being rotated (by less than 360°). The [center of\nrotation](gloss:center-of-rotation) is usually just the middle of the shape.\n\nThe [__order of symmetry__](gloss:order-of-symmetry) is the number of distinct\norientations in which the shape looks the same. You can also think about it as\nthe _number of times we can rotate the shape_, before we get back to the start.\nFor example, this snowflake has order [[6]].\n\n{.reveal(when=\"blank-0\")} The angle of each rotation is `\"360°\"/\"order\"`. In the\nsnowflake, this is `\"360°\"/6 = input(60)°`.\n\n::: column(width=240)\n\n    include svg/snowflake.svg\n\n:::\n\n    // Maybe have another alphabeth to select all letters with rotational symmetry?"
    },
    {
      "id": "rotational-symmetry-1",
      "content": "Find the order and the angle of rotation, for each of these shapes:\n\n::: column(width=220)\n\n    img(src=\"images/clover.jpg\" width=200 height=200)\n\n{.caption} Order [[4]], angle [[90]]°\n\n::: column(width=220)\n\n    img(src=\"images/playing-card.jpg\" width=200 height=200)\n\n{.caption} Order [[2]], angle [[180]]°\n\n::: column(width=220)\n\n    img(src=\"images/flower.jpg\" width=200 height=200)\n\n{.caption} Order [[8]], angle [[45]]°\n\n:::"
    },
    {
      "id": "rotational-symmetry-2",
      "goals": "r0 r1 r2",
      "content": "Now complete these shapes, so that they have rotational symmetry:\n\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      circle.red(x=\"point(5,4)\")\n      path.fill.finished(hidden x=\"polygon(point(5,0),point(6,3),point(9,4),point(6,5),point(5,8),point(4,5),point(1,4),point(4,3))\" style=\"fill: rgba(56,102,230,0.4)\")\n      path(x=\"polyline(point(5,0),point(6,3),point(9,4))\")\n      path.red(x=\"segment(point(5,-1),point(5,4))\")\n      path.red(x=\"segment(point(5,4),point(11,4))\")\n      path(hidden x=\"polyline(point(9,4),point(6,5),point(5,8),point(4,5),point(1,4),point(4,3),point(5,0))\" name=\"to0\")\n\n{.caption} Order 4\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      circle.red(x=\"point(5,4)\" name=\"c1\")\n      path.fill.finished(hidden x=\"polygon(point(6,2),point(1,2),point(1,4),point(4,6),point(9,6),point(9,4))\" style=\"fill: rgba(40,151,130,0.4)\")\n      path(x=\"polyline(point(5,2),point(1,2),point(1,4),point(4,6),point(5,6))\" name=\"from1\")\n      path.red(x=\"segment(point(5,-1),point(5,9))\")\n      path(hidden x=\"from1.rotate(pi,c1)\" name=\"to1\")\n\n{.caption} Order 2\n::: column(width=220)\n\n    x-geopad.draw(width=220 height=180 grid=20 no-points): svg\n      circle.red(x=\"point(5,4)\")\n      path.fill.finished(hidden x=\"polygon(point(4,4),point(2,6),point(3,7),point(5,5),point(7,7),point(8,6),point(6,4),point(8,2),point(7,1),point(5,3),point(3,1),point(2,2))\" style=\"fill: rgba(83,174,9,0.4)\")\n      path(x=\"polyline(point(5,3),point(3,1),point(2,2),point(4,4))\")\n      path.red(x=\"segment(point(5,-1),point(5,4))\")\n      path.red(x=\"segment(point(5,4),point(-1,4))\")\n      path(hidden x=\"polyline(point(4,4),point(2,6),point(3,7),point(5,5),point(7,7),point(8,6),point(6,4),point(8,2),point(7,1),point(5,3))\" name=\"to2\")\n\n{.caption} Order 4\n:::"
    },
    {
      "id": "groups",
      "section": "symmetry-groups",
      "content": "## Symmetry Groups and Wallpapers\n\n\n    // HINT: To recognise different configurations, we need to highlight the\n    // four corners in different colours.\n\nSome shapes have more than one symmetry – let’s have a look at the\n[square](gloss:square) as a simple example.\n\n::: column(width=400 parent=\"padded-thin\")\n\n    .cubes\n      img.cube.reveal(src=\"images/cube-0.svg\" width=80 height=80 when=\"blank-1 blank-2 blank-3\" delay=1000 animation=\"pop\")\n      img.cube.reveal(src=\"images/cube-1.svg\" width=80 height=80 when=\"blank-1\" animation=\"pop\")\n      img.cube.reveal(src=\"images/cube-2.svg\" width=80 height=80 when=\"blank-2\" animation=\"pop\")\n      img.cube.reveal(src=\"images/cube-3.svg\" width=80 height=80 when=\"blank-3\" animation=\"pop\")\n      img.cube.reveal(src=\"images/cube-4.svg\" width=80 height=80 when=\"blank-0\" animation=\"pop\")\n      img.cube.reveal(src=\"images/cube-5.svg\" width=80 height=80 when=\"blank-0\" delay=200 animation=\"pop\")\n      img.cube.reveal(src=\"images/cube-6.svg\" width=80 height=80 when=\"blank-0\" delay=400 animation=\"pop\")\n      img.cube.reveal(src=\"images/cube-7.svg\" width=80 height=80 when=\"blank-0\" delay=600 animation=\"pop\")\n\n::: column.grow(width=200)\nYou have already shown above that a square has [[4]] axes of reflection.\n\n{.reveal(when=\"blank-0\")} It also has rotational symmetry by [[90]]°,\n[[180]]° and [[270]]°.\n\n{.reveal(when=\"blank-1 blank-2 blank-3\")} And finally, we can think\nabout “doing nothing” as another special kind of symmetry – because the result\nis (obviously) the same as before. This is sometimes called the __identity__.\n\n{.reveal(when=\"blank-1 blank-2 blank-3\" delay=1000)} In total, we have found [[8]]\ndifferent “symmetries of the square”.\n:::"
    },
    {
      "id": "add-symmetries",
      "goals": "sum-0 sum-1",
      "content": "Now we can actually start doing some arithmetic with these symmetries. For\nexample, we can _add_ two symmetries to get new ones:\n\n::: column(width=260)\n\n    .text-center\n      img.cube(src=\"images/cube-1.svg\" width=54 height=54)\n      mo +\n      img.cube(src=\"images/cube-1.svg\" width=54 height=54)\n      mo =\n      span.sym-sum.pending(tabindex=0): img.cube(src=\"images/cube-2.svg\" width=54 height=54)\n    x-gesture(target=\".sym-sum\")\n\n::: column(width=260)\n\n    .text-center\n      img.cube(src=\"images/cube-2.svg\" width=54 height=54)\n      mo +\n      img.cube(src=\"images/cube-6.svg\" width=54 height=54)\n      mo =\n      span.sym-sum.pending(tabindex=0): img.cube.ani-sym(src=\"images/cube-4.svg\" width=54 height=54)\n\n:::"
    },
    {
      "id": "calculator",
      "title": "Symmetry Calculator",
      "goals": "calculate",
      "content": "Whenever you add two symmetries of a square, you get a new one. Here is a\n“symmetry calculator” where you can try it yourself:\n\n    .calculator\n      .display\n        .operator +\n        .operator =\n        .clear ×\n      .button(tabindex=0) + #[img.cube(src=\"images/cube-0.svg\" width=40 height=40)]\n      .button(tabindex=0) + #[img.cube(src=\"images/cube-1.svg\" width=40 height=40)]\n      .button(tabindex=0) + #[img.cube(src=\"images/cube-2.svg\" width=40 height=40)]\n      .button(tabindex=0) + #[img.cube(src=\"images/cube-3.svg\" width=40 height=40)]\n      .button(tabindex=0) + #[img.cube(src=\"images/cube-4.svg\" width=40 height=40)]\n      .button(tabindex=0) + #[img.cube(src=\"images/cube-5.svg\" width=40 height=40)]\n      .button(tabindex=0) + #[img.cube(src=\"images/cube-6.svg\" width=40 height=40)]\n      .button(tabindex=0) + #[img.cube(src=\"images/cube-7.svg\" width=40 height=40)]"
    },
    {
      "id": "symmetry-arithmetic",
      "content": "Spend some time playing around with the symmetry calculator, and try to find any\npatterns. Can you complete these observations?\n\n* Adding two rotations will always give [[a rotation|a reflection]] (or the identity).\n* Adding two reflections will always give [[a rotation|a reflection]] (or the identity).\n* Adding the same two symmetries in the opposite order\n  [[sometimes gives a different|always gives a different|always gives the same]] result.\n* Adding the identity [[doesn’t do anything|returns a reflection|returns the opposite]]."
    },
    {
      "id": "group-axioms",
      "content": "You might have realised already that adding __{.m-orange}symmetries__ is actually\nvery similar to adding __{.m-green}integers__:\n\n    ol.proof\n\n      li.r\n        | Adding two #[strong.m-orange symmetries]/#[strong.m-green integers] always gives another #[strong.m-orange symmetry]/#[strong.m-green integer]:\n        .text-center.axiom\n          img.cube(src=\"images/cube-2.svg\" width=32 height=32)\n          mo +\n          img.cube(src=\"images/cube-6.svg\" width=32 height=32)\n          mo(value=\"=\") =\n          img.cube(src=\"images/cube-4.svg\" width=32 height=32)\n        .text-center.axiom\n          mn 12\n          mo +\n          mn 7\n          mo =\n          mn 19\n        .next-step Continue\n\n      li.r.reveal(when=\"next-0\")\n        span.md Adding #[strong.m-orange symmetries]/#[strong.m-green integers] is [associative](gloss:associative):\n        .text-center.axiom\n          mfenced\n            img.cube(src=\"images/cube-1.svg\" width=32 height=32)\n            mo +\n            img.cube(src=\"images/cube-4.svg\" width=32 height=32)\n          mo +\n          img.cube(src=\"images/cube-3.svg\" width=32 height=32)\n          mo(value=\"=\") =\n          img.cube(src=\"images/cube-1.svg\" width=32 height=32)\n          mo +\n          mfenced\n            img.cube(src=\"images/cube-4.svg\" width=32 height=32)\n            mo +\n            img.cube(src=\"images/cube-3.svg\" width=32 height=32)\n        .text-center.axiom\n          mfenced #[mn 4]#[mo +]#[mn 2]\n          mo +\n          mn 5\n          mo =\n          mn 4\n          mo +\n          mfenced #[mn 2]#[mo +]#[mn 5]\n        .next-step Continue\n\n      li.r.reveal(when=\"next-1\")\n        | Every #[strong.m-orange symmetry]/#[strong.m-green integer] has an #[strong inverse], another #[strong.m-orange symmetry]/#[strong.m-green integer] which, when added, gives the identity:\n        .text-center.axiom\n          img.cube(src=\"images/cube-1.svg\" width=32 height=32)\n          mo +\n          img.cube(src=\"images/cube-3.svg\" width=32 height=32)\n          mo(value=\"=\") =\n          img.cube(src=\"images/cube-0.svg\" width=32 height=32)\n        .text-center.axiom\n          mn 4\n          mo +\n          mn –4\n          mo(value=\"=\") =\n          mn 0\n        .next-step Continue"
    },
    {
      "id": "groups-1",
      "content": "In mathematics, any collection that has these properties is called a\n[__group__](gloss:group). Some groups (like the __{.m-orange}symmetries__ of a\nsquare) only have a finite number of elements. Others (like the\n__{.m-green}integers__) are infinite.\n\nIn this example, we started with the eight symmetries of the square. In fact,\nevery geometric shape has its own __symmetry group__. They all have different\nelements, but they always satisfy the three rules above.\n\nGroups appear everywhere in mathematics. The elements can be numbers or\nsymmetries, but also polynomials, permutations, matrices, functions … _anything_\nthat obeys the three rules. The key idea of _group theory_ is that we are not\ninterested in the individual elements, just in _how they interact with each\nother_.\n\n::: column.grow\nFor example, the symmetry groups of different molecules can help scientists\npredict and explain the properties of the corresponding materials.\n\nGroups can also be used to analyse the winning strategy in board games, the\nbehaviour of viruses in medicine, different harmonies in music, and many other\nconcepts…\n::: column(width=340)\n\n    img(src=\"images/molecule.jpg\" width=160 height=160 style=\"margin-right: 20px\")\n    img(src=\"images/virus.jpg\" width=160 height=160)\n\n{.caption} The properties of the CCl<sub>4</sub> molecule (left) and the\nAdenovirus (right) are determined by their symmetries.\n:::"
    },
    {
      "id": "wallpaper-groups",
      "content": "### Wallpaper Groups\n\n\nIn the [previous sections](/course/transformations/symmetry) we saw two\ndifferent kinds of symmetry corresponding to two different transformations:\nrotations and reflections. But there is also a symmetry for the third kind of\nrigid transformation: [[translations|spins|flips]]."
    },
    {
      "id": "wallpaper-groups-1",
      "goals": "play-0 play-1",
      "content": "[__Translational symmetry__](gloss:translational-symmetry) does not work for\nisolated objects like flowers or butterflies, but it does for regular patterns\nthat extend into every direction:\n\n::: column.grow\n\n    .symmetry(style=\"width: 320px; height: 240px;\")\n      img(src=\"images/honeycomb.jpg\" width=376 height=276 style=\"margin: 0 0 -36px -56px; max-width: none;\")\n      img(src=\"images/honeycomb.jpg\" width=376 height=276 style=\"margin: 0 0 -36px -56px; max-width: none;\")\n      x-play-btn\n\n{.caption} Hexagonal honyecomb\n::: column.grow\n\n    .symmetry(style=\"width: 320px; height: 240px;\")\n      img(src=\"images/tiling.jpg\" width=376 height=240 style=\"margin-left: -56px; max-width: none;\")\n      img(src=\"images/tiling.jpg\" width=376 height=240 style=\"margin-left: -56px; max-width: none;\")\n      x-play-btn\n\n{.caption} Ceramic wall tiling\n:::"
    },
    {
      "id": "footsteps",
      "content": "In addition to reflectional, rotational and translational symmetry, there even\nis a fourth kind: [__glide reflections__](gloss:glide-reflection). This is a\ncombination of a reflection and a translation in the same direction as the axis\nof reflection.\n\n    figure\n      .footsteps\n         img(src=\"images/footsteps.svg\" width=650 height=120)\n         img(src=\"images/footsteps.svg\" width=650 height=120)\n      x-slider(steps=100, style=\"max-width: 400px; margin: 24px auto\")"
    },
    {
      "id": "wallpaper-groups-2",
      "content": "A pattern can have more than one type of symmetry. And just like for squares,\nwe can find the [symmetry group](gloss:symmetry-group) of a pattern, which\ncontains all its different symmetries.\n\nThese groups don’t tell you much about how the pattern _looks_ like (e.g. its\ncolours and shapes), just how it is _repeated_. Multiple different patterns can\nhave the same symmetry group – as long are arranged and repeated in the same\nway.\n\n::: column.grow\n\n    .text-center\n      img(src=\"images/wallpaper-1.svg\" width=150 height=150 style=\"margin: 0 10px\")\n      img(src=\"images/wallpaper-2.svg\" width=150 height=150 style=\"margin: 0 10px\")\n\n{.caption} These two patterns have the same symmetries, even though they look\nvery different. But symmetries are not about colours, or superficial shapes.\n::: column.grow\n\n    .text-center\n      img(src=\"images/wallpaper-3.svg\" width=150 height=150 style=\"margin: 0 10px\")\n      img(src=\"images/wallpaper-4.svg\" width=150 height=150 style=\"margin: 0 10px\")\n\n{.caption} These two patterns also have the same symmetries – even though they\nlook more similar to the corresponding patterns on the left, than to each other.\n:::"
    },
    {
      "id": "wallpaper-groups-3",
      "goals": "gallery",
      "content": "It turns out that, while there are infinitely many possible patterns, they all\nhave one of just 17 different symmetry groups. These are called the __Wallpaper\nGroups__. Every wallpaper group is defined by a combination of translations,\nrotations, reflections and glide reflections. Can you see the [centers of\nrotation](gloss:center-of-rotation) and the [axes of\nreflection](gloss:axis-of-symmetry) in these examples?\n\n    x-gallery(slide-width=\"320\")\n      div\n        img(src=\"images/wallpapers/p1.svg\" width=360, height=240)\n        p.caption <strong>Group 1 – P1</strong><br>Only translations\n      div\n        img(src=\"images/wallpapers/p2.svg\" width=360, height=240)\n        p.caption <strong>Group 2 – P2</strong><br>Rotations of order 2, translations\n      div\n        img(src=\"images/wallpapers/p3.svg\" width=360, height=240)\n        p.caption <strong>Group 3 – P3</strong><br>Rotations of order 3 (120°), translations\n      div\n        img(src=\"images/wallpapers/p4.svg\" width=360, height=240)\n        p.caption <strong>Group 4 – P4</strong><br>Four rotations of order 2 (180°), translations\n      div\n        img(src=\"images/wallpapers/p6.svg\" width=360, height=240)\n        p.caption <strong>Group 5 – P6</strong><br>Rotations of order 2, 3 and 6 (60°), translations\n      div\n        img(src=\"images/wallpapers/pm.svg\" width=360, height=240)\n        p.caption <strong>Group 6 – PM</strong><br>Parallel axes of reflection, translations\n      div\n        img(src=\"images/wallpapers/pmm.svg\" width=360, height=240)\n        p.caption <strong>Group 7 – PMM</strong><br>Perpendicular reflections, rotations of order 2, translations\n      div\n        img(src=\"images/wallpapers/p4m.svg\" width=360, height=240)\n        p.caption <strong>Group 8 – P4M</strong><br>Rotations (ord 2 + 4), reflections, glide reflections, translations\n      div\n        img(src=\"images/wallpapers/p6m.svg\" width=360, height=240)\n        p.caption <strong>Group 9 – P6M</strong><br>Rotations (ord 2 + 6), reflections, glide reflections, translations\n      div\n        img(src=\"images/wallpapers/p3m1.svg\" width=360, height=240)\n        p.caption <strong>Group 10 – P3M1</strong><br>Rotations of order 3, reflections, glide reflections, translations\n      div\n        img(src=\"images/wallpapers/p31m.svg\" width=360, height=240)\n        p.caption <strong>Group 11 – P31M</strong><br>Rotations of order 3, reflections, glide reflections, translations\n      div\n        img(src=\"images/wallpapers/p4g.svg\" width=360, height=240)\n        p.caption <strong>Group 12 – P4G</strong><br>Rotations (ord 2 + 4), reflections, glide reflections, translations\n      div\n        img(src=\"images/wallpapers/cmm.svg\" width=360, height=240)\n        p.caption <strong>Group 13 – CMM</strong><br>Perpendicular reflections, rotations of order 2, translations\n      div\n        img(src=\"images/wallpapers/pmg.svg\" width=360, height=240)\n        p.caption <strong>Group 14 – PMG</strong><br>Reflections, glide reflections, rotations of order 2, translations\n      div\n        img(src=\"images/wallpapers/pg.svg\" width=360, height=240)\n        p.caption <strong>Group 15 – PG</strong><br>Parallel glide reflections, translations\n      div\n        img(src=\"images/wallpapers/cm.svg\" width=360, height=240)\n        p.caption <strong>Group 16 – CM</strong><br>Reflections, glide reflections, translations\n      div\n        img(src=\"images/wallpapers/pgg.svg\" width=360, height=240)\n        p.caption <strong>Group 17 – PGG</strong><br>Perpendicular glide reflections, rotations of order 2, translations"
    },
    {
      "id": "drawing",
      "title": "Drawing Wallpaper Symmetries",
      "goals": "draw-1 draw-2 switch",
      "content": "Unfortunately there is no simple reason why there are _17_ of these groups, and proving it requires\nmore advanced mathematics. Instead, you can try drawing your own repeated patterns for each of the\n17 wallpaper groups:\n\n    figure: x-wallpaper\n    .other-students.reveal(when=\"draw-1 switch\")\n      h4 Examples of other students’ drawings\n      .row.padded-thin\n        div(style=\"width: 224px\"): img(src=\"images/user/wallpaper-1.png\" width=240 height=160)\n        div(style=\"width: 224px\"): img(src=\"images/user/wallpaper-2.png\" width=240 height=160)\n        div(style=\"width: 224px\"): img(src=\"images/user/wallpaper-3.png\" width=240 height=160)"
    },
    {
      "id": "crystallographic-groups",
      "content": "::: column.grow\nThe wallpaper groups were all about flat, two-dimensional patterns. We can do\nsomething similar for three-dimensional patterns: these are called\ncrystallographic groups, and there are 219 of them!\n\nIn addition to translations, reflections, rotations, and glide reflections,\nthese groups include symmetries like __glide planes__ and __screw axes__ (think\nabout the motion when unscrewing a bottle).\n::: column(width=300)\n\n    img(src=\"images/crystal.jpg\" width=300 height=240)\n\n{.caption} Boron-Nitride has its molecules arranged in this crystal lattice,\nwhich has a three-dimensional symmetry group.\n:::"
    },
    {
      "id": "planets",
      "sectionBackground": "dark stars",
      "section": "physics",
      "content": "## Symmetry in Physics\n\n\nSo far, all the symmetries we looked at were _visual_ in some sense: visible\nshapes, images or patterns. In fact, symmetry can be a much wider concept:\n_immunity to change_.\n\nFor example, if you like apple juice just as much as you like orange juice, then\nyour preference is “symmetric” under the transformation that swaps apples and\noranges.\n\nIn 1915, the German mathematician [Emmy Noether](bio:noether) observed that\nsomething similar is true for the [laws of nature](gloss:laws-of-nature).\n\n::: column.grow\nFor example, our experience tells us that the laws of Physics are the same\neverywhere in the universe. It doesn’t matter if you conduct an experiment in\nLondon, or in New York, or on Mars – the laws of Physics should always be the\nsame. In a way, they have [[translational symmetry|reflectional symmetry]].\n\n{.reveal(when=\"blank-0\")} Similarly, it shouldn’t matter if we conduct an\nexperiment while facing North, or South, or East or West: the laws of nature\nhave [[rotational symmetry|glide reflection symmetry]].\n\n{.reveal(when=\"blank-1\")} And finally, it shouldn’t matter if we conduct an\nexperiment today, or tomorrow, or in a year. The laws of nature are\n“time-symmetric”.\n::: column(width=300)\n\n    include svg/planets.svg\n\n:::"
    },
    {
      "id": "planets-1",
      "content": "These “symmetries” might initially seem quite meaningless, but they can actually\ntell us a lot about our universe. Emmy Noether managed to prove that every\nsymmetry corresponds to a certain physical quantity that is _conserved_.\n\nFor example, time-symmetry implies that __Energy__ must be conserved in our\nuniverse: you can convert energy from one type to another (e.g. light to electricity), but you can never create or destroy energy. The total amount of energy in the universe will always stay constant.\n\n    figure\n      x-img(src=\"images/cern.jpg\" width=760 height=400 credit=\"© CERN\" alt=\"Large Hadron Collider in CERN\")\n      p.caption CERN is the world’s largest particle accelerator. Scientists smash together fundamental particles at enormous speeds, to learn more about their properties. Can you see the person at the bottom, for size comparison?\n\n::: column(width=220)\n\n    x-img(src=\"images/higgs.png\" width=220 height=150 alt=\"Particle Fragments\")\n    p.caption The paths taken by particle fragments after a collision\n\n::: column.grow\nIt turns out that, just by knowing about symmetry, physicists can derive most\nlaws of nature that govern our universe – without ever having to do an\nexperiment or observation.\n\nSymmetry can even predict the existence of fundamental particles. One example is\nthe famous __Higgs Boson__: it was predicted in the 1960s by theoretical\nphysicists, but not observed in the real world until 2012.\n:::"
    },
    {
      "id": "dilations",
      "section": "dilations",
      "content": "## Dilations\n\n\nSo far, we have just looked at [[rigid|congruent|visual]] transformations.\n_{span.reveal(when=\"blank-0\")} Now let’s think about one that is not: a\n[__dilation__](gloss:dilation) changes a shape’s size by making it larger or\nsmaller._"
    },
    {
      "id": "dilations-1",
      "content": "::: column.grow\n\nAll dilations have a [__center__](target:center) and a [__scale factor__](->.scale-target).\nThe center is the point of reference for the dilation and scale factor tells us\nhow much the figure stretches or shrinks.\n\nIf the [scale factor](gloss:scale-factor) is between 0 and 1, the image is\n[[smaller|larger]] than the original. If the scale factor is larger than 1, the\nimage is [[larger|smaller]] than the original.\n\n::: column(width=300)\n\n    x-geopad(width=300 height=240): svg\n      circle.move(name=\"C\" cx=40 cy=35 target=\"center\")\n\n      circle(hidden name=\"a\" x=\"point(140,55)\")\n      circle(hidden name=\"b\" x=\"point(160,115)\")\n      circle(hidden name=\"c\" x=\"point(60,130)\")\n\n      circle(hidden name=\"a1\" x=\"a.subtract(C).scale(s).add(C)\")\n      circle(hidden name=\"b1\" x=\"b.subtract(C).scale(s).add(C)\")\n      circle(hidden name=\"c1\" x=\"c.subtract(C).scale(s).add(C)\")\n\n      path.fill.green(x=\"polygon(a,b,c)\" label=\"A\" label-class=\"white\")\n      path.fill.blue(x=\"polygon(a1,b1,c1)\" label=\"A’\" label-class=\"white\")\n\n      path.light.thin(x=\"segment(C,s<1?a:a1)\")\n      path.light.thin(x=\"segment(C,s<1?b:b1)\")\n      path.light.thin(x=\"segment(C,s<1?c:c1)\")\n\n{.text-center.scale-target} Scale factor: ${s}{s|2|0,3,0.1}\n:::\n\n{.todo} COMING SOON – More on Dilations\n\n    // Here is how we can construct the dilation of a geometric shape:\n    //\n    // ::: column(width=300)\n    // {.todo} COMING SOON – Animation\n    // ::: column.grow\n    // First we draw rays from the center of dilation to every point in the shape.\n    //\n    // Now let’s measure the distance of all these points from the center of dilation.\n    // Then we can multiply the distance by the scale factor, and the measure the\n    // image of the point along the same ray.\n    //\n    // All that’s left is to connect the transformed points in the image … all done!\n    // :::"
    },
    {
      "section": "similarity",
      "sectionStatus": "dev",
      "id": "similarity",
      "content": "## Similarity\n\n\n::: column.grow\nFor rigid transformations, the image is always [[congruent|larger|smaller]] to\nthe original – but this is [[no longer|still]] true for dilations. Instead, we\nsay that two shapes are [__similar__](gloss:similar). They have the same overall\nshape, but not necessarily the same size.\n\nThe symbol for similarity is `∼` (similar to the symbol for congruence, which\nwas `≅`). In this example, we would write `A ∼ A'`.\n\n::: column(width=240)\n{.todo} COMING SOON – Illustration\n:::"
    },
    {
      "id": "perspective",
      "content": "### Perspective Drawings\n\nYou might have noticed that these dilations with the connecting rays almost look\nlike __perspective drawings__. The center of dilation is called the __vanishing\npoint__, because it looks like this is where everything is “vanishing in the\ndistance”.\n\nFind the vanishing point in the figure below:\n\n{.todo} COMING SOON – Interactive\n\nNow can you draw another house that matches the existing ones?"
    },
    {
      "id": "similar-polygons",
      "content": "### Similar Polygons\n\nSimilarity can tell us a lot about shapes. For example, [circles](gloss:circle),\n[squares](gloss:square) and [equilateral triangles](gloss:equilateral-triangle)\nare [[always|sometimes|never]] similar. They might have different sizes, but\nalways the same general shape.\n\n::: column.grow\nThe two quadrilaterals on the right are similar. Our first important observation\nis that in similar polygons, all the matching pairs of angles are\n[congruent](gloss:congruent-angles). This means that\n\n{.text-center} [_{.m-red}∡ABC_ ≅ _{.m-red}∡A'B'C'_](target:a)_{.space}_\n[_{.m-blue}∡BCD_ ≅ _{.m-blue}∡B'C'D'_](target:b)\n[_{.m-green}∡CDE_ ≅ _{.m-green}∡C'D'E'_](target:c)_{.space}_\n[_{.m-yellow}∡DEA_ ≅ _{.m-yellow}∡D'E'A'_](target:d)\n\nThe second important fact is that in similar polygons, all sides are scaled\n__proportionally__ by the scale factor of the corresponding dilation. If the\nscale factor is ${k}{k|1.5|0.5,2,0.1}, then\n\n{.text-center} `abs(AB) ×` ${k} `= abs(A'B')`_{.space}_`abs(BC) ×` ${k} `= abs(B'C')`\n`abs(CD) ×` ${k} `= abs(C'D')`_{.space}_`abs(DE) ×` ${k} `= abs(D'E')`\n\nWe can instead rearrange these equations and eliminate the scale factor\nentirely:\n\n{.text-center} `abs(AB)/abs(A'B') = abs(BC)/abs(B'C') = abs(AB)/abs(A'B') = abs(AB)/abs(A'B')`\n\n    // This proportional relationship is true not just for the sides of the\n    // polygon, but also for properties like diagonals.\n\nWe can use this to solve real life problems that involve similar polygons – for\nexample finding the length of missing sides, if we know some of the other sides.\nIn the following section you will see a few examples.\n::: column(width=240)\n\n    x-geopad.sticky(width=240 height=360): svg\n      - var x = ['a', 'b', 'c', 'd']\n      - var initial = {a:[50,70], b:[160,50], c:[200,110], d:[150,160]}\n      - var next = {a:'b', b:'c', c:'d', d:'a'}\n      - var prev = {a:'d', b:'a', c:'b', d:'c'}\n      - var classes = {a:'red', b:'blue', c:'green', d:'yellow'}\n      each l in x\n        circle(name=l x=`point(${initial[l][0]},${initial[l][1]})` r=4 target=l)\n        path(x=`angle(${prev[l]},${l},${next[l]})` target=l class=classes[l])\n        path(x=`segment(${l},${next[l]})` target=`${l} ${next[l]}`)\n        circle(name=l+'1' r=4 x=`${l}.subtract({x:120,y:90}).scale(k).rotate(3).add({x:120,y:270})` target=l)\n        path(x=`angle(${prev[l]}1,${l}1,${next[l]}1)` target=l class=classes[l])\n        path(x=`segment(${l}1,${next[l]}1)` target=`${l} ${next[l]}`)\n:::"
    },
    {
      "id": "similar-triangles",
      "content": "### Similar Triangles\n\nThe concept of similarity is particularly powerful with triangles. We already\nknow that the corresponding internal angles in similar polygons are equal.\n\nFor triangles, the opposite is also true: this means that if you have two\ntriangles with the same three angle sizes, then the triangles must be similar.\n\nAnd it gets even better! We know that the internal angles in a triangle always\nadd up to [[180]]°. This means that if we know two angles in a triangle, we can\nalways work out the third one.\n\nFor similarity, this means that we also just need to check _two angles_ to\ndetermine if triangles are similar. If two triangles have two angles of the same\nsize, then the third angle must also be the same in both.\n\nThis result is sometimes called the [__AA Similarity Condition__](gloss:triangle-aa)\nfor triangles. (The two _As_ stand for the two _angles_ we compare.)\n\n::: .theorem\nIf two angles in one triangle are congruent to two angles in another triangle,\nthe two triangles are similar.\n:::"
    },
    {
      "id": "similar-triangles-1",
      "content": "Let’s have a look at a few examples where this is useful:\n\n::: column(width=320)\n{.todo} COMING SOON – Animation\n\n::: column.grow\nHere you can see the image of a large lighthouse. Together with a friend, you\nwant to measure the height of the lighthouse, but unfortunately we cannot climb\nto the top.\n\nIt turns out that, very well hidden, the diagram contains two similar triangles:\none is formed by the lighthouse and its shadow, and one is formed by your friend\nand her shadow.\n\nBoth triangles have one right angle at the bottom. The sun rays are parallel,\nwhich means that the other two angles at the bottom are corresponding angles,\nand also equal. By the AA condition for triangles, these two must be similar.\n\nWe can easily measure the length of the shadows, and we also know the height of\nyour friend. Now we can use the proportionality of sides in similar triangles\nto find the height of the lighthouse:\n\n{.todo} COMING SOON – Equation\n\nTherefore the lighthouse is 1.5m tall.\n:::"
    },
    {
      "id": "similar-triangles-2",
      "content": "::: column(width=320)\n{.todo} COMING SOON – Animation\n::: column.grow\nWe can use the same technique to measure distances on the ground. Here we want\nto find the width of a large river. There is a big tree on one side of the\nriver, and I’ve got a stick that is one meter long.\n\nTry drawing another two similar triangles in this diagram.\n\nYou can mark the point along the side of the river, that lies directly on the\nline of sight from the end of the stick to the tree. Then we can measure the\ndistances to the stick, and to the point directly opposite the tree.\n\nOnce again, these two triangles are similar because of the AA condition. They\nboth have a right angle, and on pair of opposite angles.\n\nAccording to the proportionality rule, this means that\n\n{.todo} COMING SOON – Equation\n\nTherefore the width of the river is 45 meters.\n:::"
    },
    {
      "content": "### Similarity on Rays\n\nTheorem: If a ray bisects an angle of a triangle, then it divides the\nopposite side into segments that are proportional to the lengths of the\nother two sides.\n\nWe can extend this theorem to a situation outside of triangles where we\nhave multiple parallel lines cut by transverals.\n\nTheorem: If three or more parallel lines are cut by two transversals, then they\ndivide the transversals proportionally.\n\nThink about a midsegment of a triangle. A midsegment is parallel to one side of\na triangle and divides the other two sides into congruent halves. The midsegment\ndivides those two sides proportionally.\n\nTriangle Proportionality Theorem: If a line parallel to one side of a triangle\nintersects the other two sides, then it divides those sides proportionally.\n\nTriangle Proportionality Theorem Converse: If a line divides two sides of a\ntriangle proportionally, then it is parallel to the third side."
    },
    {
      "content": "### Self Similarity\n\nThere are some curious mathematical shapes that are similar to a smaller part\n_of themselves_. An example is the __Sierpinksi Triangle__: the entire triangle\nis similar to any one of the smaller triangles it consists on. You could zoom\nin and infinitely many smaller and smaller triangles.\n\nShapes with this property are called __Fractals__. They have some surprising\nand truly XXX properties, which you will learn about more in the future."
    },
    {
      "content": "Triangles are not just useful for measuring distances. In the next course we\nwill learn a lot more about triangles and their properties."
    }
  ],
  "title": "Transformations and Symmetry"
}