{
  "sections": [
    {
      "id": "intro",
      "section": "introduction",
      "description": "\"Triangles are some of the most important shapes in geometry: they have countless interesting properties and appear everywhere in engineering and technology.\"",
      "color": "\"#3566DE\"",
      "level": "Intermediate",
      "next": "polyhedra",
      "content": "# Triangles and Trigonometry\n\n## Introduction\n\n\n::: column.grow\nBy the early 19th century, explorers had discovered most of the world. Trade and\ntransportation was booming between distant countries, and this created a need\nfor _accurate maps_ of the entire planet.\n\nToday we have satellites that can take photos from above – but 200 years ago,\ncreating maps was a difficult and time consuming task. It was done by\nmathematicians like [Radhanath Sikdar](bio:sikdar), who worked on the _Great\nTrigonometrical Survey_: a century-long project to measure all of India,\nincluding the Himalayan mountain range.\n\n::: column(width=240)\n\n    x-img.shift-1(src=\"images/theodolite.jpg\" width=240 height=320 credit=\"Science & Society Picture Library\")\n\n{.caption} The _theodolite_, a surveying instrument\n:::\n\nOf particular interest was the quest to find the highest mountain on Earth.\nThere were a few different candidates, but from hundreds of kilometers away, it\nwas difficult to tell which one was the highest.\n\nSo how do you measure the height of a mountain?\n\n    figure.mountain: include svg/mountain.svg\n\n{.r} Today we can use satellites to measure the height of mountains to within a\nfew centimeters – but these did not exist when Radhanath was surveying India.\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-0\")} Climbers use _altimeters_ to determine their altitude.\nThese devices use the difference in air pressure at different heights. However\nthis would have required someone to actually climb to the [top of every\nmountain](->.mountain-top) – an extremely difficult feat that was not achieved\nuntil a century later.\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-1\")} You could also try using similar triangles, like we\ndid in the [previous course](/course/transformations/similarity).\nThis method requires knowing the [distance](->.mountain-distance) to the [base\nof the mountain](->.mountain-base): the point at sea level that lies directly below\nits summit. We can do this for trees or tall buildings, but for mountains this\npoint is hidden underneath hundreds of meters of rock.\n[Continue](btn:next)"
    },
    {
      "id": "intro-2",
      "content": "::: column(width=320)\n\n    x-img(src=\"images/hillary.jpg\" width=320 height=190)\n\n{.caption} Edmund Hillary and Tenzing Norgay were the first to reach the top of\nMount Everest, in 1953.\n\n::: column.grow\nBut there are more advanced geometric techniques, which [Radhanath](bio:sikdar)\nused to discover the highest mountain on Earth: it is now called _Mount Everest_.\nHis measurement is only a few meters off today’s official height of 8848 meters.\n\nIn this course you will learn about many different features and properties of\ntriangles. These will allow you to measure the height of mountains, but they are\nalso of fundamental importance in many other areas of mathematics, science and\nengineering.\n[Continue](btn:next)\n:::"
    },
    {
      "id": "applications",
      "content": "Triangles are special because they are particularly _strong_. They are the only\npolygon that, when made out of wooden beams and hinges, will be completely\n_rigid_ – unlike rectangles, for example, which you can easily push over.\n\n{.todo} COMING SOON – Animations"
    },
    {
      "id": "applications-1",
      "content": "This property makes triangles particularly useful in construction, where they\ncan carry heavy weights.\n\n::: column(width=200)\n    x-img(src=\"images/truss-bridge.jpg\" credit=\"© ykanazawa1999, Flickr\" width=200 height=200 lightbox)\n\n{.caption} A “Truss bridge” is supported by triangular bars\n::: column(width=200)\n    x-img(src=\"images/pylon.jpg\" width=200 height=200 lightbox)\n\n{.caption} Triangles in high-voltage electricity Pylons\n::: column(width=200)\n    x-img(src=\"images/bike.jpg\" width=200 height=200 lightbox)\n\n{.caption} Even bikes use triangles for stability.\n:::"
    },
    {
      "id": "applications-2",
      "goals": "video",
      "content": "Triangles are also the simplest polygon, with the fewest sides. This makes them\nparticularly well suited to approximating complex curved surfaces. This is done\nin physical building…\n\n::: column(width=200)\n    x-img(src=\"images/st-mary.jpg\" credit=\"Kunstlerbob, Wikipedia\" width=200 height=200 lightbox)\n\n{.caption} “The Gherkin”, a skyscraper in London\n::: column(width=200)\n    x-img(src=\"images/hk-bank.jpg\" credit=\"WiNG, Wikipedia\" width=200 height=200 lightbox)\n\n{.caption} Bank of China Tower in Hong Kong\n::: column(width=200)\n    x-img(src=\"images/museum.jpg\" credit=\"Andrew Dunn, Wikipedia\" width=200 height=200 lightbox)\n\n{.caption} Courtyard of the British Museum in London\n:::\n\n::: column.grow\n…but also in virtual worlds. In computer generated graphics (e.g. for movies or\nvideo games), all surfaces are approximated using a “mesh” of tiny triangles.\nArtists and software engineers need to know about geometry and trigonometry in\norder to be able to move and transform these triangles realistically, and to\ncalculate their colour and texture.\n::: column(width=220)\n    x-img(src=\"images/dolphin.jpg\" width=220 height=135)\n:::\n\n    figure: x-video(src=\"https://static.mathigon.org/videos/tiger.mp4\" poster=\"images/tiger.jpg\" width=480 height=270 credit=\"© UCTV, The STEAM Channel\")\n    //- src: https://www.youtube.com/watch?v=Y9PYzdFsVio"
    },
    {
      "id": "angle-sum",
      "section": "properties",
      "content": "## Properties of Triangles\n\n\nLet’s start simple: a triangle is a closed shape that has three sides (which\nare [line segments](gloss:line-segment)) and three vertices (the\n[points](gloss:point) where the sides meet). It also has three [internal\nangles](gloss:internal-angle), and we already know that the sum of them is\nalways [[180]]°."
    },
    {
      "id": "classification",
      "content": "We can classify triangles by the size of their angles:\n\n::: column(width=220)\n\n    x-geopad(width=220): svg\n      circle(name=\"a1\" x=\"point(40,60)\")\n      circle(name=\"b1\" x=\"point(40,140)\")\n      circle(name=\"c1\" x=\"point(180,140)\")\n      path.fill.red(x=\"angle(a1,b1,c1)\")\n      path(x=\"polygon(a1,b1,c1)\")\n\n{.caption} A __right-angled triangle__<br>\nhas one [right angle](gloss:right-angle).\n::: column(width=220)\n\n    x-geopad(width=220): svg\n      circle(name=\"a2\" x=\"point(30,30)\")\n      circle(name=\"b2\" x=\"point(150,60)\")\n      circle(name=\"c2\" x=\"point(190,190)\")\n      path.fill.blue(x=\"angle(c2,b2,a2)\")\n      path(x=\"polygon(a2,b2,c2)\")\n\n{.caption} An __obtuse triangle__<br>\nhas one [obtuse angle](gloss:obtuse-angle).\n::: column(width=220)\n\n    x-geopad(width=220): svg\n      circle(name=\"a3\" x=\"point(60,50)\")\n      circle(name=\"b3\" x=\"point(30,180)\")\n      circle(name=\"c3\" x=\"point(190,130)\")\n      path.fill.green(x=\"angle(a3,b3,c3)\")\n      path.fill.green(x=\"angle(b3,c3,a3)\")\n      path.fill.green(x=\"angle(c3,a3,b3)\")\n      path(x=\"polygon(a3,b3,c3)\")\n\n{.caption} An __acute triangle__<br>\nhas [[three]] [acute angles](gloss:acute-angle).\n:::"
    },
    {
      "id": "labels",
      "content": "::: column.grow\nFor convenience, we always label triangles in the same way. The vertices are\nlabelled with capital letters [_A_, _B_ and _C_](target:vertex), the sides are\nlabelled with lowercase letters [_a_, _b_ and _c_](target:side), and the angles\nare labelled with Greek letters [`α`, `β` and `γ`](target:angle) (“alpha”, “beta” and\n“gamma”).\n\nThe [side that lies _opposite_ vertex _A_](target:X) is labeled _a_, and the\n[angle that lies right next to _A_](target:Y) is labelled `α`. The same pattern\nworks for _B_/_b_/`β` and for _C_/_c_/`γ`.\n::: column(width=220)\n\n    x-geopad(width=220 height=200): svg\n      circle.move.red(name=\"a\" cx=80 cy=30 label=\"A\" target=\"vertex X Y\")\n      circle.move.blue(name=\"b\" cx=30 cy=170 label=\"B\" target=\"vertex\")\n      circle.move.green(name=\"c\" cx=190 cy=150 label=\"C\" target=\"vertex\")\n      path.red(x=\"angle(c,a,b).sup\" label=\"α\" target=\"angle Y\")\n      path.blue(x=\"angle(a,b,c).sup\" label=\"β\" target=\"angle\")\n      path.green(x=\"angle(b,c,a).sup\" label=\"γ\" target=\"angle\")\n      path.red(x=\"segment(b,c)\" label=\"a\" target=\"side X\")\n      path.blue(x=\"segment(a,c)\" label=\"b\" target=\"side\")\n      path.green(x=\"segment(b,a)\" label=\"c\" target=\"side\")\n\n:::"
    },
    {
      "id": "medians",
      "goals": "s0 s1 s2 move",
      "content": "### Medians\n\n::: column(width=300)\n\n    x-geopad.sticky(width=300 tools=\"move|line\" projections=\"no\"): svg\n      circle.move(name=\"a\" cx=75 cy=75 target=\"ratio\")\n      circle.move(name=\"b\" cx=50 cy=250)\n      circle.move(name=\"c\" cx=250 cy=200)\n      path(x=\"triangle(a,b,c)\")\n\n      circle.green(name=\"ab\" x=\"line(a,b).midpoint\")\n      circle.blue(name=\"ac\" x=\"line(a,c).midpoint\")\n      circle.red(name=\"bc\" x=\"line(b,c).midpoint\" target=\"ratio\")\n\n      circle.yellow.reveal(name=\"d\" x=\"triangle(a,b,c).centroid\" when=\"blank-0\" animation=\"pop\" target=\"ratio\")\n\n      path.red.transparent(x=\"segment(a,d)\" label=\"2\" target=\"ratio\")\n      path.red.transparent(x=\"segment(d,bc)\" label=\"1\" target=\"ratio\")\n\n::: column.grow\nHere you can see a triangle as well as the [midpoints](gloss:midpoint) of its\nthree sides.\n\nA [__median__](gloss:triangle-median) of a triangle is a line segment that joins\na vertex and the midpoint of the opposite side. Draw the three medians of this\ntriangle. _{span.reveal(when=\"s0 s1 s2\")}What happens as you move the vertices\nof the triangle?_\n\n{.reveal(when=\"move\")} It seems like the medians always [[intersect in one\npoint|have the same length|divide each other in the middle]].\n_{span.reveal(when=\"blank-0\")}This point is called the\n[__centroid__](gloss:centroid)._\n\n{.reveal(when=\"blank-0\")} Medians always divide each other in the\n[ratio 2:1](target:ratio). For each of the three medians, the distance from the\nvertex to the centroid is always [[twice|three times|exactly]] as long as the\ndistance from the centroid to the midpoint.\n:::"
    },
    {
      "id": "center-of-mass",
      "content": "The centroid is also the “balancing point” of a triangle. Draw a triangle on\nsome cardboard, cut it out, and find the three medians. If you were accurate,\nyou can now balance the triangle on the tip of a pencil, or hang it perfectly\nlevel from a piece of string that’s attached to its centroid:\n\n    figure: img(src=\"images/center-of-mass.jpg\" width=600 height=190)\n\nThis works because the weight of the triangle is evenly distributed around the\ncentroid. In physics, this point is often called the __center of mass__.\n\n    // Any straight line that goes through the centroid divides the triangle into two\n    // parts that have exactly the same area. Move the [blue point](target:move) in the\n    // figure on the right. The red and green areas will always have the same area.\n\n    // x-geopad(width=220): svg\n      circle.move(name=\"a\" cx=70 cy=50)\n      circle.move(name=\"b\" cx=60 cy=160)\n      circle.move(name=\"c\" cx=180 cy=130)\n      circle.yellow(x=\"triangle(a,b,c).centroid\" name=\"d\")\n      circle.move.blue.pulsate(name=\"p\" cx=50 cy=50 project=\"circle(point(110,110),100)\" target=\"move\")\n      circle(hidden name=\"q\" x=\"p.rotate(pi,d)\")\n\n      path.dark(x=\"triangle(a,b,c)\" name=\"t\")\n      path.fill.green.light(x=\"t.intersect(polygon(p,q,p.rotate(pi/2,q),q.rotate(-pi/2,p)))\")\n      path.fill.red.light(x=\"t.intersect(polygon(p,q,p.rotate(-pi/2,q),q.rotate(pi/2,p)))\")\n      path.blue(x=\"line(p,d)\")"
    },
    {
      "id": "circumcircle",
      "goals": "s0 s1 s2",
      "content": "### Perpendicular Bisectors and Circumcircle\n\n::: column(width=300)\n\n    x-geopad.sticky(tools=\"move|perpBisector\" width=300 projections=\"no\"): svg\n      circle.move(name=\"a\" cx=75 cy=75 label=\"A\" target=\"b-blue b-red\")\n      circle.move(name=\"b\" cx=50 cy=250 label=\"B\" target=\"b-red\")\n      circle.move(name=\"c\" cx=250 cy=200 label=\"C\" target=\"b-blue\")\n      path(x=\"triangle(a,b,c)\")\n\n      circle.reveal.red(x=\"line(a,b).midpoint\" when=\"blank-0\")\n      circle.reveal.blue(x=\"line(a,c).midpoint\" when=\"blank-0\")\n      circle.reveal.green(x=\"line(b,c).midpoint\" when=\"blank-0\")\n\n      circle.reveal.yellow(x=\"triangle(a,b,c).circumcircle.c\" name=\"d\" when=\"s0 s1 s2\" target=\"center\")\n      path.yellow(hidden x=\"arc(d,c,1.99*pi)\" name=\"circumcircle\")\n\n::: column.grow\nRecall that the [perpendicular bisector](gloss:perpendicular-bisector) of a line\nis the perpendicular line that goes through its [[midpoint|endpoints]].\n\n{.reveal(when=\"blank-0\")}Draw the perpendicular bisector of all three sides of\nthis triangle. _{.lgrey} To draw the perpendicular bisector of a side of the\ntriangle, simply click and drag from one of its endpoints to the other._\n\n{.reveal(when=\"s0 s1 s2\")} Like before, the three perpendicular bisectors meet in a\nsingle point. And again, this point has a special property.\n\n{.reveal(when=\"s0 s1 s2\")} Any point on a perpendicular bisector has the same\ndistance from the two endpoints of the lines it bisects. For example, any point\non the [{.blue} blue bisector](target:b-blue) has the same distance from points _A_ and\n_C_ and any point on the [{.red} red bisector](target:b-red) has the same distance from\npoints [[A and B|A and C|B and C]].\n\n{.reveal(when=\"blank-1\")} The [{.yellow} intersection point](target:center) lies on all\nthree perpendicular bisectors, so it must have the same distance from all three\n[[vertices|sides]] of the triangle.\n\n{.reveal(when=\"blank-2\")} This means we can draw a circle around it that\nperfectly touches all the vertices. This circle is called the\n[__circumcircle__](gloss:circumcircle) of the triangle, and the center is called\nthe __circumcenter__.\n:::"
    },
    {
      "id": "circumcircle-1",
      "content": "In fact, this means that if you are given any three points, you can use the\ncircumcenter to find a circle that goes through all three of them. (Unless the\npoints are [[collinear|parallel]], in which case they all lie on a straight line.)"
    },
    {
      "id": "incircle",
      "goals": "s0 s1 s2",
      "content": "### Angle Bisectors and Incircle\n\nYou’re probably getting the hang of this now: we pick a certain construction, do\nit three times for all sides/angles of the triangles, and then we work out\nwhat’s special about their intersection.\n\n::: column(width=300)\n\n    x-geopad.sticky(tools=\"move|angleBisector\" width=300 projections=\"no\"): svg\n      circle.move(name=\"a\" cx=75 cy=75)\n      circle.move(name=\"b\" cx=50 cy=250 target=\"b-blue\")\n      circle.move(name=\"c\" cx=250 cy=200 target=\"b-red\")\n\n      path.fill.light.red(x=\"angle(c,a,b).sup\" name=\"xa\")\n      path.fill.light.blue(x=\"angle(a,b,c).sup\" name=\"xb\")\n      path.fill.light.green(x=\"angle(b,c,a).sup\" name=\"xc\")\n\n      path(x=\"segment(a,b)\" label=\"a\" target=\"b-blue b-red\")\n      path(x=\"segment(a,c)\" label=\"b\" target=\"b-red\")\n      path(x=\"segment(b,c)\" label=\"c\" target=\"b-blue\")\n\n      circle.reveal.yellow(x=\"triangle(a,b,c).incircle.c\" when=\"s0 s1 s2\" target=\"center\")\n      path.yellow(hidden x=\"arc(triangle(a,b,c).incircle.c,triangle(a,b,c).incircle.at(0),1.999*pi)\" name=\"incircle\")\n\n::: column.grow\nRecall that the [angle bisector](gloss:angle-bisector) divides an angle exactly\nin the middle. Draw the angle bisector of the three angles in this triangle.\n_{.lgrey} To draw an angle bisector, you have to click on three points that form\nthe angle you want to bisect._\n\n{.r.reveal(when=\"s0 s1 s2\")} Once again, all three lines intersect at one point.\nYou probably expected something like this, but it is important to notice that\nthere is no obvious reason why this should happen – triangles are just very\nspecial shapes!\n[Continue](btn:next)\n\n{.reveal(when=\"next-0\")} Points that lie on an angle bisector have the same\ndistance from the two lines that form the angle. For example any point on the\n[{.blue} blue bisector](target:b-blue) has the same distance from side _a_ and side _c_,\nand any point on the [{.red} red bisector](target:b-red) has the same distance from\nsides [[a and b|a and c|b and c]].\n\n{.reveal(when=\"blank-0\")} The [{.yellow} intersection point](target:center) lies on all\nthree bisectors. Therefore it must have the same distance from all three\n[[sides|vertices]] of the triangle.\n\n{.reveal(when=\"blank-1\")} This means we can draw a circle around it, that lies\ninside the triangle and just touches its three sides. This circle is called the\n__incircle__ of the triangle, and the center is called the __incenter__.\n:::"
    },
    {
      "id": "area",
      "content": "### Area and Altitudes\n\n::: column.grow\n{.r} Finding the area of a [rectangle](gloss:rectangle) is easy: you simply\nmultiply its width by its height. Finding the area of a triangle is a bit less\nobvious. Let’s start by “trapping” a triangle inside a rectangle.\n[Continue](btn:next)\n\n{.reveal.r(when=\"next-0\")} The width of the rectangle is the length of the\n[bottom side](target:base) of the triangle (which is called the __base__). The\nheight of the rectangle is the [perpendicular distance](target:height) from the\nbase to the opposite vertex.\n[Continue](btn:next)\n\n{.reveal(when=\"next-1\")} The height divides the triangle into two parts. Notice\nhow the [two gaps in the rectangle](target:gap) are exactly as big as the two\nparts of the triangle. This means that the rectangle is\n[[twice as|three times as|exactly as]] large as the triangle.\n\n{.reveal(when=\"blank-0\")} We can easily work out the area of the rectangle, so\nthe area of the triangle must be half that:\n\n{.text-center.reveal(when=\"blank-0\")} `A = 1/2 ×` [{.red} base](target:base)\n`×` [{.blue} height](target:height)\n::: column(width=300)\n\n    x-geopad.sticky(width=300): svg\n      circle.move(name=\"a\" cx=40 cy=220)\n      circle.move(name=\"b\" cx=260 cy=220)\n      circle.move(name=\"c\" cx=190 cy=80)\n      circle(hidden x=\"line(a,b).project(c)\" name=\"d\")\n      circle(hidden x=\"a.add(c).subtract(d)\" name=\"e\")\n      circle(hidden x=\"b.add(c).subtract(d)\" name=\"f\")\n\n      path.fill.green.reveal(x=\"polygon(a,d,c)\" when=\"next-1\" target=\"gap\")\n      path.fill.green.transparent(x=\"polygon(a,e,c)\" target=\"gap\")\n\n      path.fill.yellow.reveal(x=\"polygon(b,d,c)\" when=\"next-1\" target=\"gap\")\n      path.fill.yellow.transparent(x=\"polygon(b,f,c)\" target=\"gap\")\n\n      path.dark(x=\"polygon(a,b,c)\")\n      path.red.reveal(x=\"polygon(a,b,f,e)\" when=\"next-0\" animation=\"draw\")\n      path.blue.reveal(x=\"segment(c,d)\" label=\"height\" when=\"next-0\" delay=\"1000\" target=\"height\")\n      path.blue.reveal(x=\"angle(c,d,b).sup\" when=\"next-0\" delay=\"1000\" target=\"height\")\n      path.red.reveal(x=\"segment(a,b)\" label=\"base\" when=\"next-0\" delay=\"1000\" target=\"base\")\n\n:::"
    },
    {
      "id": "altitudes",
      "content": "To calculate the area of a triangle, you can pick any of the three sides as\n__base__, and then find the corresponding __height__, which is the line that is\n[[perpendicular|parallel]] to the base and goes through the opposite vertex.\n\n{.reveal(when=\"blank-0\")} In triangles, these _heights_ are often called\n[__altitudes__](gloss:triangle-altitude). Every triangle has [[three]] altitudes."
    },
    {
      "id": "altitudes-1",
      "content": "::: column(width=300)\n\n    x-geopad(width=300): svg\n      circle.move(name=\"a\" cx=75 cy=75 label=\"A\")\n      circle.move(name=\"b\" cx=50 cy=250 label=\"B\")\n      circle.move(name=\"c\" cx=250 cy=200 label=\"C\")\n\n      path(x=\"triangle(a,b,c)\")\n      path.altitude.red(hidden x=\"line(a,b).perpendicular(c)\")\n      path.altitude.blue(hidden x=\"line(a,c).perpendicular(b)\")\n      path.altitude.green(hidden x=\"line(b,c).perpendicular(a)\")\n      circle.yellow(hidden x=\"triangle(a,b,c).orthocenter\" target=\"center\")\n\n::: column.grow\nLike the [medians](gloss:triangle-median), [perpendicular\nbisectors](gloss:perpendicular-bisector) and [angle\nbisectors](gloss:angle-bisector), the three altitudes of a triangle\nintersect in a [single point](target:center). This is called the __orthocenter__\nof the triangle.\n\nIn [acute triangles](gloss:acute-triangle), the orthocenter\n[[lies inside|lies outside|is a vertex of]] the triangle.\n\n{.reveal(when=\"blank-0\")} In [obtuse triangles](gloss:obtuse-triangle), the\northocenter [[lies outside|lies inside|is a vertex of]] the triangle.\n\n{.reveal(when=\"blank-1\")} In [right-angled triangles](gloss:right-triangle), the\northocenter [[is a vertex of|lies inside|lies outside]] the triangle. Two of the\naltitudes are actually just sides of the triangle.\n:::"
    },
    {
      "section": "midsegments",
      "sectionStatus": "dev",
      "id": "midsegments",
      "goals": "s0 s1 s2",
      "content": "## Midsegments and Similarity\n\n\n::: column(width=300)\n\n    x-geopad.sticky(tools=\"move|line\" width=300 projections=\"no\"): svg\n      circle.move(name=\"a\" cx=75 cy=75)\n      circle.move(name=\"b\" cx=50 cy=250)\n      circle.move(name=\"c\" cx=250 cy=200)\n      circle.red(name=\"p\" x=\"line(a,b).midpoint\")\n      circle.red(name=\"q\" x=\"line(a,c).midpoint\")\n      circle.red(name=\"r\" x=\"line(b,c).midpoint\")\n      path(x=\"triangle(a,b,c)\")\n\n      path.transparent.fill.red(x=\"polygon(a,p,q)\" target=\"triangles\")\n      path.transparent.fill.blue(x=\"polygon(b,p,r)\" target=\"triangles\")\n      path.transparent.fill.yellow(x=\"polygon(c,q,r)\" target=\"triangles\")\n      path.transparent.fill.green(x=\"polygon(p,q,r)\" target=\"triangles\")\n      path.transparent.fill.red(x=\"polygon(a,b,c)\" target=\"large\")\n\n::: column.grow\nA [__midsegment__](gloss:triangle-midsegment) is a line segment that connects\nthe midpoints of two sides of a triangle. Draw the three midsegments of this\ntriangle.\n\n{.reveal(when=\"s0 s1 s2\")} As you can see, the midsegments split the triangle\ninto [four smaller triangles](target:triangles).\n\n{.reveal(when=\"s0 s1 s2\")} It turns out that all of these smaller triangles are\n[[congruent|overlapping|different sizes]] – even the upside down one in the\nmiddle. _{span.reveal(when=\"blank-0\")} They are also all [[similar|congruent]]\nto the [original triangle](target:large),_ _{span.reveal(when=\"blank-1\")}with a\nscale factor of `1/2`._\n\n{.reveal(when=\"blank-1\")} This allows us to deduce some important facts about\nthe midsegments of triangles:\n\n::: .theorem.reveal(when=\"blank-1\")\n__Midsegment Theorem__<br>\nA midsegment of a triangle is parallel to its opposite side, and exactly half\nthe length of that side.\n:::\n:::"
    },
    {
      "content": "{.todo} COMING SOON – More on triangle midsegments, and how they relate to\nsimilarity and proportionality."
    },
    {
      "id": "sss-construction",
      "section": "congruence",
      "goals": "draw-base draw-c1 draw-c2",
      "content": "## Triangle Congruence\n\n\nNow that we can check if three sides can form a triangle, let’s think about how\nwe would actually _construct_ a triangle with these sides.\n\n::: column(width=300)\n\n    x-geopad.sticky(width=300 tools=\"move|line|circle\"): svg\n\n::: column.grow\n{.task} Draw a triangle that has sides of lengths 4cm, 5cm and 6cm.\n\n{.r} In the box of the length, draw the longest side of the triangle, which is\n__6cm__. _{span.reveal(when=\"draw-base\")} Now we already have [two](target:base)\nof the three vertices of the triangle – the challenge is to find the last one.\n*{button.next-step} Continue*_\n\n{.reveal(when=\"next-0\")} Next, draw a circle of radius __4cm__ around one of the\nvertices, _{span.reveal(when=\"draw-c1\")} and a circle of radius __5cm__ around\nthe other one._\n\n{.reveal(when=\"draw-c2\")} The third vertex of the triangle is the\n[[intersection|center|radius]] of the two circles. _{span.reveal(when=\"blank-0\")}\nNow we can simply connect them to form a triangle._\n\n{.reveal(when=\"blank-0\" delay=\"3000\")} The circles actually intersect\n[[twice|three times|infinitely many times]]: _{span.reveal(when=\"blank-1\")}once\n[at the top](target:top) and once [at the bottom](target:bottom). We can pick\neither of these intersections, and the resulting two triangles are\n[[congruent|equilateral|perpendicular]]._\n:::"
    },
    {
      "id": "congruence",
      "content": "### Congruence Conditions\n\nBut is it possible to construct _a different_ triangle with the same three\nsides?\n\nWe already saw two triangles above, but they were both congruent. In fact, any\ntwo triangles that have the same three side lengths are congruent. This is\ncalled the [__SSS Congruence Condition__](gloss:triangle-sss) for triangles\n(“Side-Side-Side”).\n\nWe now have two conditions for triangles: “AA” means that two triangles are\n[[similar|congruent|transformations]], and “SSS” means that two triangles are\n[[congruent|similar|equal]]. There are a few more congruence conditions:"
    },
    {
      "id": "congruence-1",
      "content": "::: .theorem\nTwo triangles are congruent if any one of the following conditions is met:\n\n    .row.padded-thin\n      div(style=\"width: 150px\")\n        .text-center: strong SSS\n        x-geopad(width=150 height=120): svg\n          circle(name=\"a\" x=\"point(60,10)\")\n          circle(name=\"b\" x=\"point(10,110)\")\n          circle(name=\"c\" x=\"point(140,80)\")\n          path.red(x=\"segment(a,b)\")\n          path.red(x=\"segment(a,c)\")\n          path.red(x=\"segment(b,c)\")\n        p.caption All sides are congruent.\n\n      div(style=\"width: 150px\")\n        .text-center: strong SAS\n        x-geopad(width=150 height=120): svg\n          circle(name=\"a\" x=\"point(60,10)\")\n          circle(name=\"b\" x=\"point(10,110)\")\n          circle(name=\"c\" x=\"point(140,80)\")\n          path.red(x=\"angle(a,b,c)\")\n          path.red(x=\"segment(a,b)\")\n          path(x=\"segment(a,c)\")\n          path.red(x=\"segment(b,c)\")\n        p.caption Two sides and the #[strong included] angle are congruent.\n\n      div(style=\"width: 150px\")\n        .text-center: strong ASA\n        x-geopad(width=150 height=120): svg\n          circle(name=\"a\" x=\"point(60,10)\")\n          circle(name=\"b\" x=\"point(10,110)\")\n          circle(name=\"c\" x=\"point(140,80)\")\n          path.red(x=\"angle(c,a,b)\")\n          path.red(x=\"angle(a,b,c)\")\n          path.red(x=\"segment(a,b)\")\n          path(x=\"segment(a,c)\")\n          path(x=\"segment(b,c)\")\n        p.caption Two angles and the #[strong included] side are congruent.\n\n      div(style=\"width: 150px\")\n        .text-center: strong AAS\n        x-geopad(width=150 height=120): svg\n          circle(name=\"a\" x=\"point(60,10)\")\n          circle(name=\"b\" x=\"point(10,110)\")\n          circle(name=\"c\" x=\"point(140,80)\")\n          path.red(x=\"angle(b,c,a)\")\n          path.red(x=\"angle(a,b,c)\")\n          path.red(x=\"segment(a,b)\")\n          path(x=\"segment(a,c)\")\n          path(x=\"segment(b,c)\")\n        p.caption Two angles and one of the non-included sides.\n:::"
    },
    {
      "id": "cpoct",
      "content": "You can think of these conditions as “shortcuts”: to check if two triangles are\ncongruent, you just need to check one of the conditions above.\n\nOnce you _know_ that two triangles are congruent, you know that _all_ of their\ncorresponding sides and angles are congruent. This is often called\n[__CPOCT__](gloss:cpoct), or “Corresponding Parts of Congruent Triangles are\nCongruent”.\n\nIt is interesting to note that all conditions consists of [[three]] different\nvalues (either sides or angles)!"
    },
    {
      "id": "contruction",
      "content": "### Constructing Triangles\n\nAt the beginning of this section, we saw how to construct a triangle if we know\nits three sides. Similarly, there are ways to construct triangles for each of\nthe congruence conditions above.\n\n::: tab\n#### SAS\n\n::: column(width=300)\n{.todo} COMING SOON – Animation\n::: column.grow\n{.task} Draw the triangle that has sides of 5cm and 3cm, and an included\nangle of 40°.\n\nLike before, we start by drawing one of the sides of the triangle.\n\nNext, use a protractor to measure a 40° angle around one of the two vertices.\nLet’s mark this angle with a point.\n\nWe can connect the vertex to our measurement, to form the second side of the\ntriangle.\n\nWe know that this side has to be 3cm long, so let’s measure that distance with a\nruler and then mark the third vertex of the triangle.\n\nFinally, we can connect the last two vertices, to complete the triangle.\n:::\n\nOf course, we could have drawn the 3cm side first, or picked the other vertex\nto draw the 40° angle around. However, in all those cases, the resulting\ntriangles would have been congruent to this one.\n\n::: tab\n#### ASA\n\n::: column(width=300)\n{.todo} COMING SOON – Animation\n::: column.grow\n{.task} Draw the triangle that has angles of 70° and 50°, and an included\nside of length 5cm.\n\nLet’s start by drawing the first side, using a ruler to measure 5cm.\n\nNow let’s use a protractor to measure an angle of 70° around one of the\nendpoints of the side, and an angle of 50° around the other endpoint. (Which\nway round does not matter – the resulting triangles will be congruent.)\n\nConnecting the angle marks to the endpoints completes the triangle.\n:::\n\n::: tab\n#### AAS\n\n::: column(width=300)\n{.todo} COMING SOON – Animation\n::: column.grow\n{.task} Draw the triangle that has angles of 40° and 50°, and an included\nside of length 5cm.\n\nAgain, we’ll start by constructing the first side of the triangle, which is 5cm\nlong.\n\nAnd again, we’ll use a protractor to measure an angle of 40° around one of the\nendpoints, and draw the second side of the triangle. However, we don’t yet know\nwhere this side will end.\n\nInstead, let’s pick any point around this line, pretend it is the third vertex of\nthe triangle and measure an angle of 50°.\n\nAs you can see, this doesn’t quite work: the third side does not yet link up\nwith the vertex A. To fix this, we simply have to shift it: we draw a parallel\nline that goes through A. (You already learned how to construct parallel lines\nin a [previous course](/course/euclidean-geometry/geometric-construction).)\n\nNow the two angles at the top are alternate angles, so they must be congruent\nand both 50°. We can erase the incorrect, first line to get our completed AAS\ntriangle.\n:::\n\n::: tab\n#### SSA\nThe SSA construction is slightly different. You might have noticed that “SSA”\nwas not in the list of congruence conditions above, so comparing SSA is two\ntriangles is not enough to confirm they are congruent. This will show you why:\n\n::: column(width=300)\n{.todo} COMING SOON – Animation\n::: column.grow\n{.task} Draw the triangle that has sides of 4cm and 5cm, and a non-included\nangle of 50°.\n\nLike always, let’s start by drawing the first side of the triangle which is 5cm\nlong.\n\nNext, let’s measure an angle of 50° around one of the endpoints and draw the\nsecond side of the triangle. However, we don’t yet know where this side will\nend.\n\nThe third side has o be 4cm long. Using a protractor we can draw a circle of\nradius 4cm around the other endpoint of the original side.\n\nThe final vertex of the triangle is formed by the intersection of the circle and\nthe second line. However, in this case, there are two intersections!\n\nThese two triangles are clearly not congruent. This means that there are two\ndifferent triangles that have sides of 4cm and 5cm, as well as a non-included\nangle of 50°. SSA is not enough to confirm two triangles are congruent.\n:::\n:::"
    },
    {
      "id": "pythagoras",
      "section": "pythagoras",
      "content": "## Pythagoras’ Theorem\n\n\nWe have now reached an important point in geometry – being able to state and\nunderstand one of the most famous [theorems](gloss:theorem) in all of\nmathematics: __Pythagoras’ Theorem__. It is named after the ancient Greek\nmathematician [Pythagoras of Samos](bio:pythagoras).\n\n::: .theorem\n::: column.grow\n__Pythagoras’ Theorem__<br>\nIn any right-angled triangle, the square of the length of the\n[__hypotenuse__](target:hypot) (the side that lies opposite the right angle) is\nequal to the sum of the squares of the other two sides. In other words,\n\n{.text-center} _{span.circled.green}`a^2`_ + _{span.circled.blue}`b^2`_ =\n_{span.circled.yellow}`c^2`_\n\n_The converse is also true: if the three sides in a triangle satisfy\n`a^2 + b^2 = c^2`, then it must be [[right-angled|acute|obtuse]]._\n::: column(width=300)\n\n    x-geopad(width=300): svg\n      circle.move(name=\"a\" cx=82 cy=160 target=\"hypot\")\n      circle.move(name=\"b\" cx=218 cy=160 target=\"hypot\")\n      circle.move(name=\"c\" cx=120 cy=100 project=\"arc(line(a,b).midpoint,a,pi).contract(0.2)\")\n\n      path.fill.green(x=\"polygon(b,c,b.rotate(-pi/2,c),c.rotate(pi/2,b))\" label=\"a²\" label-class=\"white\")\n      path.fill.blue(x=\"polygon(c,a,c.rotate(-pi/2,a),a.rotate(pi/2,c))\" label=\"b²\" label-class=\"white\")\n      path.fill.yellow(x=\"polygon(b,a,b.rotate(pi/2,a),a.rotate(-pi/2,b))\" label=\"c²\" label-class=\"white\")\n\n      path.dark(x=\"segment(b,c)\" label=\"a\")\n      path.dark(x=\"segment(a,c)\" label=\"b\")\n      path.dark(x=\"segment(a,b)\" label=\"c\" target=\"hypot\")\n      path.dark.thin(x=\"angle(b,c,a)\")\n\n:::\n:::"
    },
    {
      "id": "pythagoras-1",
      "content": "::: column(width=220)\n\n    img(src=\"images/ladder.svg\" width=220 height=300)\n\n::: column.grow\nRight angles are everywhere, and that’s why Pythagoras’ Theorem is so useful.\n\nHere you can see a __{.m-red}6m__ long ladder leaning on a wall. The bottom of\nthe ladder is __{.m-blue}1m__ away from the wall. How far does it reach up the\nwall?\n\nNotice that there is a right-angled triangle formed by the ladder, the wall and\nthe ground. Using Pythagoras’ theorem, we get\n\n    table.eqn-system\n      tr\n        td.md `class(h^2,\"b m-green\") + class(1^2,\"b m-blue\")`\n        td.md `= class(6^2,\"b m-red\")`\n      tr\n        td.md `⇒ class(h^2,\"b m-green\")`\n        td.md `= input(35)`\n      tr.reveal(when=\"blank-0\")\n        td.md `⇒ class(h, \"b m-green\")`\n        td.md `= sqrt(35) = \"5.92m\"`\n\n:::\n\n{.reveal(when=\"blank-0\")} Whenever you’ve got a right-angled triangle and know\ntwo of its sides, Pythagoras can help you find the third one."
    },
    {
      "id": "pythagoras-proof",
      "content": "### Proving Pythagoras’ Theorem\n\nPythagoras’ theorem was known to ancient Babylonians, Mesopotamians,\nIndians and Chinese – but Pythagoras may have been the first to find a formal,\nmathematical proof.\n\nThere are actually many different ways to prove Pythagoras’ theorem. Here you\ncan see three different examples that each use a different strategy:\n\n::: tab.proof-1\n\n#### Rearrangement _{span.check(when=\"blank-0 blank-1\")}_\n\n::: column.grow\n\nHave a look at the figure on the right. The square has side length `a + b`, and contains\n[{.blue} four right-angled triangles](target:triangle), as well as a\n[{.red} smaller square](target:square) of area [[`c^2`|`a - b`|`a + b`]].\n\n{.reveal(when=\"blank-0\")} Now let’s rearrange the triangles in the square. The\nresult still contains the four right-angles triangles, as well as two squares\nof size [[`a^2` and `b^2`|`c^2`|`(a + b)^2`]].\n\n{.reveal(when=\"blank-1\")} Comparing the area of the red area [before](action:set(0)) and\n[after](action:set(100)) the rearrangement, we see that\n\n{.text-center.reveal(when=\"blank-1\")} `a^2 + b^2 = c^2`.\n\n{.reveal(when=\"blank-1\")} This is the original proof that\n[Pythagoras](bio:pythagoras) came up with. _{span.qed}_\n\n::: column(width=240)\n\n    x-geopad(width=240)\n      svg\n        circle(hidden name=\"a\" x=\"point(20,20)\")\n        circle(hidden name=\"b\" x=\"point(220,20)\")\n        circle(hidden name=\"c\" x=\"point(220,220)\")\n        circle(hidden name=\"d\" x=\"point(20,220)\")\n\n        circle.move(name=\"e\" cx=100 cy=20 project=\"segment(line(a,b).at(.1),line(a,b).at(.9))\")\n        circle(name=\"f\" hidden x=\"b.add(e.subtract(a).flip)\")\n        circle(name=\"g\" hidden x=\"c.subtract(e.subtract(a))\")\n        circle(name=\"h\" hidden x=\"d.subtract(e.subtract(a).flip)\")\n\n        path.thin(x=\"segment(a,e)\" label=\"a\")\n        path.thin(x=\"segment(e,b)\" label=\"b\")\n        path.thin(x=\"segment(a,h)\" label=\"b\")\n        path.thin(x=\"segment(h,d)\" label=\"a\")\n        path.thin(x=\"segment(e,h)\" label=\"c\")\n        path.thin(x=\"segment(e,f).shift(0,x*distance(h,a))\" label=\"c\")\n\n        path.square(x=\"polygon(a,b,c,d)\")\n        path.tri(x=\"polygon(a,e,h)\" target=\"triangle\")\n        path.tri(x=\"polygon(c,g,f).shift(-x*distance(d,g),-x*distance(b,f))\" target=\"triangle\")\n        path.tri(x=\"polygon(d,h,g).shift(x*distance(e,a),0)\" target=\"triangle\")\n        path.tri(x=\"polygon(b,f,e).shift(0,x*distance(h,a))\" target=\"triangle\")\n        path.square.transparent(x=\"polygon(e,f,g,h)\" target=\"square\")\n\n      .label(style=\"left: 120px; top: 120px;\") c²\n      .label.var(style=\"left: ${10 + e.x/2}px; top: ${230 - e.x/2}px;\") a²\n      .label.var(style=\"left: ${110 + e.x/2}px; top: ${130 - e.x/2}px;\") b²\n\n    x-slider(steps=100)\n\n:::\n::: tab.proof-2\n\n#### Algebra _{span.check(when=\"blank-2 blank-3 blank-4\")}_\n\n::: column.grow\n\nHere we have the same figure as before, but this time we’ll use _algebra_ rather\nthan _rearrangement_ to prove Pythagoras’ theorem.\n\nThe large square has side length `a + b` and area [[`(a + b)^2`|`a^2 + b^2`|`c^2`]].\n\n{.reveal(when=\"blank-2\")} It consists of [{.blue}four triangles](target:triangle), each with an\narea of [[`1/2 a b`|`(a + b)^2`|`1/2 (a + b)`]], and [{.red}one square](target:square) of area\n[[`c^2`|`(a + b)^2`|`a × b`]].\n\n{.reveal(when=\"blank-3 blank-4\")} If we combine all of that information, we have\n\n|          `(a+b)^2` | `= 4 × 1/2 a b + c^2` |\n| `a^2 + 2a b + b^2` | `= 2a b + c^2`        |\n|        `a^2 + b^2` | `= c^2`               |\n{.eqn-system.reveal(when=\"blank-3 blank-4\")}\n\n{.reveal(when=\"blank-3 blank-4\")} And, once again, we get Pythagoras’ theorem.\n_{span.qed}_\n\n::: column(width=240)\n\n    x-geopad(width=240): svg\n      circle.move(name=\"e1\" cx=100 cy=20 project=\"segment(line(a,b).at(.1),line(a,b).at(.9))\")\n      circle(name=\"f1\" hidden x=\"b.add(e1.subtract(a).flip)\")\n      circle(name=\"g1\" hidden x=\"c.subtract(e1.subtract(a))\")\n      circle(name=\"h1\" hidden x=\"d.subtract(e1.subtract(a).flip)\")\n\n      path.thin(x=\"segment(a,e1)\" label=\"a\")\n      path.thin(x=\"segment(e1,b)\" label=\"b\")\n      path.thin(x=\"segment(a,h1)\" label=\"b\")\n      path.thin(x=\"segment(h1,d)\" label=\"a\")\n      path.thin(x=\"segment(e1,h1)\" label=\"c\")\n      path.thin(x=\"segment(e1,f1).shift(0,x*distance(h,a))\" label=\"c\")\n\n      path.square(x=\"polygon(e1,f1,g1,h1)\" target=\"square\")\n      path.tri(x=\"polygon(a,e1,h1)\" target=\"triangle\")\n      path.tri(x=\"polygon(c,g1,f1)\" target=\"triangle\")\n      path.tri(x=\"polygon(d,h1,g1)\" target=\"triangle\")\n      path.tri(x=\"polygon(b,f1,e1)\" target=\"triangle\")\n\n:::\n::: tab.proof-3\n\n#### Similar Triangles _{span.check(when=\"next-0 next-1 next-2 blank-5\")}_\n\n::: column.grow\n\n{.r} Here you can see another right-angled triangle. If we draw one of the\naltitudes, it splits the triangle into two smaller triangle.\nIt also divides the hypotenuse _c_ into [two smaller parts](target:hypotenuse)\nwhich we’ll call [{.i.blue}x](target:x) and [{.i.green}y](target:y).\n_{span.next-step} Continue_\n\n{.r.reveal(when=\"next-0\")} Let’s separate out the two smaller triangles, so that\nit’s clearer to see how they are related…\n_{span.next-step} Continue_\n\n{.reveal(when=\"next-1\")} Both smaller triangles [share one angle](target:angle)\nwith the original triangle. They also all have [one right angle](target:right).\nBy the AA condition, all three triangles must be [[similar|congruent|right-angled]].\n\n::: column(width=260)\n\n    x-geopad.similar-triangle(width=260): svg\n      circle(name=\"B1\" hidden cx=40 cy=100)\n      circle(name=\"X1\" hidden cx=170 cy=100)\n      circle(name=\"C1\" hidden cx=170 cy=20)\n      path.fill.light.red(x=\"polygon(B1,X1,C1)\")\n      path.fill.yellow(x=\"angle(C1,B1,X1).sup\" size=25 target=\"angle\")\n      path.dark.thin(x=\"angle(B1,X1,C1).sup\" size=10 target=\"right\")\n      path.red(x=\"segment(B1,C1)\" label=\"a\" target=\"a ac\")\n      path.dark(x=\"segment(X1,C1)\")\n      path.blue(x=\"segment(X1,B1)\" label=\"x\" target=\"x xa\")\n\n      circle(name=\"A2\" hidden cx=220 cy=100)\n      circle(name=\"X2\" hidden cx=170 cy=100)\n      circle(name=\"C2\" hidden cx=170 cy=20)\n      path.fill.light.yellow(x=\"polygon(A2,X2,C2)\")\n      path.fill.red(x=\"angle(C2,A2,X2).sup\" size=20 target=\"angle\")\n      path.dark.thin(x=\"angle(A2,X2,C2).sup\" size=10 target=\"right\")\n      path.yellow(x=\"segment(A2,C2)\" label=\"b\" target=\"b bc\")\n      path.dark(x=\"segment(X2,C2)\")\n      path.green(x=\"segment(X2,A2)\" label=\"y\" target=\"y yb\")\n\n      circle(name=\"A\" hidden x=\"point(220,100)\")\n      circle(name=\"B\" hidden x=\"point(40,100)\")\n      circle(name=\"C\" hidden x=\"point(170,20)\")\n      circle(name=\"X\" hidden x=\"point(170,100)\")\n      path.dark(x=\"segment(X,C)\" target=\"altitude\")\n      path.dark.thin(x=\"angle(B,X,C)\" size=10 target=\"altitude\")\n      path.fill.yellow(x=\"angle(C,B,X)\" size=25 target=\"angle\")\n      path.fill.red(x=\"angle(X,A,C)\" size=20 target=\"angle\")\n      path.dark.thin(x=\"angle(A,C,B)\" size=10 target=\"right\")\n      path.red(x=\"segment(B,C)\" label=\"a\" target=\"a xa\")\n      path.yellow(x=\"segment(A,C)\" label=\"b\" target=\"b yb\")\n      path.blue(x=\"segment(B,X)\" label=\"x\" target=\"hypotenuse x ac bc\")\n      path.green(x=\"segment(X,A)\" label=\"y\" target=\"hypotenuse y ac bc\")\n\n:::\n\n{.reveal(when=\"blank-5\")} Now we can use the equations we already know about\nsimilar polygons:\n\n    table.proof-table.reveal(when=\"blank-5\"): tr\n      td.md `pill(x/a, \"blue\", \"xa\") = pill(a/c, \"red\", \"ac\")`<br>`pill(x, \"blue\", \"x\") = (a^2)/c`\n      td.md `pill(y/b, \"green\", \"yb\") = pill(b/c, \"yellow\", \"bc\")`<br>`pill(y, \"green\", \"y\") = (b^2)/c`\n\n{.r.reveal(when=\"blank-5\")} [Continue](btn:next)\n\n{.reveal(when=\"next-2\")} But remember that `c = pill(x,\"blue\",\"x\") + pill(y,\"green\",\"y\")`.\nTherefore\n\n{.text-center.reveal(when=\"next-2\")} `c = a^2/c + b^2/c`\n\n{.text-center.reveal(when=\"next-2\")} `c^2 = a^2 + b^2`\n\n{.reveal(when=\"next-2\")} Once more, we’ve proven Pythagoras’ theorem! _{span.qed}_\n\n:::"
    },
    {
      "id": "pythagoras-2",
      "content": "Much about Pythagoras’ life is unknown, and no original copies of his work have\nsurvived. He founded a religious cult, the _Pythagoreans_, that practiced a kind\nof  “number worship”. They believed that all numbers have their own character,\nand followed a variety of other bizarre customs.\n\n::: column.grow\n\nThe Pythagoreans are credited with many mathematical discoveries, including\nfinding the first [irrational number](gloss:irrational-numbers), `sqrt(2)`.\nIrrational numbers cannot be expressed as a simple fraction – a concept the\nPythagoreans found deeply troubling and (unsuccessfully) tried to cover up!\n\n::: column(width=400)\n\n    x-img(src=\"images/pythagoreans.jpg\" width=400 height=200 lightbox)\n\n{.caption} “Pythagoreans celebrate sunrise” by Fyodor Bronnikov\n\n:::"
    },
    {
      "id": "distance-formula",
      "content": "### Calculating Distances\n\nOne of the most important application of Pythagoras’ Theorem is for calculating\ndistances.\n\n::: column.grow\n{.r} On the right you can see two points in a coordinate system. We could\nmeasure their distance using a ruler, but that is not particularly accurate.\nInstead, let’s try using Pythagoras.\n[Continue](btn:next)\n\n{.reveal(when=\"next-0\")} We can easily count the [{.blue}horizontal distance](target:dx) along the\n_x_-axis, and the [{.red}vertical distance](target:dy) along the _y_-axis. If we draw those two\nlines, we get a [{.yellow}right-angled triangle](target:triangle).\n\n{.reveal(when=\"next-0\")} Using Pythagoras,\n\n| `d^2` | `= pill(var(\"b.x-a.x\"),\"blue\",\"dx\")^2 + pill(var(\"b.y-a.y\"),\"red\",\"dy\")^2`   |\n| `d^2` | `= var(\"(b.x-a.x)**2 + (b.y-a.y)**2\")`                                       |\n| `d`   | `= sqrt(var(\"(b.x-a.x)**2 + (b.y-a.y)**2\")) = var(\"round(distance(a,b),4)\")` |\n{.eqn-system.reveal(when=\"next-0\")}\n\n::: column(width=300)\n\n    x-geopad(width=300 height=300 x-axis=\"-0.5,11.5,1\" y-axis=\"-0.5,11.5,1\" grid snap): svg\n      circle.move.pulsate(name=\"a\" cx=\"2\" cy=\"5\" label=\"(${a.x},${a.y})\")\n      circle.move.pulsate(name=\"b\" cx=\"9\" cy=\"10\" label=\"(${b.x},${b.y})\")\n      path(x=\"segment(a,b)\" label=\"d\")\n      path.blue.reveal(x=\"segment(a,point(b.x,a.y))\" label=\"${b.x-a.x}\" mark=\"arrow\" when=\"next-0\" target=\"dx\")\n      path.red.reveal(x=\"segment(point(b.x,a.y),b)\" label=\"${b.y-a.y}\" mark=\"arrow\" when=\"next-0\" target=\"dy\")\n      path.yellow.fill.transparent#tri-move(target=\"triangle\" x=\"polygon(a,b,point(b.x,a.y))\")\n\n:::"
    },
    {
      "id": "distance-formula-1",
      "content": "This method works for _any_ two points:\n\n::: .theorem\n__The Distance Formula__<br>\nIf you are given two points with coordinates  (`x_1`,`y_1`) and (`x_2`,`y_2`),\nthe distance between them is\n\n{.text-center} `d^2=(x_2−x_1)^2+(y_2−y_1)^2`\n\n{.text-center} `d=sqrt((x_2−x_1)^2+(y_2−y_1)^2)`\n:::"
    },
    {
      "id": "pythagorean-triples",
      "content": "### Pythagorean Triples\n\nAs you moved the [vertices of the triangle](->#tri-move) in the previous step,\nyou might have noticed that in most cases, the length of the hypothenuse _d_\nended up being a [[decimal number|fraction|integer]].\n_{span.reveal(when=\"blank-0\")}However there are a few examples of right-angled\ntriangles where the lengths of *all three sides* happens to be *whole numbers*._"
    },
    {
      "id": "pythagorean-triples-1",
      "content": "::: column.grow\nOne famous example is the 3-4-5 triangle. Since `3^2 + 4^2 = 5^2`, any triangle\nwith sides of length 3, 4 and 5 must be right-angled.\n\nThe ancient Egyptians didn’t know about Pythagoras’ theorem, but they did know\nabout the 3-4-5 triangle. When building the pyramids, they used knotted ropes\nof lengths 3, 4 and 5 to measure perfect right angles.\n::: column(width=400)\n\n    img(src=\"images/egypt.png\" width=400 height=220)\n\n:::\n\nThree integers like this are called [__Pythagorean Triples__](gloss:pythagorean-triple).\n(3, 4, 5) is one example of a Pythagorean triple. If we multiply every number\nby 2, we get another Pythagorean triple: (6, 8, [[10]])."
    },
    {
      "id": "isosceles",
      "goals": "p0 p1 p2 p3 p4 p5",
      "section": "isosceles-and-equilateral",
      "sectionStatus": "dev",
      "content": "We can think of these triples as grid points in a coordinate systems. For a\nvalid Pythagorean triples, the distance from the origin to the grid point has to\nbe a whole number. Using the coordinate system below, can you find any other\nPythagorean triples?\n\n    figure: x-geopad.r.no-background(width=450 height=450 x-axis=\"0,16.5,1\" y-axis=\"0,16.5,1\" grid axes padding=\"10 10 25 25\" snap)\n      svg\n        circle.move.pulsate(cx=4 cy=10 name=\"a\")\n        path.thick(x=\"polygon(point(0,0),a,point(a.x,0))\")\n      .label.var(style=\"left:${26+12.5*a.x}px; top:425px\") ${a.x}\n      .label.var(style=\"left:${26+25*a.x}px; top:${425-12.5*a.y}px\") ${a.y}\n      .label.var(style=\"left:${26+12.5*a.x}px; top:${425-12.5*a.y}px\") ${round(a.length,2)}\n\n{.reveal(when=\"p0 p1 p2 p3 p4 p5\")} Do you notice any pattern in the\ndistribution of these points?\n\n    // The mathematician Euclid found a clever method for generating new\n    // Pythagorean triples. First, we need to pick any two integers _m_ and _n_:\n    // {.text-center} _m_ = ${m}{m|2|1,20,1} _{span.space}_ _n_ = ${n}{n|2|1,20,1}\n    // Now we can calculate the three numbers that make up the triple:\n    // {.text-center} `2mn =` ${2×m×n}, `m^2 - n^2 =` ${m×m-n×n},  `m^2 + n^2 =` ${m×m+n×n}\n    // And there you have your pythagorean triple! You can check that a2 + b2 = c2.\n\n----\n\n## Isosceles and Equilateral Triangles\n\n\nOther then right-angled triangles, there are a few other triangles with\nspecial properties. In this section we’ll have a look at some of them.\n\n### Isosceles Triangles\n\nWe say that a triangle is [__isosceles__](gloss:isosceles-triangle) if it has\ntwo congruent sides. These congruent sides are called the __legs__ of the\ntriangle, while the third side is called the __base__.\n\n{.todo} COMING SOON – Base angles theorem\nProof by constructing angle bisector and using SAS result.\n\n{.todo} COMING SOON – Find the height of an Isosceles Triangles using Pythagoras\n\n    // {.todo} The angles between the base and the congruent sides are\n    // called base angles. The angle made by the two legs of the isosceles triangle is\n    // called the vertex angle.\n    //\n    // {.todo} Base Angles Theorem: The base angles of an isosceles triangle are congruent.\n    // To prove the Base Angles Theorem, we will construct the angle bisector through\n    // the vertex angle of an isosceles triangle.\n    //\n    // {.todo} Isosceles Triangle Theorem: The angle bisector of the vertex angle in an\n    // isosceles triangle is also the perpendicular bisector to the base.\n    //\n    // {.todo} The converses of the Base Angles Theorem and the Isosceles Triangle Theorem are\n    // both true. If two angles in a triangle are congruent, then\n    // the opposite sides are also congruent. And if the perpendicular bisector of the base of\n    // an isosceles triangle is also the angle bisector of the vertex angle.\n    //\n    // {.todo} In other words, if △ABC is isosceles, AD⊥CB and CD≅DB, then ∠CAD≅∠BAD.\n    //\n    // {.todo} Find the Height of an Isosceles Triangle\n    // One way to use The Pythagorean Theorem is to identify the heights in isosceles\n    // triangles so you can calculate the area."
    },
    {
      "id": "trigonometry",
      "section": "trigonometry",
      "content": "### Equilateral Triangles\n\nWe say that a triangle is [__equilateral__](todo:equilateral-triangle) if all of\nits sides  have the same length. You’ve [already\nseen](/course/euclidean-geometry/geometric-construction) how to construct an\nequilateral triangle using straight-edge and compass.\n\n    // Any equilateral triangle is always also isosceles. From the base angle theorem\n    // we know that angles opposite congruent sides in a triangle are also congruent.\n    // In an equilateral triangle, all of the sides are congruent, so all of the angles\n    // must also be congruent.\n    //\n    // Since we know that the sum of all three angles is 180°, every individual angle\n    // in an equilateral triangle must be [[60]]°.\n\n{.todo} COMING SOON – Size of angles in an equilateral triangle\n\n{.todo} COMING SOON – Area of an equilateral triangle\n\n----\n\n## Trigonometry\n\n\nSo far we have seen relationships between the __angles__ of triangles (e.g.\nthey always sum up to 180°) and relationships between the __sides__ of triangles\n(e.g. Pythagoras). But there is nothing that _connects_ the size of angles and\nsides.\n\nFor example, if I know the three sides of a triangle, how do I find the size of\nits angles – without drawing the triangle and measuring them using a protractor?\nThis is where __Trigonometry__ comes in!\n\n    figure: img(src=\"images/trig-om-nom.jpg\" width=200 height=200)"
    },
    {
      "id": "trigonometry-1",
      "content": "::: column.grow\nImagine we have a right-angled triangle, and we also know one of the two other\nangles, __{.m-red}α__. We already know that the longest side is called the\n__[{.yellow}hypotenuse](target:hyp)__. The other two are usually called the\n__[{.green}adjacent](target:adj)__ (which is next to angle __{.m-red}α__) and\nthe __[{.blue}opposite](target:opp)__ (which is opposite angle __{.m-red}α__).\n::: column(width=240)\n\n    x-geopad(width=240 height=160): svg\n      circle(name=\"a\" x=\"point(30,120)\")\n      circle(name=\"b\" x=\"point(210,40)\")\n      circle(name=\"c\" x=\"point(210,120)\")\n      path(x=\"angle(a,c,b)\")\n      path.red(x=\"angle(b,a,c)\" label=\"α\")\n      path.yellow(x=\"segment(a,b)\" label=\"Hypotenuse\" target=\"hyp\")\n      path.blue(x=\"segment(b,c)\" label=\"Opposite\" target=\"opp\")\n      path.green(x=\"segment(a,c)\" label=\"Adjacent\" target=\"adj\")\n\n:::\n\nThere are many different triangles that have angles __{.m-red}α__ and 90°, but\nfrom the [AA condition](gloss:triangle-aa) we know that they are all\n[[similar|congruent]]:\n\n    figure: img(src=\"images/triangles.svg\" width=600 height=240)"
    },
    {
      "id": "trig-functions",
      "content": "Since all of these triangles are similar, we know that their sides are\nproportional. In particular, the following ratios are the same for all of these\ntriangles:\n\n{.text-center} `class(\"Opposite\",\"m-blue b\") / class(\"Hypotenuse\",\"m-yellow b\")`\n_{span.space}_\n`class(\"Adjacent\",\"m-green b\") / class(\"Hypotenuse\",\"m-yellow b\")`\n_{span.space}_\n`class(\"Opposite\",\"m-blue b\") / class(\"Adjacent\",\"m-green b\")`\n\nLet’s try to summarise this: we picked a certain value for __{.m-red}α__, and\ngot lots of similar, right-angled triangles. All of these triangles have the\nsame ratios of sides. Since __{.m-red}α__ was our only variable, there must be\nsome relationship between __{.m-red}α__ and those ratios.\n\nThese relationships are the __Trigonometric functions__ – and there are three of\nthem:\n\n::: .theorem\nThe three Trigonometric functions are relationships between the angles and the\nratios of sides in a right-angles triangle. They each have a name, as well as\na 3-letter abbreviation:\n\n::: column.grow\n\n    ul\n      li.display.md __Sine:__ `sin(class(α,\"m-red b\")) = class(\"Opposite\",\"m-blue b\") / class(\"Hypotenuse\",\"m-yellow b\")`\n      li.display.md __Cosine:__ `cos(class(α,\"m-red b\")) = class(\"Adjacent\",\"m-green b\") / class(\"Hypotenuse\",\"m-yellow b\")`\n      li.display.md __Tangent:__ `tan(class(α,\"m-red b\")) = class(\"Opposite\",\"m-blue b\") / class(\"Adjacent\",\"m-green b\")`\n\n::: column(width=240)\n\n    x-geopad(width=240 height=160): svg\n      circle(name=\"a\" x=\"point(30,120)\")\n      circle(name=\"b\" x=\"point(210,40)\")\n      circle(name=\"c\" x=\"point(210,120)\")\n      path(x=\"angle(a,c,b)\")\n      path.red(x=\"angle(b,a,c)\" label=\"α\")\n      path.yellow(x=\"segment(a,b)\" label=\"Hypotenuse\")\n      path.blue(x=\"segment(b,c)\" label=\"Opposite\")\n      path.green(x=\"segment(a,c)\" label=\"Adjacent\")\n\n:::\n:::"
    },
    {
      "id": "trig-functions-1",
      "content": "{.todo} COMING SOON – More on Trigonometry\n\n    // {.todo} COMING SOON – Abbreviations: sin x, cos y\n    // {.todo} COMING SOON – Using calculators\n    // {.todo} COMING SOON – Examples\n    // {.todo} COMING SOON – Rationalize the denominator"
    },
    {
      "id": "inverse-trig",
      "content": "### Inverse Trignometric Functions\n\n{.todo} COMING SOON – Inverse functions\n\n    // The word inverse is probably familiar to you. In mathematics, once you learn how\n    // to do an operation, you also learn how to “undo” it. For example, you may\n    // remember that addition and subtraction are considered inverse operations.\n    // Multiplication and division are also inverse operations. In algebra you used\n    // inverse operations to solve equations and inequalities. When we apply the word\n    // inverse to the trigonometric ratios, we can find the acute angle measures within\n    // a right triangle. Normally, if you are given an angle and a side of a right\n    // triangle, you can find the other two sides, using sine, cosine or tangent. With\n    // the inverse trig ratios, you can find the angle measure, given two sides.\n\n    // On most scientific and graphing calculators, the buttons look like\n    // [SIN−1],[COS−1], and [TAN−1]. Typically, you might have to hit a shift\n    // button to access these functions."
    },
    {
      "section": "sine-cosine-rule",
      "id": "sine-cosine-rule",
      "content": "## Sine and Cosine Rules\n\n\nSo far, all you’ve learned about Trigonometry only works in right-angled\ntriangles. But most triangles are not right-angled, and there are two important\nresults that work for all triangles\n\n::: column.grow\n::: .theorem\n__Sine Rule__<br>\nIn a triangle with sides _a_, _b_ and _c_, and angles _A_, _B_ and _C_,\n\n{.text-center} `(sin(A))/a = (sin(B))/b = (sin(C))/c`\n:::\n\n    // {.todo} Use Law of Sines when given:\n    // An angle and its opposite side.\n    // Any two angles and one side.\n\n::: column.grow\n::: .theorem\n__Cosine Rule__<br>\nIn a triangle with sides _a_, _b_ and _c_, and angles _A_, _B_ and _C_,\n\n{.text-center} `c^2 = a^2 + b^2 - 2a b cos(C)`\n`b^2 = c^2 + a^2 - 2c a cos(B)`\n`a^2 = b^2 + c^2 - 2b c cos(A)`\n:::\n\n    // {.todo} Even though there are three formulas, they are all very similar. First, notice\n    // that whatever angle is in the cosine, the opposite side is on the other side of\n    // the equal sign.\n    //\n    // {.todo} Use Law of Cosines when given:\n    // Two sides and the included angle.\n    // All three sides.\n:::"
    },
    {
      "id": "trigonometry-4",
      "content": "{.todo} COMING SOON – Proof, examples and applications\n\n    // TODO Future stuff about trigonometry"
    },
    {
      "id": "mountains",
      "content": "### The Great Trigonometric Survey\n\nDo you still remember the quest to find the highest mountain on Earth from the\n[introduction](/course/triangles/introduction)? With Trigonometry, we finally\nhave the tools to do it!\n\n::: .sticky-wrap\n\n    figure.sticky.mountain\n      x-geopad.no-background(width=760 height=250): svg\n        image(href=\"images/mountain.svg\" height=240 width=760 y=5)\n        circle(name=\"a\" x=\"point(25, 230)\" target=\"points\")\n        circle(name=\"b\" x=\"point(185, 230)\" target=\"points\")\n        circle(name=\"x\" x=\"point(573, 7)\" target=\"\")\n        circle(name=\"y\" x=\"point(573, 230)\" target=\"\")\n\n        path.fill.red(x=\"angle(x,a,b)\" label=\"23°\" target=\"angles ang\" size=60)\n        path.fill.blue(x=\"angle(x,b,y)\" label=\"29°\" target=\"ang1\" size=50)\n        path.fill(name=\"angle-b\" x=\"angle(b,x,a)\" label=\"β\" target=\"b angles\" size=100)\n        path.fill.green(name=\"angle-a\" x=\"angle(a,b,x)\" label=\"α\" target=\"a angles\" size=25)\n        path(x=\"angle(b,y,x)\")\n\n        path.yellow(x=\"segment(a,b)\" target=\"base right\" label=\"5km\")\n        path.yellow(x=\"segment(b,x)\" target=\"\")\n        path.yellow(name=\"side-d\" x=\"segment(a,x)\" target=\"d right\" label=\"d\")\n        path.yellow(x=\"segment(b,y)\" target=\"right\")\n        path.yellow(x=\"segment(x,y)\" target=\"right\" label=\"height\")\n\nThe surveyors in India measured the angle of the top of a mountain from [two\ndifferent positions](target:points), [{.yellow} 5km apart](target:base).\nThe results were [{.red} 23°](target:ang) and [{.blue} 29°](target:ang1).\n\nBecause [{.green} angle α](target:a) is a [supplementary angle](gloss:supplementary-angles),\nwe know that it must be [[151]]°. _{span.reveal(when=\"blank-0\")}Now we can use the sum of the\ninternal angles of a triangle to work out that [angle β](target:b) is [[6]]°._\n\n{.reveal(when=\"blank-1\")} Now we know [all three angles](target:angles) of the triangle, as well as\n[{.yellow} one of the sides](target:base). This is enough to use the [[sine rule|cosine rule]]\nto find the distance [_d_](target:d):\n\n    table.eqn-system\n      tr.reveal(when=\"blank-2\")\n        td.md `(\"sin\" pill(\"151°\",\"green\",\"a\")) / blank(d,5)`\n        td.md `= (\"sin\" pill(\"6°\",\"\",\"b\")) / blank(5,d)`\n      tr.reveal(when=\"blank-3 blank-4\")\n        td.md `d`\n        td.md `= \"sin\" pill(\"151°\",\"green\",\"a\") × pill(5,\"yellow\",\"base\") / (\"sin\" pill(\"6°\",\"\",\"b\"))`\n      tr.reveal(when=\"blank-3 blank-4\" delay=1000)\n        td\n        td.md `= pill(\"23.2 km\",\"yellow\",\"d\")`\n\n{.reveal(when=\"blank-3 blank-4\" delay=2000)} There is one final step: let’s have\na look at the [{.yellow}big, right-angled triangle](target:right). We already know the\nlength of the hypotenuse, but what we really need is the [[opposite|adjacent]]\nside. _{span.reveal(when=\"blank-5\")}We can find it using the definition of\n*sin*:_\n\n    table.eqn-system\n      tr.reveal(when=\"blank-5\" delay=1000)\n        td.md `\"sin\" pill(\"23°\",\"red\",\"ang\")`\n        td.md `= blank(\"height\",23) / blank(23,\"height\")`\n      tr.reveal(when=\"blank-6 blank-7\")\n        td.md `\"height\"`\n        td.md `= \"sin\" pill(\"23°\",\"red\",\"ang\") × pill(23,\"yellow\",\"d\")`\n      tr.reveal(when=\"blank-6 blank-7\" delay=1000)\n        td\n        td.md `= pill(\"8.987 km\",\"yellow\",\"height\")`\n\n{.reveal(when=\"blank-6 blank-7\" delay=2000)} And that is very close to the\nactual height of Mount Everest, the highest mountain on Earth: 8,848m.\n:::"
    },
    {
      "id": "mountains-1",
      "content": "This explanation greatly simplifies the extraordinary work done by the\nmathematicians and geographers working on the Great Trigonometrical Survey. They\nstarted from sea level at the beach, measured thousands of kilometers of\ndistance, built surveying towers across the entire country and even accounted\nfor the curvature of Earth.\n\n    figure: x-img(src=\"images/himalaya.jpg\" width=760 height=320)"
    }
  ],
  "title": "Triangles and Trigonometry"
}