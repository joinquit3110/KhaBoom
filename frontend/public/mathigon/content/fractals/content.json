{
  "sections": [
    {
      "section": "introduction",
      "id": "intro",
      "trailer": "ohygDnKg5mg",
      "color": "\"#8032AD\"",
      "level": "Advanced",
      "next": "chaos",
      "content": "# Fractals\n\n## Introduction\n\n\nWhen looking around nature, you might have noticed intricate plants like\nthese:\n\n::: column.r(width=320)\n\n    img(src=\"images/fern.jpg\" width=320 height=240)\n    img.fractal-overlay(src=\"images/fern-overlay.png\" width=320 height=240)\n\n{.caption} This __Fern__ consists of many small leaves that branch off a larger\none.\n\n::: column.r(width=320)\n\n    img(src=\"images/romanesco.jpg\" width=320 height=240)\n    img.fractal-overlay(src=\"images/romanesco-overlay.png\" width=320 height=240)\n\n{.caption} This __Romanesco broccoli__ consists of smaller [[cones|cubes|spheres]]\nspiralling around a larger one.\n\n:::\n\n{.reveal(when=\"blank-0\")} Initially, these appear like highly complex shapes –\nbut when you look closer, you might notice that they both follow a relatively\nsimple pattern: all the [individual parts](target:fractal) of the plants look\nexactly the same as the entire plant, just smaller. The same pattern is repeated\nover and over again, at smaller scales.\n[Continue](btn:next)"
    },
    {
      "id": "fern",
      "content": "In mathematics, we call this property __self-similarity__, and shapes that\nhave it are called [__fractals__](gloss:fractal). They are some of the most\nbeautiful and most bizarre objects in all of mathematics.\n\nTo create our own fractals, we have to start with a simple pattern and then\nrepeat it over and over again, at smaller scales.\n\n::: column.grow\n\nOne of the simplest patterns might be a [{.red} line segment](target:s1),\nwith [{.blue} two more segments](target:s2) branching off one end. If we\nrepeat this pattern, both of these blue segments will also have two more\nbranches at their ends.\n\nYou can move the [{.blue} blue dots](target:dot) to change the length and angle of all\nof the branches. Then increase the number of iterations using [the\nslider](->#fern-slider) below.\n\n{.reveal(when=\"slider-0\")} Depending on the position of the branches, you can\nmake completely different patterns – looking like the\n[fern](action:set(130,228,197,184)) above, a [tree](action:set(160,186,200,186)),\nor [nested pentagons](action:set(113,235,232,238)). What else can you find?\n[Continue](btn:next)\n\n::: column(width=360)\n\n    x-geopad(width=360 height=360 projections=\"no\")\n      canvas(width=720 height=720)\n      svg\n        circle(x=\"point(180,340)\" name=\"a\" hidden)\n        circle(x=\"point(180,250)\" name=\"b\" hidden)\n        circle.move.blue.pulsate(name=\"c1\" cx=150 cy=175 target=\"s2 dot\")\n        circle.move.blue.pulsate(name=\"c2\" cx=225 cy=220 target=\"s2 dot\")\n        path.thick.red(x=\"segment(a,b)\" target=\"s1\")\n        path.thick.blue.rounded(x=\"polyline(c1,b,c2)\" target=\"s2\")\n    x-slider#fern-slider(steps=8 :bind=\"steps\")\n\n:::"
    },
    {
      "id": "triangle",
      "content": "::: column.grow(parent=\"right\")\n\nAnother famous fractal is the [__Sierpinski triangle__](gloss:sierpinski-triangle).\nIn this case, we start with a large, equilateral triangle, and then repeatedly\ncut smaller triangles out of the remaining parts.\n\n{.reveal(when=\"slider=0\")} Notice how the final shape is made up of [{.red} three\nidentical copies of itself](target:x), and each of these is made up of even\nsmaller copies of the entire triangle! You could keep zooming into the triangle\nforever, and the patterns and shapes will always continue repeating.\n\n::: column(width=300)\n\n    svg.sierpinski.var(width=300 height=265)\n      path.red(:draw=\"triangle\" :show=\"!steps\")\n      g.red.t1\n        path(:draw=\"t1\")\n        path.white(:d=\"sierpinski(t1.points, steps-1)\")\n      g.red.t2\n        path(:draw=\"t2\")\n        path.white(:d=\"sierpinski(t2.points, steps-1)\")\n      g.red.t3\n        path(:draw=\"t3\")\n        path.white(:d=\"sierpinski(t3.points, steps-1)\")\n    x-slider(steps=8 :bind=\"steps\")\n\n:::"
    },
    {
      "id": "real",
      "content": "The plants at the beginning of this chapter _look_ just like fractals, but it is\nclearly impossible to create _true_ fractals in real-life. If we keep repeating\nthe same pattern over and over again, smaller and smaller, we would eventually\nget to cells, molecules or atoms which can no longer be divided.\n\nHowever, using mathematics, we can think about the properties that real fractals\n“would” have – and these are very surprising…\n[Continue](btn:next)"
    },
    {
      "id": "dimension",
      "content": "### Fractal Dimensions\n\n::: column(width=240)\n\n    img(src=\"images/line.png\" width=240 height=20)\n\n::: column.grow\n\nFirst, let’s think about the dimension of fractals. A line has dimension [[1]].\n_{span.reveal(when=\"blank-0\")} When scaling it by a factor of 2, its length\nincreases by a factor of `2^1 = 2`. Obviously!_\n\n:::"
    },
    {
      "id": "dimension-1",
      "content": "::: column(width=240)\n\n    img(src=\"images/square.png\" width=240 height=131)\n\n::: column.grow\n\nA square has dimension [[2]]. _{span.reveal(when=\"blank-0\")} When scaling it by\na factor of 2, its area increases by a factor of `2^2 =` [[4]]._\n\n:::"
    },
    {
      "id": "dimension-2",
      "content": "::: column(width=240)\n\n    img(src=\"images/cube.png\" width=240 height=157)\n\n::: column.grow\n\nA cube has dimension [[3]]. _{span.reveal(when=\"blank-0\")} When scaling it by\na factor of 2, its volume increases by a factor of `2^3 =` [[8]]._\n_{span.reveal(when=\"blank-1\")} Notice that the larger cube in the image\nconsists of 8 copies of the smaller one!_\n\n:::"
    },
    {
      "id": "dimension-3",
      "content": "::: column(width=240)\n\n    img(src=\"images/sierpinski.png\" width=240 height=114 style=\"position:sticky;top:48px\")\n\n::: column.grow\n\nNow let’s have a look at the Sierpinski triangle. If we scale it by a factor of\n2, you can see that it’s “area” increases by a factor of [[3]].\n\n{.reveal(when=\"blank-0\")} Let’s say that _d_ is the dimension of the Sierpinski\ntriangle. Using the same pattern as above, we get `2^d = 3`. In other words,\n_d_ = [[`log_2(3)`|`log_3(2)`]] _{span.reveal(when=\"blank-1\")}≈ 1.585…_\n\n:::"
    },
    {
      "id": "dimension-4",
      "content": "But wait … how can something have a dimension that is not an integer? It seems\nimpossible, but this is just one of the weird properties of fractals. In fact,\nthis is what gives fractals their name: they have a __fractional dimension__.\n\nWith every iteration, we remove some of the area of the Sierpinski triangle.\nIf we could do this infinitely many times, there would actually be no area\nleft: that’s why the Sierpinski triangle is something in-between a two-dimensional\narea, and a one-dimensional line.\n\n::: .theorem\nWhile many fractals are _self-similar_, a better definition is that __fractals__\nare shapes which have a __non-integer dimension__.\n:::\n\n[Continue](btn:next)"
    },
    {
      "id": "snowflake",
      "content": "### The Koch Snowflake\n\nThere are many shapes in nature that look like fractals. We’ve already seen\nsome plants at the beginning of this chapter. Other great examples are\nsnowflakes and ice crystals:\n\n::: column(width=120 parent=\"padded-thin\")\n\n    x-img(src=\"images/snow-1.jpg\" width=120 height=120 alt=\"Snowflake\")\n\n::: column(width=120)\n\n    x-img(src=\"images/snow-2.jpg\" width=120 height=120 alt=\"Snowflake\")\n\n::: column(width=120)\n\n    x-img(src=\"images/snow-3.jpg\" width=120 height=120 alt=\"Snowflake\")\n\n::: column(width=120)\n\n    x-img(src=\"images/snow-4.jpg\" width=120 height=120 alt=\"Snowflake\")\n\n::: column(width=120)\n\n    x-img(src=\"images/snow-5.jpg\" width=120 height=120 alt=\"Snowflake\")\n\n:::"
    },
    {
      "id": "koch",
      "content": "To create our own fractal snowflake, we once again have to find a simple\nprocedure we can apply over and over again.\n\n::: column.grow\n\nLike the Sierpinski triangle, let’s start with a single, equilateral triangle.\nHowever, rather than _removing_ smaller triangles at every step, we _add_\nsmaller triangles along the edge. The side-length of every triangle is\n[[`1/3`|`1/4`|`1/2`]] of the triangles in the previous step.\n\n{.reveal(when=\"blank-0\")} The resulting shape is called the [__Koch\nsnowflake__](gloss:koch-snowflake), named after the Swedish mathematician [Helge\nvon Koch](bio:koch). Notice, once again, that [{.blue} small sections](target:t2) of the\nedge of the snowflake look exactly the same as [{.blue} larger sections](target:t1).\n\n::: column(width=300)\n\n    svg.var(width=300 height=300)\n      path.blue(:draw=\"koch(steps)\")\n      rect.overlay(y=76 width=300 height=224 target=\"t1\")\n      polygon.overlay(points=\"300 0 90 0 107 76 0 76 0 300 300 300 300 0\" target=\"t2\")\n    x-slider(steps=5 :bind=\"steps\")\n\n:::"
    },
    {
      "id": "koch-dimension",
      "content": "::: column(width=380)\n\n    img(src=\"images/koch.png\" width=380 height=171)\n\n::: column.grow\n\nWhen we scale one edge segment of the Koch Snowflake by a factor of 3, its\nlength [[quadruples|triples|doubles]].\n\n{.reveal(when=\"blank-0\")} Using the same relationship between dimensions and\nscale factors as above, we get the equation [[`3^d=4`|`2^d=4`|`2^d=3`|`4^d=3`]].\n_{span.reveal(when=\"blank-1\")} This means that the dimension of the Koch\nSnowflake is `§d = log_3(4) ≈ 1.262`._\n\n:::"
    },
    {
      "id": "koch-size",
      "content": "::: tab(parent=\"sticky\")\n\n#### Area _{span.check(when=\"blank-6\")}_\n\nCreating the Koch snowflakes is almost like a [recursive\nsequence](gloss:sequence-recursive): we know the starting shape (a triangle),\nand we know how to get from one term to the next (by adding more triangles on\nevery edge):\n\n::: column(width=140)\n\n    img#koch-0(src=\"images/koch-0.svg\" width=140 height=160)\n\n::: column(width=140)\n\n    img#koch-1(src=\"images/koch-1.svg\" width=140 height=160)\n\n{.text-center} [[3]] new triangles\n\n::: column(width=140)\n\n    img(src=\"images/koch-2.svg\" width=140 height=160)\n\n{.text-center} [[12]] new triangles\n\n::: column(width=140)\n\n    img(src=\"images/koch-3.svg\" width=140 height=160)\n\n{.text-center} [[48]] new triangles\n\n:::\n\n{.reveal(when=\"blank-0 blank-1 blank-2\")}\nAfter the first iteration, the number of new triangles added increases by a\nfactor of [[4]] at every step. At the same time, the area of these new triangles\ndecreases by a factor of [[9]] at every step.\n\n{.reveal(when=\"blank-3 blank-4\")}\nLet’s say that the [{.purple} first triangle](->#koch-0) has an area of 1. Then the total\narea of the [{.purple} next three triangles](->#koch-1) is `3 × 1/9 = 1/3`. The following\nsteps all form a [[geometric series|arithmetic series|quadratic series]],\n_{span.reveal(when=\"blank-5\")} with common ratio [[`4/9`|`9/4`|`4/3`]]._\n\n{.reveal(when=\"blank-6\")}\nUsing the formula for the sum of infinite [geometric series](gloss:geometric-series),\nwe can calculate that the total area of the Koch snowflake is\n\n{.text-center.reveal(when=\"blank-6\")}\n`A = 1 + 1/3 × 1/blank(1-4/9, 1+9/4, 9-1/4) reveal(= 8/5 = 1.6,\"blank-7\")`.\n\n::: tab\n\n#### Perimeter _{span.check(when=\"blank-9\")}_\n\n::: column.grow\n\nWe can also try to calculate the perimeter of the Koch snowflake. As we have\nalready seen before, the length of the perimeter changes by a factor of\n[[`4/3`|`3/4`|`1/4`]] at every step.\n\n{.reveal(when=\"blank-8\")}\nThis means that, once again, we have a geometric series – but in this case, it\n[[doesn’t converge|converges to 0|doesn’t have a first term]].\n_{span.reveal(when=\"blank-9\")} This means that the perimeter of the Koch\nsnowflake is actually **infinitely long**!_\n\n::: column(width=220)\n\n    img(src=\"images/koch-edge.svg\" width=220 height=250)\n\n:::\n\n{.reveal(when=\"blank-9\")} _If this seems counterintuitive, just remember that\nwe multiply the perimeter by `§4/3` at every step, and we do this infinitely\nmany times._\n\n:::"
    },
    {
      "id": "frozen",
      "content": "//- ::: column.grow\n\nIt is almost unthinkable that you can have a shape with a _finite_ area and also\nan _infinite_ circumference – but this is just one of the many unexpected\nproperties of fractals.\n\nCan you come up with any other ways to create your own fractals?\n[Continue](btn:next)\n\n    //- ::: column(width=352)\n    //-     x-video(src=\"images/frozen.mp4\" poster=\"images/frozen.jpg\" width=352 height=198 audio credit=\"© Disney\")\n    //- {.caption} “My soul is spiralling on frozen fractals all around…”\n    //- :::"
    },
    {
      "id": "menger-sponge",
      "content": "### Menger Sponge\n\nFractals don’t have to be “flat”, like many of the examples above. One of the\nmost famous fractals that look three-dimensional is the __Menger sponge__, named\nafter the mathematician [Karl Menger](bio:menger) who first described it in 1926.\n\n::: column(width=320 parent=\"right\")\n\n    x-menger-sponge.var(size=320 :steps=\"steps\")\n    x-slider(steps=3 :bind=\"steps\")\n\n::: column.grow\n\nWe start with a solid cube, and repeatedly drill smaller and smaller holes into\nits sides. Every new iteration of holes has [[`1/3`|`1/2`|`1/4`]] the width of\nthe previous iteration of holes.\n\n{.reveal(when=\"blank-0\")} A `3×3×3` cube consists of 27 smaller cubes, but here\nwe have removed some of these. The Menger sponge consists of [[20]] copies of\nitself, which are 3 times smaller.\n\n{.reveal(when=\"blank-1\")} Now we can try to calculate the dimension _d_ of the\nMenger sponge just like we did for the Koch snowflake above. In this case we get\n`3^d = 20`, or `§d = log_3(20) ≈ 2.727`.\n\n:::\n\n{.reveal(when=\"blank-1 slider-0\")} If you imagine cutting out more and more holes,\ninfinitely many times, there would be no actual volume left. That’s why the cube\nis “not quite” three-dimensional!\n[Continue](btn:next)"
    },
    {
      "id": "coastlines",
      "content": "### Fractal Coastlines\n\nOne of the key characteristics of all the fractals we’ve seen so far is that\nyou can “zoom in” forever and always find new patterns. Around 1920, the\nBritish mathematician [Lewis Fry Richardson](bio:richardson) realised that the\nsame is true for the border or coastline of many countries.\n\nYou start with the basic shape of the country, and, as you zoom in, you add\nriver inlets, bays and estuaries, then individual cliffs, rocks, pebbles, and so\non:\n\n::: column(width=120 parent=\"padded-thin\")\n\n    x-img(src=\"images/coast-1.jpg\" width=120 height=180 alt=\"Coastline\")\n\n::: column(width=120)\n\n    x-img(src=\"images/coast-2.jpg\" width=120 height=180 alt=\"Coastline\")\n\n::: column(width=120)\n\n    x-img(src=\"images/coast-3.jpg\" width=120 height=180 alt=\"Cliffs\")\n\n::: column(width=120)\n\n    x-img(src=\"images/coast-4.jpg\" width=120 height=180 alt=\"Beach\")\n\n::: column(width=120)\n\n    x-img(src=\"images/coast-5.jpg\" width=120 height=180 alt=\"Pebbles\")\n\n:::\n\n[Continue](btn:next)"
    },
    {
      "id": "coastlines-1",
      "content": "::: column.grow\n\nThis is a significant problem when trying to calculate the length of the border\nof a country – how do you decide how far to zoom in, and which nooks and\ncrannies to include?\n\nOne way we could measure the length of Britain’s coastline, for example, is to\ntake a long ruler, walk all the way around its beaches, and then add up all the\ndistances.\n\nIf the ruler is ${rulers[index]}{index|0|0,8,1}km long, we have to use it\n${count} times, so we get a total coastline of ${count} × ${rulers[index]} =\n${count * rulers[index]}km.\n\n{.reveal(when=\"var-0\")} We can just keep going, with smaller and smaller rulers,\nand each time our result for the length of the coastline would get a bit\nlonger. Just like the Koch Snowflake before, it seems that Britain’s coastline\nis infinitely long! This is often called the __coastline paradox__.\n[Continue](btn:next)\n\n::: column(width=280)\n\n    .coastline: include svgs/britain.svg\n\n:::"
    },
    {
      "id": "coastline-grid",
      "content": "A few decades later, the mathematician [Benoit Mandelbrot](bio:mandelbrot)\nstumbled upon Richardson’s work in a discarded library book, while working at\nIBM. He recognised its significance, and also how it relates to more recent\nresearch on fractals and dimensions.\n\n::: column(width=340)\n\n    include svgs/cells.svg\n    x-slider(steps=10 continuous :bind=\"i\")\n\n::: column.grow\n\nThe coastline of Britain certainly “looks” fractal, but it is not\n_self-similar_, like other fractals we’ve seen before. In order to find\nits size, we can draw it on a grid and count the number of cells that\nit intersects with.\n\n{.r.reveal(when=\"slider-0\")} Initially, there are [{.b}88](pill:yellow)\nintersecting cells. If we scale the coastline by a factor of 2, there are\n[{.b}197](pill:yellow) intersecting cells – more than twice as many!\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-0\")} The size of the coastline has increased by a factor\nof `§197/88`. Like before, this means that the dimension of the coastline is\n\n{.text-center.reveal(when=\"next-0\")} `§d = log_2(197/88) ≈ 1.16`\n\n:::"
    },
    {
      "id": "coastline-dimension-1",
      "content": "If we repeat this with larger grids, we’d find that the dimension of Britain’s\ncoastline is actually approximately 1.21. Mandelbrot realised that this fractal\ndimension is also a measure of the __roughness__ of a shape – a new concept, for\nwhich he found important applications in many other areas of mathematics and\nscience."
    },
    {
      "id": "nature",
      "content": "### More Fractals in Nature and Technology\n\nWhile true fractals can never appear in nature, there are many objects that\nlook _almost_ like fractals. We’ve already seen plants, snowflakes and\ncoastlines, and here are some more examples:\n\n::: column(width=200)\n\n    // https://visibleearth.nasa.gov/images/72291/the-hindu-kush\n    x-img(src=\"images/nature/mountains.jpg\" width=200 height=200 lightbox credit=\"NASA/GSFC\" alt=\"Mountain range\")\n\n{.caption} Mountain range in central Asia\n\n::: column(width=200)\n\n    // https://de.wikipedia.org/wiki/Datei:Sundarbans.jpg\n    x-img(src=\"images/nature/rivers.jpg\" width=200 height=200 lightbox credit=\"NASA\" alt=\"River delta\")\n\n{.caption} Ganges river delta in India\n\n::: column(width=200 parent=\"padded-thin\")\n\n    x-img(src=\"images/nature/lightning.jpg\" width=200 height=200 lightbox alt=\"Lightning bolts\")\n\n{.caption} Lightning bolts\n\n::: column(width=200)\n\n    // https://commons.wikimedia.org/wiki/File:Fundus_photograph_of_normal_right_eye.jpg\n    x-img(src=\"images/nature/retina.jpg\" width=200 height=200 lightbox credit=\"Mikael Häggström, CC-BY-SA\" alt=\"Blood vessels\")\n\n{.caption} Blood vessels in the retina\n\n::: column(width=200)\n\n    // https://www.flickr.com/photos/usgeologicalsurvey/11188773133\n    x-img(src=\"images/nature/canyons.jpg\" width=200 height=200 lightbox credit=\"US Geological Survey\" alt=\"Grand Canyon\")\n\n{.caption} Grand Canyon in the USA\n\n::: column(width=200)\n\n    x-img(src=\"images/nature/clouds.jpg\" width=200 height=200 lightbox alt=\"Clouds\")\n\n{.caption} Clouds\n\n:::\n\nAll these objects might appear completely random, but, just like fractals, there\nis an underlying pattern that determines how they are formed. Mathematics can\nhelp us understand the shapes better, and fractals have applications in fields\nlike medicine, biology, geology and meteorology.\n[Continue](btn:next)\n\n    // TODO https://en.wikipedia.org/wiki/Fractal_antenna\n    // TODO Fractals in African Art"
    },
    {
      "id": "sierpinski",
      "section": "sierpinski",
      "content": "::: column(width=300)\n\n    // https://commons.wikimedia.org/wiki/File:Fractal_terrain_texture.jpg\n    x-img(src=\"images/terrain.jpg\" width=360 height=270 lightbox alt=\"Computer-generated fractal terrain with mountains and water\")\n\n{.caption} Computer-generated fractal terrain\n\n::: column.grow\n\nWe can also use fractals to create realistic “copies” of nature, for example, as\nlandscapes and textures used in video games or computer-generated movies. The\nwater, mountains and clouds in this image are made entirely by a computer, with\nthe help of fractals!\n\nAnd we can even reverse this process to compress digital images, to reduce their\nfile size. The first algorithms were developed by Michael Barnsley and Alan\nSloan in the 1980s, and new ones are still being researched today.\n\n:::\n\n\n--------------------------------------------------------------------------------\n\n\n## The Sierpinski Triangle\n\n\n::: column.grow\n\nOne of the fractals we saw in the previous chapter was the [__Sierpinski\ntriangle__](gloss:sierpinski-triangle), which is named after the Polish\nmathematician [Wacław Sierpiński](bio:sierpinski). It can be created by starting\nwith one large, equilateral triangle, and then repeatedly cutting smaller\ntriangles out of its center.\n\n{.r.reveal(when=\"slider-0\")} Wacław Sierpiński was the first mathematician to think about the\nproperties of this triangle, but it has appeared many centuries earlier in artwork, patterns and\nmosaics.\n\n::: column(width=300)\n\n    svg.var.sierpinsk(width=300 height=265)\n      path.red(:draw=\"triangle\")\n      path.white(:d=\"sierpinski(triangle.points, steps)\")\n    x-slider(steps=8 :bind=\"steps\")\n\n:::"
    },
    {
      "id": "sierpinski-history",
      "content": "Here are some examples of floor tilings from different churches in Rome:\n\n::: column(width=140 parent=\"padded-thin\")\n\n    // https://commons.wikimedia.org/wiki/File:Santa_Maria_in_Cosmedin_(Roma).jpg\n    x-img(src=\"images/floor-1.jpg\" width=140 height=140 credit=\"Wiki LIC, CC-BY-SA-4.0\" alt=\"Mosaic Floor with Sierpinski Triangle\")\n\n::: column(width=140)\n\n    // Permission from Elisa Conversano\n    x-img(src=\"images/floor-2a.jpg\" width=140 height=140 credit=\"San Clemente, Carlini und Conversano, 2010\" alt=\"Mosaic Floor with Sierpinski Triangle\")\n\n::: column(width=140)\n\n    // https://www.cattedraledianagni.it/\n    x-img(src=\"images/floor-2.jpg\" width=140 height=140 credit=\"© cattedraledianagni.it\" alt=\"Mosaic Floor with Sierpinski Triangle\")\n\n::: column(width=140)\n\n    // http://matheuro.overblog.com/2014/05/sierpinski-s-triangle-the-nave-of-the-roman-basilica-of-santa-maria-in-comesdin.html\n    x-img(src=\"images/floor-3.jpg\" width=140 height=140 credit=\"© Lycée Baudelaire\" alt=\"Mosaic Floor with Sierpinski Triangle\")\n\n:::\n\nAs it turns out, the Sierpinski triangle appears in a wide range of other areas\nof mathematics, and there are many different ways to generate it. In this\nchapter, we will explore some of them!\n[Continue](btn:next)"
    },
    {
      "id": "pascal",
      "goals": "select",
      "content": "### Pascal’s Triangle\n\nYou might already remember the Sierpinski triangle from our chapter on\n[__Pascal’s triangle__](gloss:pascals-triangle). This is a number pyramid in\nwhich every number is the sum of the two numbers above. Tap on all the _even_\nnumbers in the triangle below, to highlight them – and see if you notice a\npattern:\n\n    - var fact = function(x) { return !x ? 1 : (x * fact(x-1)); };\n    - var bin = function(a, b) { return Math.round(fact(a) / fact(b) / fact(a - b)); };\n    figure: .overflow-wrap: .pascal-grid.small(style=\"width: 760px\")\n      - var i = 0;\n      while i <= 18\n        - var j = 0\n        .r\n          while j <= i\n            - b = bin(i, j)\n            .c= b\n            - j += 1;\n        - i += 1;"
    },
    {
      "id": "pascal-1",
      "content": "Pascal’s triangle can be continued downwards forever, and the Sierpinski pattern\nwill continue with bigger and bigger triangles. You can already see the\nbeginning of an even larger triangle, starting in row 16.\n\nIf two adjacent cells are divisible by 2, then their sum in the cell underneath\nmust also be divisible by 2 – that’s why we can only get coloured triangles\n(or single cells). Of course, we can also try colouring all cells divisible by\nnumbers _other than 2_. What do you think will happen in those cases?\n[Continue](btn:next)"
    },
    {
      "id": "pascal-large",
      "content": ".pascal-canvas\n      canvas.pascal(width=960 height=840)\n      .label Divisible by #[span.circled.var(style=\"background: ${gradient[n - 2]}\") ${n}]:\n\nHere you can see a tiny version of the first 128 rows of Pascal’s triangle.\nWe have highlighted all cells that are divisible by ${n}{n|2|2,40,1} – what\ndo you notice?\n\n{.reveal(when=\"var-0\")} For every number, we get a different triangular pattern\nsimilar to the Sierpinski triangle. The pattern is particularly regular if we\nchoose a [[prime number|triangle number|Fibonacci number]].\n_{span.reveal(when=\"blank-0\")} If the number has *many different* prime factors,\nthe pattern looks more random._\n\n    x-gesture(target=\"#pascal-large x-var\" slide=\"100,0\")"
    },
    {
      "id": "chaos-game",
      "goals": "point play",
      "content": "### The Chaos Game\n\n::: column(width=360 parent=\"right\")\n\n    x-geopad.sticky#chaos-geo(width=360)\n      canvas(width=720 height=720)\n      svg\n        circle.red(name=\"x0\" x=\"tri[0]\")\n        circle.green(name=\"x1\" x=\"tri[1]\")\n        circle.yellow(name=\"x2\" x=\"tri[2]\")\n    x-gesture(target=\"#chaos-geo\")\n\n::: column.grow\n\nHere you can see the three vertices of an equilateral triangle. Tap anywhere\nin the grey area to create a fourth point.\n\n{.r.reveal(when=\"point\")} Let’s play a simple game: we pick one of the vertices\nof the triangle at random, draw a line segment between our point and the vertex,\nand then find the [{.red}midpoint](target:p1) of that segment.\n[Continue](btn:next)\n\n{.r.reveal(when=\"next-0\")} Now we repeat the process: we pick another random\nvertex, draw the segment from our last point, and then find the\n[{.green}midpoint](target:p2). Note that we colour these new points based\non the colour of the vertex of the triangle we picked.\n[Continue](btn:next)\n\n{.reveal(when=\"next-1\")} So far, nothing surprising has happened – but watch\nas we repeat the same process many more times:\n\n{.text-center.reveal.var(when=\"next-1\")}\n_{button.btn.btn-red(@click=\"play()\")} Add 1000 steps_\n\n:::"
    },
    {
      "id": "fractal-builder",
      "goals": "s1 s2 shape play",
      "content": "This process is called the __Chaos Game__. There might be a few stray points at\nthe beginning, but if you repeat the same steps many times, the distribution of\ndots starts to look exactly like the Sierpinski triangle!\n\nThere are many other versions of it – for example, we could start with a square\nor a pentagon, we could add additional rules like not being able to select the\nsame vertex twice in a row, or we could pick the next point at a ratio other\nthan `§1/2` along the segment. In some of these cases, we’ll just get a random\ndistribution of dots, but in other cases, we reveal even more fractals:\n\n    include components/chaos-game\n\n{.reveal(when=\"s1 s2 play\")} Did you discover the [Sierpinski\ncarpet](action:carpet()) or this [pentagonal snowflake](action:snowflake())\nbased on the [__golden ratio__](gloss:golden-ratio)?"
    },
    {
      "id": "cellular",
      "goals": "sierpinski",
      "content": "### Cellular Automata\n\nA __cellular automaton__ is a grid consisting of many individual cells. Every\ncell can be in different “states” (e.g. different colours), and the state of\nevery cell is determined by its surrounding cells.\n\nIn our example, every cell can be either black or white. We start with one row\nthat contains just a single black square. In every following row, the colour of\neach cell is determined by the three cells immediately above. Tap the eight\npossible options below to flip their colour – can you find a set of rules that\ncreates a pattern similar to the Sierpinski triangle?\n\n    figure: x-automaton(size=28)\n\n{.reveal(when=\"sierpinski\")} There are two choices for each of the eight\noptions, which means there are `2^8 =` [[256]] possible rules in total. Some,\nlike [Rule 126](action:setRule('01111110')), look like the Sierpinski triangle.\nOthers, like [Rule 30](action:setRule('01111000')), look completely chaotic.\nIt was discovered by [Stephen Wolfram](bio:wolfram) in 1983, and computers can\neven use them to generate random numbers!"
    },
    {
      "id": "cellular-1",
      "content": "::: column.grow\n\nCellular automata show how highly complex patterns can be created by very simple\nrules – just like fractals. Many processes in nature also follow simple rules,\nyet produce incredibly complex systems.\n\nIn some cases, this can lead to the appearance of patterns that look just like\ncellular automata, for example the colours on the shell of this snail.\n\n::: column(width=320)\n\n    x-img(src=\"images/shell.jpg\" width=320 height=240 lightbox credit=\"Richard Ling, CC BY-SA 3.0\" alt=\"Shell of a sea snail\")\n\n{.caption} Conus textile, a venomous sea snail\n\n:::"
    },
    {
      "id": "iteration",
      "section": "mandelbrot",
      "goals": "move-1 move-2",
      "content": "### Sierpinski Tetrahedra\n\nThere are many variants of the Sierpinski triangle, and other fractals with\nsimilar properties and creation processes. Some look two-dimensional, like the\n_Sierpinski Carpet_ you saw above. Others look three-dimensional, like these\nexamples:\n\n::: column(width=320)\n\n    x-sierpinski-tetrahedra(size=320 steps=5 style=\"display: block; margin-top: -20px\")\n\n{.caption} Sierpinski Tetrahedra\n\n::: column(width=320)\n\n    x-sierpinski-pyramid(size=320 steps=5 style=\"display: block; margin-top: -20px\")\n\n{.caption} Sierpinski Pyramid\n\n:::\n\n\n--------------------------------------------------------------------------------\n\n\n## The Mandelbrot Set\n\n\nAll the fractals we saw in the previous chapters were created using a process\nof __iteration__: you start with a specific pattern, and then you repeat it\nover and over again.\n\n::: column(width=112 parent=\"padded-thin\")\n\n    img(src=\"images/koch-0.svg\" width=112 height=128)\n\n::: column(width=112 parent=\"padded-thin\")\n\n    img(src=\"images/koch-1.svg\" width=112 height=128)\n\n::: column(width=112 parent=\"padded-thin\")\n\n    img(src=\"images/koch-2.svg\" width=112 height=128)\n\n::: column(width=112 parent=\"padded-thin\")\n\n    img(src=\"images/koch-3.svg\" width=112 height=128)\n\n:::\n\nThis is similar to another concept in mathematics that you saw before: with\n[recursive sequences](gloss:sequence-recursive), you start with a specific\nnumber, and then you apply the same recursive formula, again and again, to get\nthe next number in the sequence.\n\nLet’s take the recursive formula `§x_n = x_(n-1)^2` as an example, and plot its\nterms on a number line. You can change the value of `pill(x_0,\"yellow\",\"x0\")`:\n\n    figure: x-geopad.no-background(width=720 height=120 x-axis=\"-2.4,4.4,1\" y-axis=\"-0.1,0.1\" axes=\"yes,no\" padding=\"40 20 0\"): svg\n      circle.yellow.move.pulsate(x=\"point(0,0)\" name=\"x0\" project=\"line(point(-3,0),point(3,0))\" target=\"x0\")\n      path.blue.thick.reveal.light(x=\"segment(point(-1,0),point(1,0))\" style=\"stroke-width: 20px\" when=\"move-1 move-2\" animation=\"draw\" duration=1200)\n      path.yellow(:d=\"drawArc(x0)\")"
    },
    {
      "id": "iteration-1",
      "content": "Notice how the resulting sequence can behave very differently, depending on the\nstarting value `x_0`:\n\n::: column.frame.blue.text-center(width=212 parent=\"padded-thin\")\n\nIf `x_0 > 1`, the sequence [[diverges|converges]]:\n_{span.reveal(when=\"blank-0\")}it just keeps growing, up to infinity._\n\n::: column.frame.blue.text-center(width=212)\n\nIf `x_0` is between –1 and 1, the sequence [[converges|diverges]].\n\n::: column.frame.blue.text-center(width=212)\n\nIf `x_0 < -1`, the sequence [[diverges|converges]].\n\n:::"
    },
    {
      "id": "iteration-2",
      "content": "So far, we’ve not learned anything new. However, about one century ago,\nmathematicians started to explore what happens to these sequences if you use\n[__complex numbers__](gloss:complex-numbers), rather than just the real number\nline. Their discoveries were some of the most surprising and beautiful results\nin all of mathematics."
    },
    {
      "id": "julia",
      "goals": "wipe-a wipe-b wipe-c wipe-d",
      "content": "### Julia Sets\n\nLet’s use the same sequence as before, `§x_n = x_(n-1)^2`, but on the complex\nplane. You can move the position of `pill(x_0,\"yellow\",\"x0\")`, to see what\nhappens to the following terms. If the sequence looks like it will converge,\nlet’s colour the corresponding point on the plane in [blue](pill:blue):\n\n    figure: x-geopad(slot=\"stage\" width=720 height=480 x-axis=\"-2.2,2.2,1\" y-axis=\"-1.5,1.5,1\" axes grid padding=8 projections=\"no\" style=\"margin-bottom: 24px\" label-positioning=\"no\" label-suffix=\",i\" axis-names=\"Real, Imaginary\")\n      canvas(width=1440 height=960)\n      canvas(width=1440 height=960 style=\"opacity: 1\")\n      svg\n        circle.move.yellow.pulsate(name=\"x0\" x=\"point(0,0)\" target=\"x0\")\n        circle.yellow.transparent(name=\"x1\" x=\"iterate(x0)\" target=\"x1\")\n        circle.yellow.transparent(name=\"x2\" x=\"iterate(x1)\" target=\"x2\")\n        circle.yellow.transparent(name=\"x3\" x=\"iterate(x2)\" target=\"x3\")\n        path.yellow(x=\"spiral(x0)\")\n      .geo-legend\n        .formula.md `pill(x_n,\"yellow\") = pill(x_(n-1),\"yellow\")^2`\n        .sequence\n          .md `pill(x_0,\"yellow\", \"x0\") = var(\"complex(x0)\")`\n          .md `pill(x_1,\"yellow\", \"x1\") = var(\"complex(x1)\")`\n          .md `pill(x_2,\"yellow\", \"x2\") = var(\"complex(x2)\")`\n          .md `pill(x_3,\"yellow\", \"x3\") = var(\"complex(x3)\")`\n          div\n            span.vdots …\n            strong.var.m-blue(:show=\"converges\" data-display=\"inline\") Converges!\n            strong.var(:show=\"!converges\" data-display=\"inline\") Diverges!\n\n{.reveal(when=\"wipe-a wipe-b wipe-c wipe-d\")} As you can see, the sequence\nconverges as long as `pill(x_0,\"yellow\",\"x0\")` lies [[inside the unit circle|\noutside the unit square|above the *x*-axis]] _{span.reveal(when=\"blank-0\")}(the\ncircle with radius 1, centred at the origin)._"
    },
    {
      "id": "julia-1",
      "content": "Now let’s make things a bit more difficult. Rather than just squaring the\nprevious number, we also add a constant [_c_](pill:red) every time (which can be\nany complex number). In other words, `§x_n = x_(n-1)^2 + c`. Do you think we’ll\nstill get a circle of convergence? What other shapes do you think we might see?\n[Continue](btn:next)"
    },
    {
      "id": "julia-2",
      "content": "In this diagram, you can move the position of `pill(x_0,\"yellow\",\"x0\")` as well\nas the value of `pill(c,\"red\",\"c\")`:\n\n::: x-slideshow\n\n    x-geopad(slot=\"stage\" width=720 height=480 x-axis=\"-1.8,1.8,1\" y-axis=\"-1.2,1.2,1\" axes grid padding=8 projections=\"no\" style=\"margin-bottom: 24px\" label-suffix=\",i\" axis-names=\"Real, Imaginary\")\n      canvas(width=1440 height=960)\n      svg\n        circle.move.yellow(name=\"x0\" x=\"point(0.5,0.5)\" target=\"x0\")\n        circle.move.red(name=\"c\" x=\"point(0,0)\" target=\"c\")\n        circle.yellow.transparent(name=\"x1\" x=\"iterate(x0,c)\" target=\"x1\")\n        circle.yellow.transparent(name=\"x2\" x=\"iterate(x1,c)\" target=\"x2\")\n        circle.yellow.transparent(name=\"x3\" x=\"iterate(x2,c)\" target=\"x3\")\n        path.yellow(x=\"spiral(x0,c)\")\n      .geo-legend\n        .formula.md `pill(x_n,\"yellow\") = pill(x_(n-1),\"yellow\")^2 + pill(var(\"complex(c)\"),\"red\",\"c\")`\n        .sequence\n          .md `pill(x_0,\"yellow\", \"x0\") = var(\"complex(x0)\")`\n          .md `pill(x_1,\"yellow\", \"x1\") = var(\"complex(x1)\")`\n          .md `pill(x_2,\"yellow\", \"x2\") = var(\"complex(x2)\")`\n          .md `pill(x_3,\"yellow\", \"x3\") = var(\"complex(x3)\")`\n          div\n            span.vdots …\n            strong.var.m-blue(:show=\"converges\" data-display=\"inline\") Bounded!\n            strong.var(:show=\"!converges\" data-display=\"inline\") Diverges!\n\nWe already know what happens if [`c = 0`](action:animate(0,0)) – that’s the same as the example\nabove. The sequence convergence as long as `x_0` lies within the unit circle.\n\nAs soon as we change the value of _c_, something wonderful happens. The circle transforms into a\nhighly complex, fractal shape.\n\nWhen [`c = –0.54 + 0.5i`](action:animate(-0.54,0.5)), the shape divides into infinitely many tiny\nelements arranged in spirals.\n\n::: div\nIn some cases, the sequence doesn’t converge to a _single\npoint_ – instead it reaches a cycle of multiple points, like a triangle. These\ncycles are called __orbits__.\n\nPoints that are coloured blue mean that the corresponding sequence either\nconverges or has an orbit (we say that it is __bounded__). Points that are left\nwhite mean the corresponding sequence __diverges__: it is not bounded, and\neventually blows up to infinity.\n:::\n\nWhat else can you find? Have a look at the patterns when [`c = 0.4 + 0.21i`](action:animate(0.4,0.21))\nor when [`c = 0.38 – 0.25i`](action:animate(0.38,-0.25)). There are also some values of _c_ where\n_every_ sequence diverges, so the entire complex plane remains white.\n\n:::"
    },
    {
      "id": "julia-3",
      "content": "The different shapes that are formed by colouring in the numbers are called\n[__Julia sets__](gloss:julia-set). They were discovered independently by two\nFrench mathematicians, [Gaston Julia](bio:julia) and [Pierre Fatou](bio:fatou),\naround 1918.\n\nAt that time, there were no computers to help visualise what Julia sets actually\nlooked like. Mathematicians like Julia and Fatou were able to reason about them\nmathematically, but they only ever saw rough, hand-drawn sketches of what they\nmight look like.\n\nWe don’t have this problem today – the images below are all of different Julia\nsets. The different colours indicate _how quickly_ the sequence at that point\ndiverges:\n\n::: column(width=220)\n\n    x-img(src=\"images/julia-1.jpg\" width=220 height=165 lightbox alt=\"Julia set\")\n\n{.caption} `c = −0.70176 – 0.3842\"i\"`\n\n::: column(width=220)\n\n    x-img(src=\"images/julia-2.jpg\" width=220 height=165 lightbox alt=\"Julia set\")\n\n{.caption} `c = −0.4 + 0.6\"i\"`\n\n::: column(width=220)\n\n    x-img(src=\"images/julia-3.jpg\" width=220 height=165 lightbox alt=\"Julia set\")\n\n{.caption} `c = 0.285 + 0.01\"i\"`\n\n:::\n\n[Continue](btn:next)"
    },
    {
      "id": "mandel-paint",
      "goals": "wipe-a wipe-b wipe-c",
      "content": "### The Mandelbrot Set\n\nWhen creating the different Julia sets, you might have noticed that there were\nsome values of _c_ for which every sequence diverges, and the entire complex\nplane remains white. A few decades after Julia and Fatou, a new generation of\nmathematicians tried to map what these areas looked like.\n\nIn the previous example, we chose a fixed value for `pill(c,\"red\",\"c\")`, and then\nchanged the position of `pill(x_0,\"yellow\",\"x0\")` to colour the plane. Now let’s fix\nthe value of `pill(x_0 = 0,\"yellow\",\"x0\")`, and instead change the value of\n`pill(c,\"red\",\"c\")`.\n\nOnce more, paint over the complex plane to reveal the area in which sequences\nremain bounded. What shapes do you expect to appear?\n\n    figure: x-geopad.no-background(width=720 height=480 x-axis=\"-2.1,1.1,1\" y-axis=\"-1.1,1.1,1\" axes grid padding=8 projections=\"no\" label-suffix=\",i\" axis-names=\"Real, Imaginary\")\n      img(src=\"images/mandelbrot.png\" data-bounds=\"1,0.5,-1,-1.5\")\n      canvas(width=1440 height=960 style=\"opacity: 1\")\n      svg\n        circle.move.red.pulsate(name=\"c\" cx=0 cy=0 target=\"c\")\n        circle.yellow.transparent(name=\"x0\" x=\"point(0,0)\" target=\"x0\")\n        circle.yellow.transparent(name=\"x1\" x=\"iterate(x0,c)\" target=\"x1\")\n        circle.yellow.transparent(name=\"x2\" x=\"iterate(x1,c)\" target=\"x2\")\n        circle.yellow.transparent(name=\"x3\" x=\"iterate(x2,c)\" target=\"x3\")\n        path.yellow(x=\"spiral(x0,c)\")\n      .geo-legend\n        .formula.md `pill(x_n,\"yellow\") = pill(x_(n-1),\"yellow\")^2 + pill(var(\"complex(c)\"),\"red\",\"c\")`\n        .sequence\n          .md `pill(x_0,\"yellow\", \"x0\") = var(\"complex(x0)\")`\n          .md `pill(x_1,\"yellow\", \"x1\") = var(\"complex(x1)\")`\n          .md `pill(x_2,\"yellow\", \"x2\") = var(\"complex(x2)\")`\n          .md `pill(x_3,\"yellow\", \"x3\") = var(\"complex(x3)\")`\n          div\n            span.vdots …\n            strong.var.m-blue(:show=\"converges\" data-display=\"inline\") Bounded!\n            strong.var(:show=\"!converges\" data-display=\"inline\") Diverges!"
    },
    {
      "id": "mandel-history",
      "content": "This fractal is called the [__Mandelbrot set__](gloss:mandelbrot-set), and when\nrotated by 90°, it looks almost like a person, with head, body and two arms. It\nwas defined and drawn for the first time in 1978, in a research paper by the\nmathematicians Robert Brooks and Peter Matelski:\n\n    figure: x-img(src=\"images/printout.jpg\" width=360 height=290 credit=\"© Princeton University Press\" alt=\"Mandelbrot set drawing\")\n\nA few years later, [Benoit Mandelbrot](bio:mandelbrot) used the powerful\ncomputers at IBM to create a much more detailed visualisation of the fractal,\nwhich was later named after him. The first printouts looked different from what\nhe expected – until he realised that the technicians working at the printers\nwere cleaning up the “fuzziness” around its edge, assuming that it was caused by\ndust particles or printer errors, and not a defining characteristic of fractals!\n[Continue](btn:next)"
    },
    {
      "id": "mandel-zoom",
      "content": "Like all fractals, we can “zoom into” the Mandelbrot set forever, finding new\npatterns at every scale. Here you can zoom into a part of the Mandelbrot set\nthat is called the __Seahorse valley__. Black points are _inside_ the Mandelbrot\nset, where the sequence is bounded. Coloured points are _outside_ the Mandelbrot\nset, where the sequence diverges, and the different colours indicate _how\nquickly_ it grows to infinity:\n\n    .mandel-frame\n      - i = 1;\n      while i <= 27\n        img(src=\"images/mandel/mandel-\" + i + \".jpg\" width=760 height=500)\n        - i += 1;\n      .scale.var Scale: ${pow(scale)}\n    x-slider(steps=27 continuous speed=0.1 :bind=\"scale\")"
    },
    {
      "id": "mandel-zoom-1",
      "content": "This slider consists of 27 individual images, up to a zoom level of over 14\nquadrillion, or `2^54`. Altogether, they took almost 45 minutes to render on\na modern laptop. The Mandelbrot set can be created with just a single, simple\nequation, `§x_n = x_(n-1)^2 + c`, yet it is infinitely complex and stunningly\nbeautiful."
    },
    {
      "id": "mandel-orbits",
      "content": "::: column(width=360 parent=\"right\")\n\n    x-geopad.no-background(width=360 height=\"340\" x-axis=\"-1.5,0.5,1\" y-axis=\"-0.9,0.9,1\" axes padding=8 labels=\"no\")\n      img(src=\"images/mandelbrot.png\" data-bounds=\"1,0.5,-1,-1.5\")\n      svg\n        circle.move.red.pulsate(name=\"c\" x=\"point(-0.3,0.4)\" target=\"c\")\n        path.blue.transparent.fill(x=\"cardioid\" target=\"bulb0\")\n        path.blue.transparent.fill(x=\"circle(point(-0.125,0.745),0.094)\" target=\"bulb1\")\n        path.blue.transparent.fill(x=\"circle(point(-0.5045,0.563),0.039)\" target=\"bulb2\")\n        path.yellow.thin(x=\"spiral(point(0,0),c)\")\n\n::: column.grow\n\nAs you move the value of [{.red} _c_](target:c) around the Mandelbrot set,\nyou might notice a curious property:\n\n* All sequences within the [main body](target:bulb0) of the Mandelbrot set\n  [[converge|diverge|reach an orbit]] _{span.reveal(when=\"blank-0\")}to a single point._\n* {.reveal(when=\"blank-0\")} The sequences within the [large bulb](target:bulb1)\n  at the top [[reach an orbit|converge|diverge]] _{span.reveal(when=\"blank-1\")}\n  consisting of [[3]] points._\n* {.reveal(when=\"blank-2\")} Sequences in [this smaller bulb](target:bulb2) have\n  orbits of length [[5]].\n\n:::\n\n{.reveal(when=\"blank-3\")} Every bulb has a differently-sized orbit, with smaller\nbulbs having more and more points in their orbits. The size of these orbits are\nclosely related to the __Logistic Map__, an important concept in [Chaos\ntheory](/course/chaos).\n\n    // TODO: Generic pan+zoom (see http://mandel.gart.nz)\n    // TODO: Relationship between Julia and Mandelbrot sets\n    // TODO: Fibonacci Numbers in the Mandelbrot sets"
    },
    {
      "id": "mandel-outro",
      "section": "space-filling",
      "sectionStatus": "dev",
      "content": "::: column.grow\n\nBernoit Mandelbrot dedicated most of his life to the study of fractals, as well\nas the mathematics of _roughness_ and _self-similarity_. His work had\napplications in  physics, meteorology, neurology, economics, geology,\nengineering, computer science, and many other fields.\n\nIn 1985, the Mandelbrot set appeared on the cover of the _Scientific American_\nmagazine, and since then it has become one of the most recognisable mathematical\nshapes in the world. You can find it on T-shirts, in music videos, and as screen\nsavers, and it’s been referenced in many popular books and movies.\n\n::: column(width=220)\n\n    x-img(src=\"images/magazine.jpg\" width=220 height=316 credit=\"© Scientific American\" alt=\"Scientific American Magazine Cover\")\n\n:::\n\n\n--------------------------------------------------------------------------------\n\n\n## Space Filling Curves\n\n\n{.todo} Coming Soon!"
    }
  ],
  "title": "Fractals"
}