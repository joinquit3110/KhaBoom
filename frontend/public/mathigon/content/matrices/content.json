{
  "sections": [
    {
      "section": "transformations",
      "sectionStatus": "dev",
      "id": "rocket",
      "goals": "projectile",
      "color": "\"#5A49C9\"",
      "level": "Advanced",
      "content": "# Matrices\n\n## Transformations\n\n\n::: column.grow\n\nWhen we play video games with 3d graphics, what we are really looking at are millions of tiny triangles. Everything from the mountains and grass that make up the environment, to the goblins that guard the precious treasure, to the spaceship that you pilot through an asteroid belt, is made up of many small triangles. The computer in your video game console runs trillions of computations to figure out how each shape will be displayed on the screen.\n\n::: column.fit\n\n    x-geopad(width=400 x-axis=\"-18,18,5\" y-axis=\"-18,18,5\" padding=5): svg\n      - var path = \"point(0,3),point(2,0),point(2,-2),point(0,-1),point(-2,-2),point(-2,0)\"\n      path.fill.green(x=`polygon(${path}).rotate(th)`)\n\n:::\n\nWhat kind of computations is our computer performing? Before we try displaying intricate three-dimensional landscapes and characters, let's imagine we want to draw a 2d spaceship that we can rotate to shoot incoming asteroids."
    },
    {
      "content": "Here is our humble spaceship. Like the shapes displayed in video games, we can represent our spaceship as a collection of points, with lines connecting them. We can draw it on the xy coordinate plane, centered on the origin, with each point labelled as an (x, y) value.\n\n::: column(width=400)\n\n    x-geopad(width=400 x-axis=\"-5,5,1\" y-axis=\"-5,5,1\" axes grid padding=5): svg\n      circle.green(name=\"a\" x=\"point(0,3)\" label=\"A\" target=\"a\")\n      circle.green(name=\"b\" x=\"point(2,0)\" label=\"B\")\n      circle.green(name=\"c\" x=\"point(2,-2)\" label=\"C\")\n      circle.green(name=\"d\" x=\"point(0,-1)\" label=\"D\")\n      circle.green(name=\"e\" x=\"point(-2,-2)\" label=\"E\")\n      circle.green(name=\"f\" x=\"point(-2,0)\" label=\"F\")\n\n      path.green(x=\"segment(a,b)\")\n      path.green(x=\"segment(b,c)\")\n      path.green(x=\"segment(c,d)\")\n      path.green(x=\"segment(d,e)\")\n      path.green(x=\"segment(e,f)\")\n      path.green(x=\"segment(f,a)\")\n\n:::\n\nHere the point [{.green} A](target:a) has coordinates ([[0]], [[3]])."
    },
    {
      "content": "We would like to give our spaceship the ability to rotate in place, so the player can point it at incoming asteroids. This rotation is something we call a [transformation](gloss:transformation). Let's notify the Rotation of the spaceship through angle θ as `R_\"θ\"`.\n\n{.text-center} `{P_\"1\", P_\"2\", P_\"3\", P_\"4\", P_\"5\", P_\"6\"}` --- `R_\"θ\"` ---> `{P_\"1\"', P_\"2\"', P_\"3\"', P_\"4\"', P_\"5\"', P_\"6\"'}`\n{.fixme} Could be nice with hover points to graphic.\n\nEach point `P_\"n\"` has the transformation `R_\"θ\"` applied to it, which  rotates the point around the origin to get point `P_\"n\"'` (pronounced \"P n prime\").\n\nHere is a spaceship we can rotate by ${phi + 'º'}{phi|60|10,350,10} around the origin.\n\n::: column(width=400)\n\n    x-geopad(width=400 x-axis=\"-5,5,1\" y-axis=\"-5,5,1\" axes grid padding=5): svg\n      circle.green(name=\"a\" x=\"point(0,3)\" label=\"A\" target=\"a\")\n      circle.green(name=\"b\" x=\"point(2,0)\" label=\"B\")\n      circle.green(name=\"c\" x=\"point(2,-2)\" label=\"C\")\n      circle.green(name=\"d\" x=\"point(0,-1)\" label=\"D\")\n      circle.green(name=\"e\" x=\"point(-2,-2)\" label=\"E\")\n      circle.green(name=\"f\" x=\"point(-2,0)\" label=\"F\")\n\n      circle.blue(name=\"ap\" x=\"a.rotate(phi/180*pi)\" label=\"A'\")\n      circle.blue(name=\"bp\" x=\"b.rotate(phi/180*pi)\" label=\"B'\")\n      circle.blue(name=\"cp\" x=\"c.rotate(phi/180*pi)\" label=\"C'\")\n      circle.blue(name=\"dp\" x=\"d.rotate(phi/180*pi)\" label=\"D'\")\n      circle.blue(name=\"ep\" x=\"e.rotate(phi/180*pi)\" label=\"E'\")\n      circle.blue(name=\"fp\" x=\"f.rotate(phi/180*pi)\" label=\"F'\")\n\n      path.green(x=\"segment(a,b)\")\n      path.green(x=\"segment(b,c)\")\n      path.green(x=\"segment(c,d)\")\n      path.green(x=\"segment(d,e)\")\n      path.green(x=\"segment(e,f)\")\n      path.green(x=\"segment(f,a)\")\n\n      path.blue(x=\"segment(ap,bp)\")\n      path.blue(x=\"segment(bp,cp)\")\n      path.blue(x=\"segment(cp,dp)\")\n      path.blue(x=\"segment(dp,ep)\")\n      path.blue(x=\"segment(ep,fp)\")\n      path.blue(x=\"segment(fp,ap)\")\n\n:::\n\nHere are some things we can say about the shape of our spaceship as it rotates:\n- The spaceship must retain its shape.\n- The spaceship will have the same size.\n- It does not move up and down.\n\nWe would like a formula to convert any point `P` into its rotated point `P'`.\n\nLet's start by calculating this formula for two different points.\n\n[Continue](btn:next)"
    },
    {
      "id": "two-points",
      "content": "### Calculating the rotation of two points\n\nFor our two points, let's pick [{.green} A](target:a) = `(0,3)` and [{.green} B](target:b) = `(2,0)`. We can determine the formulas for their rotation [{.purple} θ](target:theta) around the origin one at a time.\n\n::: tab\n#### (0,3)\n\nIf we rotate the point [{.green}A](target:a) at (0,3) ${t1 + 'º'}{t1|60|10,350,10} around the origin, it has a new `(x,y)` value. We can call our rotated point [{.blue}A'](target:ap) (A prime), with coordinates `(x', y')` (x prime and y prime).\n\n::: column(width=400)\n\n    x-geopad(width=400 x-axis=\"-5,5,1\" y-axis=\"-5,5,1\" axes grid padding=5): svg\n      circle.green(name=\"a\" x=\"point(0,3)\" label=\"A\" target=\"a\")\n\n      circle.blue(name=\"ap\" x=\"a.rotate(t1/180*pi)\" label=\"A'\" target=\"ap tri1\")\n\n      path.green(x=\"segment(point(0,0),a)\")\n\n      path.blue(x=\"segment(point(0,0),ap)\" target=\"tri1\")\n      path.red(x=\"segment(point(0,ap.y), point(ap.x, ap.y))\" target=\"xp tri1\" label=\"x'\")\n      path.yellow(x=\"segment(point(0,0), point(0, ap.y))\" target=\"yp tri1\" label=\"y'\")\n\n      path.purple(x=\"angle(ap,point(0,0),a)\" target=\"theta tri1\" round size=40)\n\n:::\n\nWhat is a formula to get the new coordinates for A’? We can call our new x value [{.red}x'](target:xp), and our new y value [{.yellow}y'](target:yp). Both __x'__ and __y'__ will be dependent on the length of __A__, which is 3.\n\nThese points form a [right triangle](target:tri1), so we can draw upon our knowledge of trigonometry to find the formulas for __x'__ and __y'__.\n\n{.fixme} This might be confusing for theta > 90º\n\nOur [{.red}x'](target:xp) value is the opposite of the known angle, so we can use the formula for [sine](gloss:sin) to determine that:\n\n`x' = 3 * `[[-sin(θ)|sin(θ)|cos(θ)]]\n\nOur [{.yellow}y'](target:yp) value is the adjacent side of a right triangle, so we can use the formula for [cosine](gloss:cos) to determine that:\n\n`y' = 3 * `[[cos(θ)|sin(θ)]]\n\n\n::: tab\n#### (2,0)\n\nLet's look at another point.\nIf we rotate the point [{.green}B](target:b) at (2,0) ${t2 + 'º'}{t2|60|10,350,10} around the origin, it has a new `(x,y)` We can call our rotated point [{.blue}B'](target:bp) (B prime), with coordinates `(x', y')` (x prime and y prime).\n\n::: column(width=400)\n\n    x-geopad(width=400 x-axis=\"-5,5,1\" y-axis=\"-5,5,1\" axes grid padding=5): svg\n      circle.green(name=\"b\" x=\"point(2,0)\" label=\"B\" target=\"b\")\n\n      circle.blue(name=\"bp\" x=\"b.rotate(t2/180*pi)\" label=\"B'\" target=\"bp tri2\")\n\n      path.green(x=\"segment(point(0,0),b)\")\n\n      path.blue(x=\"segment(point(0,0),bp)\" target=\"tri2\")\n      path.red(x=\"segment(point(0,0), point(bp.x, 0))\" label=\"x'\" target=\"xp tri2\")\n      path.yellow(x=\"segment(point(bp.x, 0), point(bp.x, bp.y))\" label=\"y'\" target=\"yp tri2\")\n      path.purple(x=\"angle(bp,point(0,0),b)\" target=\"tri2\" round size=40)\n\n\n:::\n\nWhat is a formula to get the new coordinates for [{.blue}B’](target:bp)? We can call our new x value [{.red}x'](target:xp), and our new y value [{.yellow}y'](target:yp). Both __x'__ and __y'__ will be dependent on the length of __B__, which is 2.\n\nThese points form a [right triangle](target:tri2), so we can draw upon our knowledge of trigonometry to find the formulas for __x'__ and __y'__.\n\n{.fixme} This might be confusing for theta > 90º\n\nOur [{.red}x'](target:xp) value is the adjacent side of the known angle, so we can use the formula for [cosine](gloss:cos) to determine that:\n\n`x' = 2 * `[[cos(θ)|sin(θ)]]\n\nOur [{.yellow}y'](target:yp) value is the opposite side of the known angle, so we can use the formula for [sine](gloss:sin) to determine that:\n\n`y' = 2 * `[[sin(θ)|cos(θ)]]\n\n:::"
    },
    {
      "id": "linear-combination",
      "content": "::: column\n\nWe now have equations for the `(x', y')` coordinates of the two points `A'` and `B'`. We still have four more rotated points to calculate (`C'`, etc), but is there a shortcut where we can use what we already have?\n\n::: column\n\n\n    table\n      tr\n        td Name\n        td xy\n        td Rotated\n        td Rxy\n      tr\n        td A\n        td (0, 2)\n        td A'\n        td (-2sin(θ), 2cos(θ))\n      tr\n        td B\n        td (3, 0)\n        td B'\n        td 3cos(θ), 3sin(θ))\n      each p in [['C', [2, -2]] , ['D', [0, -1]], ['E', [-2, -2]], ['F', [-2, 0]]]\n        - var pp = p[0] + \"'\"\n        tr\n          td= p[0]\n          td= p[1]\n          td= pp\n          td\n\n:::\n\n{.fixme} Table needs to look a lot nicer.\n\n[Continue](btn:next)"
    },
    {
      "content": "Remember from our last course on [vectors](link/to/course) that any vector can be treated as a [linear combination](gloss:linear-combination) of the two unit vectors <uv>__i__</uv> and <uv>__j__</uv>.\n\nWe can use the formulas we calculated for rotations of __A__ and __B__ to find the rotation for any other point! __A__ lies along the y-axis so it is just a scaled version of the unit vector [[j|i]], and __B__ lies upon the x-axis so it is just a scaled version of the unit vector [[i|j]]."
    },
    {
      "content": "When we divide the lengths of A and B from the respective coordinates in A' and B', we can get the formulas for the rotations of the unit vectors.\n\n{.fixme} What kind of notation should we use? Unit Vectors? Points?\n\n`(1, 0)` becomes `(sinθ, -cosθ)` and `(0, 1)` becomes `(cosθ, sinθ)`."
    },
    {
      "content": "We can then write the equation for __any__ rotated point by writing it as a linear combination of the unit vectors.\n\nfor `x'`...\n\n{.text-center} `x' = pill(x, \"teal\") * cosθ - pill(y, \"purple\") * sinθ`\n\nfor `y'`...\n\n{.text-center} `y' = pill(x, \"teal\") * sinθ + pill(y, \"purple\") * cosθ`\n\n\nWe can rewrite this as a new vector.\n\n{.text-center} `§[[x'] [y']]` = `§[[(pill(x, \"teal\", \"x\", \"x\") * cosθ - pill(y, \"purple\") * sinθ)] [(pill(x, \"teal\") * sinθ + pill(y, \"purple\") * cosθ)]]`\n\n\nNotice that both x' and y' are dependent on [{.teal}x](target:x) and [{.purple}y.](target:y)\n\n[Continue](btn:next)"
    },
    {
      "id": "matrices",
      "content": "#### Matrices\n\nMathematicians came up with a very powerful concept called a [matrix](gloss:matrix), that can help us write this in a new way. A matrix is like a spreadsheet table, with cells each containing their own numbers.\n\nThis matrix has 2 rows and 2 columns so it is a 2x2 matrix, but they can be any size.\n\n{.text-center}`§[[cosθ (-sinθ)] [sinθ cosθ]]`\n\n\n**We can rewrite our calculations for the coordinates `x'` and `y'` in the following way:**\n\n{.text-center}`§[[x'] [y']]` = `§[[cosθ (-sinθ)] [sinθ cosθ]]` x `§[[pill(x, \"teal\")] [pill(y, \"purple\")]]` = `§[[(pill(x, \"teal\", \"x\", \"x\") * cosθ - pill(y, \"purple\") * sinθ)] [(pill(x, \"teal\") * sinθ + pill(y, \"purple\") * cosθ)]]`\n\nThis is a [matrix multiplication](gloss:matrix-multiplication), wherein we multiply a matrix times a vector `(x,y)` to get a new vector `(x', y')`. [This matrix](target:rotation-matrix) is the transformation `R_\"θ\"` that we have been looking for! When we change the values within this matrix, we can change the transformation.\n\n{.fixme} Here is another representation:\n\n::: column(width=100)\n\n    table.vector\n      tr: td(target=\"feature pref-A-1\"): b x'\n      tr: td(target=\"feature pref-A-2\"): b y'\n\n::: column(width=20)\n\n    div.op =\n\n::: column(width=200)\n\n    table.matrix\n      tr\n        td(target=\"feature pref-A-1\"): b cosθ\n        td(target=\"feature pref-A-2\"): b -sinθ\n      tr\n        td.name(target=\"pref-A-1 pref-A-2\"): b {.m-green}sinθ\n        td.cell(target=\"pref-A-1\") cosθ\n\n::: column(width=20)\n\n    div.op x\n\n::: column(width=100)\n\n    table.vector\n      tr: td(target=\"feature pref-A-1\"): b x\n      tr: td(target=\"feature pref-A-2\"): b y\n\n::: column(width=20)\n\n    div.op =\n\n::: column(width=400)\n\n    table.vector\n      tr: td\n          div(target=\"x\") cosθ * x\n          div.op +\n          div(target=\"y\") -sinθ * y\n      tr: td\n          div(target=\"x\") sinθ * x\n          div.op +\n          div(target=\"y\") cosθ * y\n\n:::\n\n{.fixme} Activity where student can drag slider to adjust θ and the matrix values are updated (up to two decimal points).\n\n[Hover x](target:x) and [Hover y](target:y)\n\n{.todo} Stronger Connection between matrices and what it means to be a \"transformation\"\n\n[Continue](btn:next)"
    },
    {
      "id": "identity",
      "content": "#### Identity Matrix\n\nWhat if for our matrix, we wrote this instead?\n\n{.text-center} `§[[1 0] [0 1]]`\n\nWhat happens when we apply this transformation to the vector `§[[x] [y]]`?\n\n{.text-center} `§[[1 0] [0 1]]` x `§[[x] [y]]` = `§[[(1*x + 0*y)] [(0*x + 1*y)]]` = `§[[x] [y]]`\n\n{.fixme} The student should fill in these values on their own.\n\nThis transformation [[has no effect on|reverses|negates]] the vector `§[[x] [y]]`."
    },
    {
      "content": "{.text-center}`x' = x` and `y' = y`\n\nFor any vector, the result of the transforation will be the same. This is called the [identity matrix](gloss:identity-matrix), because its product with any 2x1 vector is that identical 2x1 vector. This is much like `1` is the identity function for integer multiplication (`1 x n = n`) and `0` is the identity function for addition (`0 + n = n`).\n\n[Continue](btn:next)"
    },
    {
      "id": "basic-transformations",
      "content": "We have already seen how we can multiply a vector by a 2x2 matrix to rotate that vector about the origin, and we have seen how the identity matrix leaves the vector unchanged. What other transformations exist?\n\n::: tab\n#### Scale\n\nWhat if we adjust the top-left and bottom-right numbers of our transformation matrix?\n\n<table>\n<tr><td>${xscale}{xscale|1.0|-2.0,2.0,0.1}</td><td>0</td></tr>\n<tr><td>0</td><td>${yscale}{yscale|1.0|-2.0,2.0,0.1}</td></tr>\n</table>\n\n    include mixins\n    svg(width=220 height=220)\n      +grid220\n      g.var.scale(:html=\"polygonTransform(xscale, 0, 0, yscale)\")\n\nChanging the [top-left](target:ma) value scales x' along the x-axis.\n\nChanging the [bottom-right](target:md) value scales y' along the y-axis.\n\n{.text-center} `§[[a 0] [0 d]]` x `§[[x] [y]]` = `§[[a*x + 0*y] [0*x + d*y]]` = `§[[ax] [dy]]`\n\n{.fixme} formatting and input.\n\n{.fixme} Add some code that lets us snap to x-big, x-shrink, x-reverse, y-big, y-shrink, y-reverse, etc.\n\n\n::: tab\n#### Reflections\n\nWhat happens when we make the top-left and bottom-right values negative or positive?\n\nAdjust the matrix to see how it changes in the coordinates.\n\n<table>\n<tr><td>${xreflect}{xreflect|1.0|-1,1,2}</td><td>0</td></tr>\n<tr><td>0</td><td>${yreflect}{yreflect|1.0|-1,1,2}</td></tr>\n</table>\n\n    include mixins\n    svg(width=220 height=220)\n      +grid220\n      g.var.scale(:html=\"polygonTransform(xreflect, 0, 0, yreflect)\")\n\n\nFlipping the sign of the [top-left](target:ma) value reflects the transformation across the [[x-axis|y-axis]], and flipping the sign of the [bottom-right](target:ma) value reflects the transformation across the [[y-axis|x-axis]].\n\n{.text-center} `§[[a 0] [0 d]]` x `§[[x] [y]]` = `§[[a*x + 0*y] [0*x + d*y]]` = `§[[ax] [dy]]`\n\n{.fixme} formatting and input.\n\n::: tab\n#### Shear\n\nWhat if we adjust the values in the [top-right](target:mb) and [bottom-left](target:mc) corners of the matrix?\n\nAdjust the matrices to see how they change the transformations.\n\n::: column(width=220)\n\n{.caption} A shear in the x direction.\n\n    include mixins\n    svg(width=220 height=220)\n      +grid220\n      g.var.shear(:html=\"polygonTransform(1, xshear, 0, 1)\")\n\n<table>\n<tr><td>1</td><td>${xshear}{xshear|0.0|-2.0,2.0,0.1}</td></tr>\n<tr><td>0</td><td>1</td></tr>\n</table>\n\n`§[[1 b] [0 1]]` x `§[[x] [y]]` = `§[[(x+by)] [y]]`\n\n{.fixme} formatting and inputs\n\n::: column(width=220)\n\n{.caption} A shear in the y direction.\n\n    include mixins\n    svg(width=220 height=220)\n      +grid220\n      g.var.shear(:html=\"polygonTransform(1, 0, yshear, 1)\")\n\n<table>\n<tr><td>1</td><td>0</td></tr>\n<tr><td>${yshear}{yshear|0.0|-2.0,2.0,0.1}</td><td>1</td></tr>\n</table>\n\n`§[[1 0] [c 1]]` x `§[[x] [y]]` = `§[[x] [cx+y]]`\n\n{.fixme} formatting and inputs\n\n:::\n\nNow add some buttons and code that make it snap to a set of matrix values.\n\nThese types of transformations are called [shear transformations](gloss:shear), because they shear the coordinate system in a perpindicular proportion (?phrasing?).\n\n::: tab\n#### Other\n\nOf course, matrices can have any values in them, and thus can transform in many ways. Play with the values here and see how the transformation is still some combination of the basic transformations.\n\n{.todo} Free reign to do whatever they want. Or just keep this separate, as shown below.\n\n:::"
    },
    {
      "id": "play-with-me",
      "content": "Try adjusting the values in the matrix and see what kind of transformations you can make!\n\n    // try w/ grid on or off, to compare underlying grid w/ transformation\n    - var GRID = 8\n    x-geopad(width=400 x-axis=`-${GRID},${GRID},1` y-axis=`-${GRID},${GRID},1` grid padding=5): svg\n      circle.green.move(name=\"ipoint\" x=\"point(1,0)\" target=\"i\")\n      circle.blue.move(name=\"jpoint\" x=\"point(0,1)\" target=\"j\")\n      circle(name=\"origin\", x=\"point(0,0)\")\n\n\n        // right values for these? Ideally we'd show to \"infinity\", but this might render slowly?\n      - var MINMAX = GRID*2\n      - for (var b=-MINMAX; b <=MINMAX; ++b)\n        // .fabric as in \"fabric of reality\"\n        // can also try class \".grid\" for default grid\n        path.fabric(x=`line(point(${b}*jpoint.x, ${b}*jpoint.y), point(ipoint.x + ${b}*jpoint.x, ipoint.y + ${b}*jpoint.y))`)\n        path.fabric(x=`line(point(${b}*ipoint.x, ${b}*ipoint.y), point(${b}*ipoint.x + jpoint.x, ${b}*ipoint.y + jpoint.y))`)\n\n      - var DRAW_SHIP = false\n      - var SPACESHIP = [[3,0], [0,3], [-3,0], [-3,-3], [0,-1], [3,-3]]\n      if DRAW_SHIP\n        each p,i in SPACESHIP\n          circle.red(name=`s${i}` x=`point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`)\n          path.red(x=`segment(s${i}, s${(i+1)%SPACESHIP.length})`)\n\n      - var DRAW_BOAT = true\n      - var BOAT_RED = [[0.25,-2.5], [6.5,-2.5], [0.25,7]]\n      - var BOAT_PURPLE = [[-0.25,-1.5], [-4.25,-1.5], [-0.25,7]]\n      - var BOAT_ORANGE = [[0,5], [0,7.5], [-3.75,6.25]]\n      - var BOAT_GREEN = [[7, -4], [5,-6], [-5,-6], [-7,-4]]\n      - var BOAT_GRAY = [[-0.25,-4],[0.25,-4],[0.25,7],[-0.25,7]]\n      if DRAW_BOAT\n        - var gray = BOAT_GRAY.map(p => `point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`).join(',')\n        path.fill.gray(x=`polygon(${gray})` label-class=\"gray\")\n        - var red = BOAT_RED.map(p => `point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`).join(',')\n        path.fill.red(x=`polygon(${red})` label-class=\"red\")\n        - var purple = BOAT_PURPLE.map(p => `point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`).join(',')\n        path.fill.purple(x=`polygon(${purple})` label-class=\"purple\")\n        - var orange = BOAT_ORANGE.map(p => `point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`).join(',')\n        path.fill.orange(x=`polygon(${orange})` label-class=\"orange\")\n        - var green = BOAT_GREEN.map(p => `point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`).join(',')\n        path.fill.green(x=`polygon(${green})` label-class=\"green\")\n\n\n        // each p,i in BOAT_GRAY\n          // circle.gray(name=`bgy${i}` x=`point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`)\n          // path.gray(x=`segment(bgy${i}, bgy${(i+1)%BOAT_GRAY.length})`)\n\n        // each p,i in BOAT_RED\n          // circle.red(name=`brd${i}` x=`point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`)\n          // path.red(x=`segment(brd${i}, brd${(i+1)%BOAT_RED.length})`)\n        // each p,i in BOAT_PURPLE\n          // circle.purple(name=`bpp${i}` x=`point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`)\n          // path.purple(x=`segment(bpp${i}, bpp${(i+1)%BOAT_PURPLE.length})`)\n        // each p,i in BOAT_ORANGE\n          // circle.orange(name=`bor${i}` x=`point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`)\n          // path.orange(x=`segment(bor${i}, bor${(i+1)%BOAT_ORANGE.length})`)\n        each p,i in BOAT_GREEN\n          circle.green(name=`bgn${i}` x=`point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`)\n          // path.green(x=`segment(bgn${i}, bgn${(i+1)%BOAT_GREEN.length})`)\n\n      path.green(x=\"segment(point(0,0),ipoint)\", label=\"i\", target=\"i\")\n      path.blue(x=\"segment(point(0,0),jpoint)\", label=\"j\", target=\"j\")\n\n\n\nHere we display the [i](target:i) and [j](target:j) unit vectors.\nInside the matrix we have i = (${ipoint.x}, ${ipoint.y}) and j = (${jpoint.x}, ${jpoint.y})\n\nChoose one of these buttons to snap to different transformations.\n\n    .button IDENTITY\n    .button SHEAR\n    .button SCALE\n    .button ROTATE\n    .button LINE\n\n[Continue](btn:next)"
    },
    {
      "id": "gpu",
      "content": "{.todo} How does this relate to video games?\n\nVideo games can manipulate and millions of shapes per second with use of a __Graphical Processing Unit__ (GPU). GPUs are specially designed to perform many matrix multiplications at once.\n\n[Continue](btn:next)"
    },
    {
      "id": "translate",
      "content": "You may have noticed we have not discussed one type of transformation. We cannot move our shapes through space! To transform our shapes so they are centered anywhere but the origin, we need a special kind of matrix called a __Translation Matrix__.\n\n{.text-center} `§[[1 0 dx] [0 1 dy] [0 0 1]]`\n\nWe add an extra row and column to our 2x2 matrix, and we add an extra row to our vector (which will not change).\n\nThe factor [dx](target:dx) will be multiplied by [1](target:bottom1) and added to the final [x'](target:xprime) value.\nThe factor [dy](target:dy) will be multiplied by [1](target:bottom1) and added to the final [y'](target:xprime) value.\n\n{.text-center} `§[[1 0 dx] [0 1 dy] [0 0 1]]` x `§[[x] [y] [1]]` = `§[[(x + dx)] [(y + dy)] [1]]`\n\n{.fixme} Focus effects.\n\n{.todo} Possibly an interactive like ncase?\n\n[Continue](btn:next)"
    },
    {
      "id": "three-d",
      "content": "Matrices do not have to represent transformations in 2 dimensions. They can also exist in 3 or higher dimensions.\n\nThis is the identity matrix for three dimensions\n\n{.text-center} `§[[1 0 0] [0 1 0] [0 0 1]]` x `§[[x] [y] [z]]` = `§[[x] [y] [z]]`\n\n{.todo} An interaction with a 3d transformation.\n\n[Continue](btn:next)"
    },
    {
      "id": "multiplication",
      "section": "arithmetic",
      "sectionStatus": "dev",
      "content": "Let's mess around with the Mathigon Logo!\n\n    include mixins\n    svg(width=220 height=220)\n      +grid220\n      g.var.mathigon.red(:html=\"polygonTransform(m1a, m1b, m1c, m1d, 'red')\")\n      g.var.mathigon.green(:html=\"polygonTransform(m2a, m2b, m2c, m2d, 'green')\")\n      g.var.mathigon.yellow(:html=\"polygonTransform(m3a, m3b, m3c, m3d, 'yellow')\")\n      g.var.mathigon.blue(:html=\"polygonTransform(m4a, m4b, m4c, m4d, 'blue')\")\n\n\n<table>\n  <tr>\n    <td>\n      <table>\n        <tr><td>${m1a}{m1a|1|-2.0,2.0,0.1}</td><td>${m1b}{m1b|0.0|-2.0,2.0,0.1}</td></tr>\n        <tr><td>${m1c}{m1c|0.0|-2.0,2.0,0.1}</td><td>${m1d}{m1d|1|-2.0,2.0,0.1}</td></tr>\n      </table>\n    </td>\n    <td>\n      <table class=\"green\">\n        <tr><td>${m2a}{m2a|1|-2.0,2.0,0.1}</td><td>${m2b}{m2b|0.0|-2.0,2.0,0.1}</td></tr>\n        <tr><td>${m2c}{m2c|0.0|-2.0,2.0,0.1}</td><td>${m2d}{m2d|1|-2.0,2.0,0.1}</td></tr>\n      </table>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <table class=\"yellow\">\n        <tr><td>${m3a}{m3a|1|-2.0,2.0,0.1}</td><td>${m3b}{m3b|0.0|-2.0,2.0,0.1}</td></tr>\n        <tr><td>${m3c}{m3c|0.0|-2.0,2.0,0.1}</td><td>${m3d}{m3d|1|-2.0,2.0,0.1}</td></tr>\n      </table>\n    </td>\n    <td>\n      <table class=\"blue\">\n        <tr><td>${m4a}{m4a|1|-2.0,2.0,0.1}</td><td>${m4b}{m4b|0.0|-2.0,2.0,0.1}</td></tr>\n        <tr><td>${m4c}{m4c|0.0|-2.0,2.0,0.1}</td><td>${m4d}{m4d|1|-2.0,2.0,0.1}</td></tr>\n      </table>\n    </td>\n  </tr>\n</table>\n\n{.todo} Possible Activities: switch Orange and Green, reflect/scale the whole thing, make shapes.\n\n\n----------------------------------------------------------------------------------------------------\n\n\n## Matrix Arithmetic\n\n\n### Matrix Multiplication\n\nWe learned in the last chapter that matrices can represent linear transformations. However, there are many other things that matrices can represent! Also, matrices do not always have to be [square matrices](gloss:square-matrix), but can have many different dimensional values. Let's explore this with a hypothetical scenario.\n\nFour friends are in a new city and they're looking for a restaurant to eat at together. What are some features they might look for in a restaurant?\n\n- Outdoor seating\n- Vegetarian food\n- Low price\n- Spicy food\n- Kid's menu\n- Good wine selection\n\nEach friend has preferences for how important these things are, which we can quantify with a value 0 (not important) to 4 (very important). If we create a table with friends on the left-most column and restaurant features across the top row, we can fill in the cells of the table with each friend's preference for that feature.\n\n    figure: img(src=\"images/proto-2/matrix-1-frn-fea.png\")\n\nWhat we have built here is a 4 by 2 matrix. We have four rows to represent the four [[friends|features|restaurants]], and two columns to represent the two [[features|friends|restaurants]]."
    },
    {
      "content": "The friends have found three restaurants within walking distance, and they have pulled up the websites for each. Lucky for them, each restaurants' website has listed the quality of the features that the friends have quantified: availability of outdoor seating, and vegetarian options.\n\n    figure: img(src=\"images/proto-2/matrix-1-fea-res.png\")\n\nThis is a 2 by 3 matrix. There are two rows to represent the two [[features|restaurants]] and three rows, one to represent each [[restaurant|feature]]."
    },
    {
      "content": "{.fixme} Begin side-by-side column display.\n\nWhat we would like to do is somehow synthesize these two tables of information so we can get a sense of how much each person might like each restaurant. We can use a procedure called [matrix multiplication](gloss:matrix-multiplication) to do this. The result will be a *new* table with the friends as [[rows]] and the restaurants as [[columns]].\n\n    figure: img(src=\"images/proto-2/matrix-1-frn-res-empty.png\")\n\nHow should we fill out this table? The value of each cell should represent how much each person might like each restaurant.\n\nFor example, the first cell will represent how much Alice might like [[Gauss Grill|Laplace Lounge]].\n\n    figure: img(src=\"images/proto-2/mult-alice-gauss.png\")\n\nAlice has a preference of 1 for Outdoor Seating, and Gauss Grill has a value of 3 for Outdoor Seating, and we multiply these to get [[3]].\n\nAlice has a preference of 4 for Vegetarian food, but Gauss Grill only has a value of 1 for Vegetarian food, and we mutiply these to get [[4]].\n\nWe sum together all the products to get [[7]], which we can write in the first cell.\n\n    figure: img(src=\"images/proto-2/mult-bob-laplace.png\")\n\nHow much might Bob like Laplace Lounge?\n[[3]]*[[1]] + [[0]]*[[4]] = [[3]].\n\nWhen we finish our process, we get a matrix of 4 rows and 3 columns. This makes sense! We had 4 people and 3 restaurants, so we will end up with a row for each person and a column for each restaurant.\n\n    figure: img(src=\"images/proto-2/matrix-1-frn-res-full.png\")\n\nWe can then sum the values in each column to figure out which restaurant is most popular (this is left as an exercise for the reader).\n\n{.fixme} End side-by-side column display.\n\nWhat we have just done is [matrix multiplication](gloss:matrix-multiplication).\n\n{.fixme} Align these.\n\n    figure: img(src=\"images/proto-2/matrix-1-frn-fea.png\" width=100)\n    div x\n    figure: img(src=\"images/proto-2/matrix-1-fea-res.png\" width=200)\n    div =\n    figure: img(src=\"images/proto-2/matrix-1-frn-res-full.png\" width=200)"
    },
    {
      "id": "formal-definition",
      "content": "#### Formal definition of Matrix Multiplication\n\nThe formal defintion for matrix multiplication is as follows:\n\n{.text-center} Given matrix `A` with dimensions `[r_\"A\", c_\"A\"]`\nand matrix `B` with dimensions `[r_\"B\", c_\"B\"]`\n\n{.text-center} The value of the cell `x_\"ij\"` in `A × B` is:\n\n{.text-center} `a_\"i1\"b_\"1j\"` + ... `a_\"iN\"b_\"Nj\"`\n\n{.text-center} where `N = c_\"A\" = r_\"B\"`.\n\n\nNotice that, for this algorithm to work, the number of [[columns]] in the first matrix has to be equal to the number of [[rows]] in the second matrix.\n\nFor example, if in our restaurant example, each friend had a preference level for spicy food, our preference matrix would be `4x3`.\n\n    figure: img(src=\"images/proto-2/matrix-1-extra.png\" width=200)\n\nWe are now attempting to multiply a `4x3` matrix by a `2x3` matrix, but we don't have any information about which restaurants have spicy food! So we __cannot__ multiply the two matrices.\n\n    figure: img(src=\"images/proto-2/matrix-1-extra-mult.png\" width=200)\n\n{.fixme} Could end section with a simple checkmark multiple choice, for which multiplications are possible."
    },
    {
      "id": "matrix-factorisation",
      "content": "#### Matrix Factorisation\n\nThis type of matrix is used in all sorts of online recommender systems. Movies can be categorized by their genres like Comedy, Action, Romance, or Horror. Songs can be categorized into genres with ever-increasing specificity like Rock, Classical, Pop, Rap, Electro-Funk, Indie Folk, or Norwegian Black Metal. When you watch a movie on Netflix, or listen to a song on Spotify, there's likely a very large matrix somewhere, remembering your taste!\n\nHowever, this process is slightly different from what we did above. The company running the streaming service *doesn't know* what its users' tastes are. It does know what movies they have watched, and whether they liked them or not. From this information they attempt to figure out each user's possible genre preferences using a process called __matrix factorisation__. Much like in [integer factorisation](gloss:factorisation), where an integer can be written as a product of prime numbers, matrix factorisation is about working backwards from an incomplete product matrix to find possible preference matrices. This algorithm is much more complex than integer factorisation, so we need complex machine leaerning algorithms to perform it.\n\n    figure: img(src=\"images/proto-2/factorisation.png\")\n\n[Continue](btn:next)"
    },
    {
      "id": "multiply-transformations",
      "content": "### Multiplying Linear Transformations\n\nWe have now learned two different ways to think about matrix multiplication. In the first chapter we learned that multiplying a 2x2 matrix by a 2x1 vector, can be thought of as a linear transformation. And we just learned to the detailed rules for how to multiply matrices of any size, like a preference matrix. Let's go back to thinking about matrices as linear transformations.\n\nRecall the 2x2 matrix representing the rotation of 90º about the origin. Let's call it `R_\"90\"`.\n\n    include mixins\n    img(src=\"images/proto-2/rotate-90-m.png\" width=100)\n    +ij([0,1], [-1,0], \"Rotate 90º\")\n\nWhat if we multiply this matrix by the 2x2 matrix for rotation of 180º, `R_\"180\"`?\n\n    include mixins\n    img(src=\"images/proto-2/rotate-180-m.png\")\n    +ij([-1,0], [0,-1], \"Rotate 180º\")\n\nThe resulting matrix is this:\n\n    include mixins\n    img(src=\"images/proto-2/rotate-270-m.png\")\n    +ij([0,-1], [1,0], \"Rotate 270º\")\n\nThis matrix is the linear transformation for a [[rotation of 270º|identity matrix|rotation of 90º]]."
    },
    {
      "content": "That's right,\n\n`R_\"90\"` x `R_\"180\"` = `R_\"270\"`\n\nIn this case, multiplying two rotation matrices give us a *new* rotation matrix with an angle equal to the sum of the first two angles. A more general way to say this is that when we multiplied two transformation matrices, the resulting transformation matrix has the effect applying BOTH of the original two matrices in succession.\n\nThis works for all rotation values:\n\n- `R_\"90\"` x `R_\"90\"` = `R_\"80\"`\n- `R_\"180\"` x `R_\"180\"` = `R_\"360\"` = `I`\n\n[Continue](btn:next)"
    },
    {
      "id": "transforms-calculator",
      "goals": "calculate",
      "content": "What about other types of transformations?\n\n{.fixme} Perhaps let them draw points (like a spaceship), and then the points are transformed by each transformation?\n{.fixme} Should be displayed horizontally, with their matrices across the bottom.\n\n    include mixins\n    .calculator\n      .display\n        .mat\n          x-geopad(width=150 x-axis=\"-3,3,1\" y-axis=\"-3,3,1\" grid padding=5): svg\n        .mat.operator x\n        .mat\n          x-geopad(width=150 x-axis=\"-3,3,1\" y-axis=\"-3,3,1\" grid padding=5): svg\n        .mat.operator =\n        .mat\n          x-geopad(width=150 x-axis=\"-3,3,1\" y-axis=\"-3,3,1\" grid padding=5): svg\n        .button.clear CLEAR\n        .button.calc CALCULATE\n      .cubes\n        +ij([1,0], [0,1], \"Identity\")\n        +ij([0,1], [-1,0], \"Rotate 90º\")\n        +ij([-1,0], [0,-1], \"Rotate 180º\")\n        +ij([0,-1], [1,0], \"Rotate 270º\")\n\n        +ij([-1,0], [0,1], \"Reflect x=0\")\n        +ij([0,1], [1,0], \"Reflect y=x\")\n        +ij([1,0], [0,-1], \"Reflect y=0\")\n        +ij([0,-1], [-1,0], \"Reflect y=-x\")\n\n        +ij([1,1], [0,1], \"Shear x 1\")\n        +ij([1,-1], [0,1], \"Shear x -1\")\n        +ij([1,0], [1,1], \"Shear y 1\")\n        +ij([1,0], [-1,1], \"Shear y -1\")\n\n        +ij([2,0], [0,2], \"Scale by 2\")\n        +ij([0.5,0], [0, 0.5], \"Scale by 1/2\")\n        +ij([2,0], [0,1], \"Scale x by 2\")\n        +ij([1,0], [0,1/2], \"Scale y by 1/2\")"
    },
    {
      "id": "matrix-addition",
      "content": "### Matrix Addition\n\nMatrices can also be added. Matrix addition does not happen very often, but it is very simple to learn.\n\nWe write matrix arithmetic just as you might expect:\n\n`A + B`\n\n* Two matrices can be added only if they have the same dimensions.\n* The resulting matrix will be the same dimension as the matrices added.\n* Each value in location (i,j) of the resulting matrix will be the sum of the values at (i,j) in the other two matrices.\n\nAdd these two matrices!\n\n<div class=\"addition\">\n  <table class=\"add\">\n    <tr>\n      <td target=\"a\">[1](target:a)</td>\n      <td target=\"b\">[2](target:b)</td>\n    </tr>\n    <tr>\n      <td target=\"c\">[3](target:c)</td>\n      <td target=\"d\">[4](target:d)</td>\n    </tr>\n  </table>\n\n  <div class=\"add\">+</div>\n\n  <table class=\"add\">\n    <tr>\n      <td target=\"a\">[9](target:a)</td>\n      <td target=\"b\">[8](target:b)</td>\n    </tr>\n    <tr>\n      <td target=\"c\">[7](target:c)</td>\n      <td target=\"d\">[6](target:d)</td>\n    </tr>\n  </table>\n\n  <div class=\"add\">=</div>\n\n  <table class=\"add\">\n    <tr>\n      <td target=\"a\">\n        <strong class=\"pill step-target\" tabindex=\"0\" data-to=\"a\">[[10]]</strong>\n      </td>\n      <td target=\"b\">\n        <strong class=\"pill step-target\" tabindex=\"0\" data-to=\"b\">[[10]]</strong>\n      </td>\n    </tr>\n    <tr>\n      <td target=\"c\">\n        <strong class=\"pill step-target\" tabindex=\"0\" data-to=\"c\">[[10]]</strong>\n      </td>\n      <td target=\"d\">\n        <strong class=\"pill step-target\" tabindex=\"0\" data-to=\"d\">[[10]]</strong>\n      </td>\n    </tr>\n  </table>\n</div>\n\nGreat.\n\nThis code could be a lot simpler! And why is this not going below the tables?"
    },
    {
      "id": "scalar-multiplication",
      "content": "### Scalar Multiplication\n\nAnother operation we can perform with a matrix is __scalar multiplication__. A __scalar__ is what we call a real number in matrix and vector arithmetic.\n\nWe write scalar multiplication as\n\n`sA`\n\nScalar multiplication is as simple as multiplying every cell in a matrix `A` times a scalar `s`.\n\n<div class=\"scalar\">\n  <div class=\"scm s\">2</div>\n\n  <table class=\"scm\">\n    <tr>\n      <td target=\"a\">[3](target:a)</td>\n      <td target=\"b\">[1](target:b)</td>\n    </tr>\n    <tr>\n      <td target=\"c\">[-4](target:c)</td>\n      <td target=\"d\">[0](target:d)</td>\n    </tr>\n  </table>\n\n  <div class=\"scm\">=</div>\n\n  <table class=\"scm\">\n    <tr>\n      <td target=\"a\">\n        <strong class=\"pill step-target\" tabindex=\"0\" data-to=\"a\">[[6]]</strong>\n      </td>\n      <td target=\"b\">\n        <strong class=\"pill step-target\" tabindex=\"0\" data-to=\"b\">[[2]]</strong>\n      </td>\n    </tr>\n    <tr>\n      <td target=\"c\">\n        <strong class=\"pill step-target\" tabindex=\"0\" data-to=\"c\">[[-8]]</strong>\n      </td>\n      <td target=\"d\">\n        <strong class=\"pill step-target\" tabindex=\"0\" data-to=\"d\">[[0]]</strong>\n      </td>\n    </tr>\n  </table>\n</div>\n\nNote that while it is possible to add two matrices, and to multiply a matrix by a scalar, the operation of adding a scalar to a matrix is __not defined__."
    },
    {
      "id": "determinants",
      "section": "determinants",
      "sectionStatus": "dev",
      "content": "### Properties of Matrix Arithmetic\n\nRecall operators like addition and multiplication, and how it's useful to think about their properties. Commutative, distributive, and associative properties.\n\n::: tab\n#### Associative\n\nIs matrix multiplication [associative](gloss:associative)?. If it is, then the equation below will be true.\n\n`Ax(BxC) = (AxB)xC`\n\nA good first question to ask is: will the dimensions of the matrices allow this?\n\nIf `Ax(BxC)` is possible, then\n\n`columns_\"B\" = rows_\"C\"`\n\n`BxC` will have `rows_\"B\"` number of rows, and will be equal to `columns_\"A\"`. This means that when attempting `(AxB)xC`, we know we can perform `AxB`. `AxB` will then have `columns_\"B\"` columns, so we can multiply it by C.\n\nWe know we can perform this multiplication based on the dimensions, but will we get the same result? Recall from our section on multiplication that it can be thought of as successive linear transformations.\n\nIt turns out that as long as we keep the ordering of the matrices, we will get the same result. Whether we do BxC first or AxB first, it does not matter.\n\nMatrix multiplication __is associative__.\n\n::: tab\n#### Commutative\n\nIs matrix multiplication [commutative](gloss:commutative)?. If it is, then the equation below will be true.\n\n`AxB = BxA`\n\nRecall that when we multiply two matrices, the number of columns of the first must match the number of rows of the second. This means that if we can multiply `AxB`, `columns_\"A\" = rows_\"B\"`, but it is not necessarily true that `rows_\"A\" = columns_\"B\"`. Therefore, it does not follow that we can multiply `BxA`, and matrix multiplication __is not commutative__.\n\nWhat if both matrices are square matrices? We can then perform both `AxB` and `BxA`, however we do not know if they will be equal.\n\nIf we think of the matrices as transformations, we can imagine scenarios wherein applying two different transformations will be different depending on which direction you multiply them.\n\nIf we perform a 90º Rotation, and then a reflection across the x-axis, the final transformation will look like this:\n\n    include mixins\n    .cubes\n      +ij([0,1], [-1,0], \"Rotate 90º\")\n      .cube.op x\n      +ij([-1,0], [0,1], \"Reflect x=0\")\n      .cube.op =\n      +ij([0,1], [1,0], \"Reflect y=x\")\n\nHowever, if we reverse the order of the transformations, the final transformation will look like this.\n\n    include mixins\n    .cubes\n      +ij([-1,0], [0,1], \"Reflect x=0\")\n      .cube.op x\n      +ij([0,1], [-1,0], \"Rotate 90º\")\n      .cube.op =\n      +ij([0,-1], [1,0], \"Reflect y=-x\")\n\nThere are many more examples of how matrix multiplication does not meet the commutative property, and we encourage you to experiment!\n\n\n::: tab\n#### Distributive\n\nIs matrix multiplication [distributive](gloss:distributive) over matrix addition?. If it is, then the equation below will be true.\n\n`Ax(B+C) = AxB + AxC`\n\n{.todo} Could demonstrate this by adding basis vectors and applying transformations to them. Or could somehow leave it as an exercise for the reader.\n\n:::\n\n\n----------------------------------------------------------------------------------------------------\n\n\n## Determinants\n\n\nWatch the area change.\n\n    - var GRID = 4\n    x-geopad(width=400 x-axis=`-${GRID},${GRID},1` y-axis=`-${GRID},${GRID},1` grid padding=5): svg\n      circle.green.move(name=\"ipoint\" x=\"point(1,0)\" target=\"i\")\n      circle.blue.move(name=\"jpoint\" x=\"point(0,1)\" target=\"j\")\n      circle(name=\"origin\", x=\"point(0,0)\")\n\n\n        // right values for these? Ideally we'd show to \"infinity\", but this might render slowly?\n      - var MINMAX = GRID*2\n      - for (var b=-MINMAX; b <=MINMAX; ++b)\n        // .fabric as in \"fabric of reality\"\n        // can also try class \".grid\" for default grid\n        path.fabric(x=`line(point(${b}*jpoint.x, ${b}*jpoint.y), point(ipoint.x + ${b}*jpoint.x, ipoint.y + ${b}*jpoint.y))`)\n        path.fabric(x=`line(point(${b}*ipoint.x, ${b}*ipoint.y), point(${b}*ipoint.x + jpoint.x, ${b}*ipoint.y + jpoint.y))`)\n\n      - var DETERMINANT = [[0,0], [1,0], [1,1], [0,1]]\n      - var determinant = DETERMINANT.map(p => `point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`).join(',')\n      path.fill.light.purple(x=`polygon(${determinant})` label-class=\"purple\")\n\n      path.green(x=\"segment(point(0,0),ipoint)\", label=\"i\", target=\"i\")\n      path.blue(x=\"segment(point(0,0),jpoint)\", label=\"j\", target=\"j\")\n\nInside the matrix we have i = (${ipoint.x}, ${ipoint.y}) and j = (${jpoint.x}, ${jpoint.y})\n\nThe deterimant is ${determinant}\n\nChoose one of these buttons.\n\n    .button IDENTITY\n    .button SHEAR\n    .button SCALE\n    .button ROTATE\n    .button LINE"
    },
    {
      "id": "examples",
      "content": "{.todo} Demonstrate how basic transformations effect the determinant\n{.todo} Demonstrate possible values: less than 1, greater than 1, negative, zero"
    },
    {
      "id": "zero-det",
      "content": "{.todo} Matrices can have a determinant of zero. What does this mean?"
    },
    {
      "id": "det-formula",
      "content": "The formula for the determinant of a 2x2 matrix is:\n\n```ad - bc```\n\nmatrix:\n\n[a](target:a), [b](target:b)\n\n[c](target:c), [d](target:d)\n\nThe area [determinant](target:determinant) is equal to the area [ad](target:ad) minus the area [bc](target:bc).\n\nLet's see why this is true geometrically.\n\n    - var GRID = 1.5\n    x-geopad(width=400 x-axis=`-${GRID},${GRID},1` y-axis=`-${GRID},${GRID},1` grid padding=5): svg\n      circle.green.move(name=\"ipoint\" x=\"point(1,0)\" target=\"i\")\n      circle.blue.move(name=\"jpoint\" x=\"point(0,1)\" target=\"j\")\n      circle(name=\"origin\", x=\"point(0,0)\")\n\n      - var MINMAX = GRID*2\n      - for (var b=-MINMAX; b <=MINMAX; ++b)\n        // .fabric as in \"fabric of reality\"\n        // can also try class \".grid\" for default grid\n        path.fabric(x=`line(point(${b}*jpoint.x, ${b}*jpoint.y), point(ipoint.x + ${b}*jpoint.x, ipoint.y + ${b}*jpoint.y))`)\n        path.fabric(x=`line(point(${b}*ipoint.x, ${b}*ipoint.y), point(${b}*ipoint.x + jpoint.x, ${b}*ipoint.y + jpoint.y))`)\n\n      - var DETERMINANT = [[0,0], [1,0], [1,1], [0,1]]\n      - var determinant = DETERMINANT.map(p => `point(${p[0]}*ipoint.x+${p[1]}*jpoint.x,${p[0]}*ipoint.y+${p[1]}*jpoint.y)`).join(',')\n      path.fill.light.purple(x=`polygon(${determinant})` label-class=\"purple\", target=\"determinant\")\n\n      path.green(x=\"segment(point(0,0),ipoint)\", label=\"i\", target=\"i\")\n      path.blue(x=\"segment(point(0,0),jpoint)\", label=\"j\", target=\"j\")\n\n      path.red(x=\"segment(point(0,0), point(ipoint.x,0))\", label=\"a\", target=\"a\")\n      path.red(x=\"segment(point(0,0), point(0,jpoint.y))\", label=\"d\", target=\"d\")\n\n      path.red(x=\"segment(point(0,0), point(0,ipoint.y))\", label=\"c\", target=\"c\")\n      path.red(x=\"segment(point(0,0), point(jpoint.x,0))\", label=\"b\", target=\"b\")\n\n      path.fill.light.teal(x=\"polygon(point(0,0),point(ipoint.x,0),point(ipoint.x,jpoint.y),point(0,jpoint.y))\" target=\"ad\")\n\n      path.fill.light.lime(x=\"polygon(point(0,0),point(jpoint.x,0),point(jpoint.x,ipoint.y),point(0,ipoint.y))\" target=\"bc\")\n\n\n{.fixme} The shapes are blocking each other when targeted.\n\n{.fixme} Could do an animation that shows how the triangles fit together, like in Pythagoras."
    },
    {
      "id": "nonsquare",
      "section": "eigenvalues",
      "sectionStatus": "dev",
      "content": "{.todo} Determinants only exist for square matrices.\n\n\n----------------------------------------------------------------------------------------------------\n\n\n## Matrix Inverses\n\n\n{.todo} COMING SOON\n\n\n----------------------------------------------------------------------------------------------------\n\n\n## Cramer’s Rule and Gaussian Elimination\n\n\n{.todo} COMING SOON\n\n\n----------------------------------------------------------------------------------------------------\n\n\n## Eigenvalues and Eigenvectors\n\n\n{.todo} COMING SOON"
    }
  ],
  "title": "Matrices"
}