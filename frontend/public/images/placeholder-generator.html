<!DOCTYPE html>
<html>
<head>
  <title>Image Placeholder Generator</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    canvas { border: 1px solid #ddd; margin: 10px 0; }
    .controls { margin-bottom: 20px; }
    label { display: block; margin-bottom: 5px; }
    input, select, button { margin-bottom: 10px; padding: 5px; }
    .button-row { display: flex; gap: 10px; }
  </style>
</head>
<body>
  <h1>Image Placeholder Generator</h1>
  
  <div class="controls">
    <label for="width">Width:</label>
    <input type="number" id="width" value="400" min="50" max="1200">
    
    <label for="height">Height:</label>
    <input type="number" id="height" value="300" min="50" max="1200">
    
    <label for="bgColor">Background Color:</label>
    <input type="color" id="bgColor" value="#f0f0f0">
    
    <label for="text">Text:</label>
    <input type="text" id="text" value="Course Image Placeholder">
    
    <label for="textColor">Text Color:</label>
    <input type="color" id="textColor" value="#333333">
    
    <label for="imageType">Image Type:</label>
    <select id="imageType">
      <option value="geocentric">Geocentric</option>
      <option value="circle-properties">Circle Properties</option>
      <option value="pi-spiral">Pi Spiral</option>
      <option value="flower">Flower</option>
      <option value="earth">Earth</option>
      <option value="ripples">Ripples</option>
      <option value="circle-area">Circle Area</option>
      <option value="archimedes">Archimedes</option>
      <option value="konigsberg">Königsberg Bridges</option>
      <option value="euler-graph">Euler Graph</option>
      <option value="graph-applications">Graph Applications</option>
    </select>
  </div>
  
  <div class="button-row">
    <button id="generate">Generate Image</button>
    <button id="download">Download Image</button>
  </div>
  
  <canvas id="canvas"></canvas>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let currentImageData;
    
    function generateImage() {
      const width = parseInt(document.getElementById('width').value);
      const height = parseInt(document.getElementById('height').value);
      const bgColor = document.getElementById('bgColor').value;
      const text = document.getElementById('text').value;
      const textColor = document.getElementById('textColor').value;
      const imageType = document.getElementById('imageType').value;
      
      // Set canvas size
      canvas.width = width;
      canvas.height = height;
      
      // Fill background
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, width, height);
      
      // Add specific elements based on image type
      switch(imageType) {
        case 'geocentric':
          // Draw circles representing planets
          drawCirclesPattern(width, height);
          break;
        case 'circle-properties':
          drawCircleProperties(width, height);
          break;
        case 'pi-spiral':
          drawPiSpiral(width, height);
          break;
        case 'flower':
          drawFlower(width, height);
          break;
        case 'earth':
          drawEarth(width, height);
          break;
        case 'ripples':
          drawRipples(width, height);
          break;
        case 'circle-area':
          drawCircleArea(width, height);
          break;
        case 'archimedes':
          drawArchimedes(width, height);
          break;
        case 'konigsberg':
          drawKonigsberg(width, height);
          break;
        case 'euler-graph':
          drawEulerGraph(width, height);
          break;
        case 'graph-applications':
          drawGraphApplications(width, height);
          break;
      }
      
      // Add text
      ctx.fillStyle = textColor;
      ctx.font = `${Math.max(16, Math.floor(width / 20))}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, width / 2, height / 2);
      
      currentImageData = canvas.toDataURL('image/jpeg');
    }
    
    function drawCirclesPattern(width, height) {
      // Draw concentric circles
      const center = { x: width / 2, y: height / 2 };
      const maxRadius = Math.min(width, height) * 0.4;
      
      for (let i = 0; i < 5; i++) {
        const radius = maxRadius * (1 - i * 0.2);
        ctx.beginPath();
        ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(33, 150, 243, ${0.5 - i * 0.1})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw a "planet" on each circle
        const angle = Math.PI * 2 * (i / 5);
        const planetX = center.x + radius * Math.cos(angle);
        const planetY = center.y + radius * Math.sin(angle);
        
        ctx.beginPath();
        ctx.arc(planetX, planetY, 10, 0, Math.PI * 2);
        ctx.fillStyle = ['#FFC107', '#FF5722', '#4CAF50', '#9C27B0', '#F44336'][i];
        ctx.fill();
      }
      
      // Draw center "sun"
      ctx.beginPath();
      ctx.arc(center.x, center.y, 20, 0, Math.PI * 2);
      ctx.fillStyle = '#FFD700';
      ctx.fill();
    }
    
    function drawCircleProperties(width, height) {
      const center = { x: width / 2, y: height / 2 };
      const radius = Math.min(width, height) * 0.35;
      
      // Draw circle
      ctx.beginPath();
      ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
      ctx.strokeStyle = '#2196F3';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Draw radius
      ctx.beginPath();
      ctx.moveTo(center.x, center.y);
      ctx.lineTo(center.x + radius, center.y);
      ctx.strokeStyle = '#F44336';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Draw diameter
      ctx.beginPath();
      ctx.moveTo(center.x - radius, center.y);
      ctx.lineTo(center.x + radius, center.y);
      ctx.strokeStyle = '#4CAF50';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Labels
      ctx.font = '16px Arial';
      ctx.fillStyle = '#F44336';
      ctx.fillText('r', center.x + radius / 2, center.y - 15);
      
      ctx.fillStyle = '#4CAF50';
      ctx.fillText('d', center.x, center.y + 25);
      
      ctx.fillStyle = '#2196F3';
      ctx.fillText('C = 2πr', center.x, center.y - radius - 15);
    }
    
    function drawPiSpiral(width, height) {
      const center = { x: width / 2, y: height / 2 };
      const maxRadius = Math.min(width, height) * 0.4;
      
      // Draw spiral
      ctx.beginPath();
      let angle = 0;
      let radius = 5;
      ctx.moveTo(center.x, center.y);
      
      while (radius < maxRadius) {
        angle += 0.1;
        radius = 5 + angle * 3;
        const x = center.x + radius * Math.cos(angle);
        const y = center.y + radius * Math.sin(angle);
        ctx.lineTo(x, y);
      }
      
      ctx.strokeStyle = '#9C27B0';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Add Pi digits along the spiral
      const piDigits = '3.1415926535897932384626433832795';
      for (let i = 0; i < piDigits.length; i++) {
        const anglePos = i * 0.3;
        const radiusPos = 5 + anglePos * 3;
        const x = center.x + radiusPos * Math.cos(anglePos);
        const y = center.y + radiusPos * Math.sin(anglePos);
        
        ctx.fillStyle = '#333';
        ctx.font = '14px monospace';
        ctx.fillText(piDigits[i], x, y);
      }
    }
    
    function drawFlower(width, height) {
      const center = { x: width / 2, y: height / 2 };
      const radius = Math.min(width, height) * 0.3;
      
      // Draw petals
      for (let i = 0; i < 8; i++) {
        const angle = Math.PI * 2 * (i / 8);
        const petalX = center.x + radius * 0.7 * Math.cos(angle);
        const petalY = center.y + radius * 0.7 * Math.sin(angle);
        
        ctx.beginPath();
        ctx.ellipse(petalX, petalY, radius * 0.4, radius * 0.2, angle, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 193, 7, 0.7)';
        ctx.fill();
      }
      
      // Draw center
      ctx.beginPath();
      ctx.arc(center.x, center.y, radius * 0.3, 0, Math.PI * 2);
      ctx.fillStyle = '#FF5722';
      ctx.fill();
    }
    
    function drawEarth(width, height) {
      const center = { x: width / 2, y: height / 2 };
      const radius = Math.min(width, height) * 0.35;
      
      // Draw Earth
      ctx.beginPath();
      ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      // Draw continents (simplified)
      ctx.fillStyle = '#4CAF50';
      
      // North America
      ctx.beginPath();
      ctx.ellipse(center.x - radius * 0.5, center.y - radius * 0.3, radius * 0.3, radius * 0.2, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // South America
      ctx.beginPath();
      ctx.ellipse(center.x - radius * 0.2, center.y + radius * 0.3, radius * 0.2, radius * 0.3, Math.PI / 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Europe/Africa
      ctx.beginPath();
      ctx.ellipse(center.x + radius * 0.3, center.y, radius * 0.15, radius * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Asia/Australia
      ctx.beginPath();
      ctx.ellipse(center.x + radius * 0.4, center.y - radius * 0.1, radius * 0.3, radius * 0.2, Math.PI / 3, 0, Math.PI * 2);
      ctx.fill();
    }
    
    function drawRipples(width, height) {
      const center = { x: width / 2, y: height / 2 };
      
      // Draw ripples
      for (let i = 1; i <= 5; i++) {
        const radius = Math.min(width, height) * 0.1 * i;
        
        ctx.beginPath();
        ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(33, 150, 243, ${1 - i * 0.15})`;
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      
      // Draw water surface
      ctx.fillStyle = 'rgba(33, 150, 243, 0.1)';
      ctx.fillRect(0, 0, width, height);
    }
    
    function drawCircleArea(width, height) {
      const center = { x: width / 2, y: height / 2 };
      const radius = Math.min(width, height) * 0.3;
      
      // Draw circle
      ctx.beginPath();
      ctx.arc(center.x - radius * 0.7, center.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(156, 39, 176, 0.5)';
      ctx.fill();
      
      // Draw wedges arranged like a rectangle
      const wedgeCount = 8;
      for (let i = 0; i < wedgeCount; i++) {
        // Define wedge shape
        ctx.beginPath();
        ctx.moveTo(center.x + radius * 0.7, center.y - radius + i * (2 * radius / wedgeCount));
        ctx.arc(center.x - radius * 0.7, center.y, radius, 
                -Math.PI/2 + i * (Math.PI / wedgeCount), 
                -Math.PI/2 + (i+1) * (Math.PI / wedgeCount));
        ctx.lineTo(center.x + radius * 0.7, center.y - radius + (i+1) * (2 * radius / wedgeCount));
        ctx.closePath();
        
        ctx.fillStyle = `rgba(156, 39, 176, ${0.3 + i * 0.05})`;
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }
      
      // Draw equation
      ctx.fillStyle = '#333';
      ctx.font = '20px Arial';
      ctx.fillText('A = πr²', center.x, center.y + radius * 1.5);
    }
    
    function drawArchimedes(width, height) {
      const center = { x: width / 2, y: height / 2 };
      const radius = Math.min(width, height) * 0.35;
      
      // Draw circle
      ctx.beginPath();
      ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
      ctx.strokeStyle = '#2196F3';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw inscribed polygon (hexagon)
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI * 2 * (i / 6);
        const x = center.x + radius * Math.cos(angle);
        const y = center.y + radius * Math.sin(angle);
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.strokeStyle = '#FF5722';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw circumscribed polygon (hexagon)
      const outerRadius = radius / Math.cos(Math.PI / 6);
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI * 2 * (i / 6);
        const x = center.x + outerRadius * Math.cos(angle);
        const y = center.y + outerRadius * Math.sin(angle);
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.strokeStyle = '#4CAF50';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    function drawKonigsberg(width, height) {
      const riverWidth = width * 0.15;
      
      // Draw land areas
      ctx.fillStyle = '#8BC34A';
      
      // North bank
      ctx.fillRect(0, 0, width, height * 0.35);
      
      // South bank
      ctx.fillRect(0, height * 0.65, width, height * 0.35);
      
      // Islands
      ctx.beginPath();
      ctx.ellipse(width * 0.3, height * 0.5, width * 0.1, height * 0.08, 0, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.ellipse(width * 0.7, height * 0.5, width * 0.15, height * 0.08, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw river
      ctx.fillStyle = '#2196F3';
      ctx.fillRect(0, height * 0.35, width, riverWidth);
      ctx.fillRect(0, height * 0.5, width, riverWidth);
      
      // Draw bridges
      ctx.strokeStyle = '#795548';
      ctx.lineWidth = 6;
      
      // Bridge 1
      ctx.beginPath();
      ctx.moveTo(width * 0.2, height * 0.25);
      ctx.lineTo(width * 0.25, height * 0.5);
      ctx.stroke();
      
      // Bridge 2
      ctx.beginPath();
      ctx.moveTo(width * 0.4, height * 0.25);
      ctx.lineTo(width * 0.35, height * 0.5);
      ctx.stroke();
      
      // Bridge 3
      ctx.beginPath();
      ctx.moveTo(width * 0.3, height * 0.42);
      ctx.lineTo(width * 0.3, height * 0.58);
      ctx.stroke();
      
      // Bridge 4
      ctx.beginPath();
      ctx.moveTo(width * 0.5, height * 0.5);
      ctx.lineTo(width * 0.6, height * 0.5);
      ctx.stroke();
      
      // Bridge 5
      ctx.beginPath();
      ctx.moveTo(width * 0.7, height * 0.42);
      ctx.lineTo(width * 0.7, height * 0.25);
      ctx.stroke();
      
      // Bridge 6
      ctx.beginPath();
      ctx.moveTo(width * 0.7, height * 0.58);
      ctx.lineTo(width * 0.7, height * 0.75);
      ctx.stroke();
      
      // Bridge 7
      ctx.beginPath();
      ctx.moveTo(width * 0.85, height * 0.5);
      ctx.lineTo(width * 0.9, height * 0.75);
      ctx.stroke();
    }
    
    function drawEulerGraph(width, height) {
      // Draw vertices
      const vertices = [
        { x: width * 0.2, y: height * 0.3 },
        { x: width * 0.8, y: height * 0.3 },
        { x: width * 0.2, y: height * 0.7 },
        { x: width * 0.8, y: height * 0.7 }
      ];
      
      // Draw edges
      ctx.strokeStyle = '#2196F3';
      ctx.lineWidth = 3;
      
      // Edge A
      ctx.beginPath();
      ctx.moveTo(vertices[0].x, vertices[0].y);
      ctx.bezierCurveTo(
        width * 0.5, height * 0.1,
        width * 0.5, height * 0.1,
        vertices[1].x, vertices[1].y
      );
      ctx.stroke();
      
      // Edge B
      ctx.beginPath();
      ctx.moveTo(vertices[0].x, vertices[0].y);
      ctx.lineTo(vertices[1].x, vertices[1].y);
      ctx.stroke();
      
      // Edge C
      ctx.beginPath();
      ctx.moveTo(vertices[0].x, vertices[0].y);
      ctx.bezierCurveTo(
        width * 0.5, height * 0.5,
        width * 0.5, height * 0.5,
        vertices[1].x, vertices[1].y
      );
      ctx.stroke();
      
      // Edge D
      ctx.beginPath();
      ctx.moveTo(vertices[0].x, vertices[0].y);
      ctx.lineTo(vertices[2].x, vertices[2].y);
      ctx.stroke();
      
      // Edge E
      ctx.beginPath();
      ctx.moveTo(vertices[1].x, vertices[1].y);
      ctx.lineTo(vertices[3].x, vertices[3].y);
      ctx.stroke();
      
      // Edge F
      ctx.beginPath();
      ctx.moveTo(vertices[2].x, vertices[2].y);
      ctx.bezierCurveTo(
        width * 0.5, height * 0.9,
        width * 0.5, height * 0.9,
        vertices[3].x, vertices[3].y
      );
      ctx.stroke();
      
      // Edge G
      ctx.beginPath();
      ctx.moveTo(vertices[2].x, vertices[2].y);
      ctx.lineTo(vertices[3].x, vertices[3].y);
      ctx.stroke();
      
      // Draw vertex circles
      for (const vertex of vertices) {
        ctx.beginPath();
        ctx.arc(vertex.x, vertex.y, 15, 0, Math.PI * 2);
        ctx.fillStyle = '#F44336';
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      // Label edges
      ctx.fillStyle = '#000';
      ctx.font = '16px Arial';
      ctx.fillText('A', width * 0.5, height * 0.15);
      ctx.fillText('B', width * 0.5, height * 0.27);
      ctx.fillText('C', width * 0.5, height * 0.45);
      ctx.fillText('D', width * 0.15, height * 0.5);
      ctx.fillText('E', width * 0.85, height * 0.5);
      ctx.fillText('F', width * 0.5, height * 0.85);
      ctx.fillText('G', width * 0.5, height * 0.65);
    }
    
    function drawGraphApplications(width, height) {
      // Draw social network graph
      const center = { x: width / 2, y: height / 2 };
      const radius = Math.min(width, height) * 0.35;
      
      // Vertices positions
      const vertices = [];
      const vertexCount = 8;
      
      for (let i = 0; i < vertexCount; i++) {
        // Create vertices in a circular arrangement with some randomness
        const angle = Math.PI * 2 * (i / vertexCount);
        const vertexRadius = radius * (0.7 + Math.random() * 0.3);
        
        vertices.push({
          x: center.x + vertexRadius * Math.cos(angle),
          y: center.y + vertexRadius * Math.sin(angle)
        });
      }
      
      // Draw edges
      ctx.strokeStyle = '#2196F3';
      ctx.lineWidth = 2;
      
      // Create a realistic-looking network
      const edges = [
        [0, 1], [0, 2], [0, 3], [0, 4],  // Node 0 is well-connected
        [1, 2], [1, 5],
        [2, 3], [2, 5], [2, 6],
        [3, 4], [3, 7],
        [4, 7],
        [5, 6],
        [6, 7]
      ];
      
      for (const [i, j] of edges) {
        ctx.beginPath();
        ctx.moveTo(vertices[i].x, vertices[i].y);
        ctx.lineTo(vertices[j].x, vertices[j].y);
        ctx.stroke();
      }
      
      // Draw vertices
      for (let i = 0; i < vertexCount; i++) {
        const vertex = vertices[i];
        
        ctx.beginPath();
        ctx.arc(vertex.x, vertex.y, 15, 0, Math.PI * 2);
        
        // Different colors for vertices
        const colors = ['#F44336', '#E91E63', '#9C27B0', '#673AB7', '#3F51B5', '#2196F3', '#00BCD4', '#009688'];
        ctx.fillStyle = colors[i % colors.length];
        ctx.fill();
        
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
    
    function downloadImage() {
      if (!currentImageData) return;
      
      const link = document.createElement('a');
      link.href = currentImageData;
      const imageType = document.getElementById('imageType').value;
      link.download = `${imageType}.jpg`;
      link.click();
    }
    
    document.getElementById('generate').addEventListener('click', generateImage);
    document.getElementById('download').addEventListener('click', downloadImage);
    
    // Generate initial image
    generateImage();
  </script>
</body>
</html>
