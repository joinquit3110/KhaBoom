/* (c) Mathigon, generated by Mathigon Studio */
"use strict";
var StepFunctions = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // content/triangles/functions.ts
  var functions_exports = {};
  __export(functions_exports, {
    altitudes1: () => altitudes1,
    applications2: () => applications2,
    circumcircle: () => circumcircle,
    incircle: () => incircle,
    medians: () => medians,
    midsegments: () => midsegments,
    mountains: () => mountains,
    pythagorasProof: () => pythagorasProof,
    pythagoreanTriplesGrid: () => pythagoreanTriplesGrid,
    sssConstruction: () => sssConstruction
  });

  // node_modules/@mathigon/core/dist/index.esm.js
  function uid(n = 10) {
    return Math.random().toString(36).substr(2, n);
  }
  function isOneOf(x, ...values) {
    return values.includes(x);
  }
  function delay(fn, t = 0) {
    if (t) {
      return +setTimeout(fn, t);
    } else {
      fn();
      return 0;
    }
  }
  function repeat(value, n) {
    return new Array(n).fill(value);
  }
  function repeat2D(value, x, y) {
    const result = [];
    for (let i = 0; i < x; ++i) {
      result.push(repeat(value, y));
    }
    return result;
  }
  function tabulate(fn, n) {
    const result = [];
    for (let i = 0; i < n; ++i) {
      result.push(fn(i));
    }
    return result;
  }
  function tabulate2D(fn, x, y) {
    const result = [];
    for (let i = 0; i < x; ++i) {
      const row = [];
      for (let j = 0; j < y; ++j) {
        row.push(fn(i, j));
      }
      result.push(row);
    }
    return result;
  }
  function list(a, b, step = 1) {
    const arr = [];
    if (b === void 0 && a >= 0) {
      for (let i = 0; i < a; i += step) arr.push(i);
    } else if (b === void 0) {
      for (let i = 0; i > a; i -= step) arr.push(i);
    } else if (a <= b) {
      for (let i = a; i <= b; i += step) arr.push(i);
    } else {
      for (let i = a; i >= b; i -= step) arr.push(i);
    }
    return arr;
  }
  function last(array, i = 0) {
    return array[array.length - 1 - i];
  }
  function total(array) {
    return array.reduce((t, v) => t + v, 0);
  }
  function flatten(array) {
    return array.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
  }

  // node_modules/@mathigon/fermat/dist/index.esm.js
  var __defProp2 = Object.defineProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var PRECISION = 1e-6;
  function nearlyEquals(a, b, t = PRECISION) {
    if (isNaN(a) || isNaN(b)) return false;
    return Math.abs(a - b) < t;
  }
  function isInteger(x, t = PRECISION) {
    return nearlyEquals(x, Math.round(x), t);
  }
  function isBetween(value, a, b, t = PRECISION) {
    if (a > b) [a, b] = [b, a];
    return value > a + t && value < b - t;
  }
  function round(n, precision = 0) {
    const factor = Math.pow(10, precision);
    return Math.round(n * factor) / factor;
  }
  function roundTo(n, increment = 1) {
    return Math.round(n / increment) * increment;
  }
  function clamp(x, min = -Infinity, max = Infinity) {
    return Math.min(max, Math.max(min, x));
  }
  function lerp(a, b, t = 0.5) {
    return a + (b - a) * t;
  }
  function square(x) {
    return x * x;
  }
  function mod(a, m) {
    return (a % m + m) % m;
  }
  function subsets(array, length = 0) {
    const copy = array.slice(0);
    const results = subsetsHelper(copy);
    return length ? results.filter((x) => x.length === length) : results;
  }
  function subsetsHelper(array) {
    if (array.length === 1) return [[], array];
    const last2 = array.pop();
    const subsets2 = subsetsHelper(array);
    const result = [];
    for (const s of subsets2) {
      result.push(s, [...s, last2]);
    }
    return result;
  }
  var matrix_exports = {};
  __export2(matrix_exports, {
    determinant: () => determinant,
    fill: () => fill,
    identity: () => identity,
    inverse: () => inverse,
    product: () => product,
    reflection: () => reflection,
    rotation: () => rotation,
    scalarProduct: () => scalarProduct,
    shear: () => shear,
    sum: () => sum,
    transpose: () => transpose
  });
  function fill(value, x, y) {
    return repeat2D(value, x, y);
  }
  function identity(n = 2) {
    const x = fill(0, n, n);
    for (let i = 0; i < n; ++i) x[i][i] = 1;
    return x;
  }
  function rotation(angle) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);
    return [[cos, -sin], [sin, cos]];
  }
  function shear(lambda) {
    return [[1, lambda], [0, 1]];
  }
  function reflection(angle) {
    const sin = Math.sin(2 * angle);
    const cos = Math.cos(2 * angle);
    return [[cos, sin], [sin, -cos]];
  }
  function sum(...matrices) {
    const [M1, ...rest] = matrices;
    const M2 = rest.length > 1 ? sum(...rest) : rest[0];
    if (M1.length !== M2.length || M1[0].length !== M2[0].length) {
      throw new Error("Matrix sizes don\u2019t match");
    }
    const S = [];
    for (let i = 0; i < M1.length; ++i) {
      const row = [];
      for (let j = 0; j < M1[i].length; ++j) {
        row.push(M1[i][j] + M2[i][j]);
      }
      S.push(row);
    }
    return S;
  }
  function scalarProduct(M, v) {
    return M.map((row) => row.map((x) => x * v));
  }
  function product(...matrices) {
    const [M1, ...rest] = matrices;
    const M2 = rest.length > 1 ? product(...rest) : rest[0];
    if (M1[0].length !== M2.length) {
      throw new Error("Matrix sizes don\u2019t match.");
    }
    const P2 = [];
    for (let i = 0; i < M1.length; ++i) {
      const row = [];
      for (let j = 0; j < M2[0].length; ++j) {
        let value = 0;
        for (let k = 0; k < M2.length; ++k) {
          value += M1[i][k] * M2[k][j];
        }
        row.push(value);
      }
      P2.push(row);
    }
    return P2;
  }
  function transpose(M) {
    const T = [];
    for (let j = 0; j < M[0].length; ++j) {
      const row = [];
      for (let i = 0; i < M.length; ++i) {
        row.push(M[i][j]);
      }
      T.push(row);
    }
    return T;
  }
  function determinant(M) {
    if (M.length !== M[0].length) throw new Error("Not a square matrix.");
    const n = M.length;
    if (n === 1) return M[0][0];
    if (n === 2) return M[0][0] * M[1][1] - M[0][1] * M[1][0];
    let det = 0;
    for (let j = 0; j < n; ++j) {
      let diagLeft = M[0][j];
      let diagRight = M[0][j];
      for (let i = 1; i < n; ++i) {
        diagRight *= M[i][(j + i) % n];
        diagLeft *= M[i][(j - i + n) % n];
      }
      det += diagRight - diagLeft;
    }
    return det;
  }
  function inverse(M) {
    const n = M.length;
    if (n !== M[0].length) throw new Error("Not a square matrix.");
    const I = identity(n);
    const C = tabulate2D((x, y) => M[x][y], n, n);
    for (let i = 0; i < n; ++i) {
      let e = C[i][i];
      if (nearlyEquals(e, 0)) {
        for (let ii = i + 1; ii < n; ++ii) {
          if (C[ii][i] !== 0) {
            for (let j = 0; j < n; ++j) {
              [C[ii][j], C[i][j]] = [C[i][j], C[ii][j]];
              [I[ii][j], I[i][j]] = [I[i][j], I[ii][j]];
            }
            break;
          }
        }
        e = C[i][i];
        if (nearlyEquals(e, 0)) throw new Error("Matrix not invertible.");
      }
      for (let j = 0; j < n; ++j) {
        C[i][j] = C[i][j] / e;
        I[i][j] = I[i][j] / e;
      }
      for (let ii = 0; ii < n; ++ii) {
        if (ii === i) continue;
        const f = C[ii][i];
        for (let j = 0; j < n; ++j) {
          C[ii][j] -= f * C[i][j];
          I[ii][j] -= f * I[i][j];
        }
      }
    }
    return I;
  }
  var random_exports = {};
  __export2(random_exports, {
    bernoulli: () => bernoulli,
    binomial: () => binomial2,
    cauchy: () => cauchy,
    chiCDF: () => chiCDF,
    exponential: () => exponential,
    find: () => find,
    geometric: () => geometric,
    integer: () => integer,
    integrate: () => integrate,
    normal: () => normal,
    normalPDF: () => normalPDF,
    poisson: () => poisson,
    shuffle: () => shuffle,
    smart: () => smart,
    uniform: () => uniform,
    weighted: () => weighted
  });
  function shuffle(a) {
    a = a.slice(0);
    for (let i = a.length - 1; i > 0; --i) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }
  function integer(a, b) {
    const start = b === void 0 ? 0 : a;
    const length = b === void 0 ? a : b - a + 1;
    return start + Math.floor(length * Math.random());
  }
  function weighted(weights) {
    const x = Math.random() * total(weights);
    let cum = 0;
    return weights.findIndex((w) => (cum += w) >= x);
  }
  function find(items) {
    return items[Math.floor(items.length * Math.random())];
  }
  var SMART_RANDOM_CACHE = /* @__PURE__ */ new Map();
  function smart(n, id) {
    if (!id) id = uid();
    if (!SMART_RANDOM_CACHE.has(id)) SMART_RANDOM_CACHE.set(id, repeat(1, n));
    const cache = SMART_RANDOM_CACHE.get(id);
    const x = weighted(cache.map((x2) => x2 * x2));
    cache[x] -= 1;
    if (cache[x] <= 0) SMART_RANDOM_CACHE.set(id, cache.map((x2) => x2 + 1));
    return x;
  }
  function bernoulli(p = 0.5) {
    return Math.random() < p ? 1 : 0;
  }
  function binomial2(n = 1, p = 0.5) {
    let t = 0;
    for (let i = 0; i < n; ++i) t += bernoulli(p);
    return t;
  }
  function poisson(l = 1) {
    if (l <= 0) return 0;
    const L = Math.exp(-l);
    let p = 1;
    let k = 0;
    for (; p > L; ++k) p *= Math.random();
    return k - 1;
  }
  function uniform(a = 0, b = 1) {
    return a + (b - a) * Math.random();
  }
  function normal(m = 0, v = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const rand = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return rand * Math.sqrt(v) + m;
  }
  function exponential(l = 1) {
    return l <= 0 ? 0 : -Math.log(Math.random()) / l;
  }
  function geometric(p = 0.5) {
    if (p <= 0 || p > 1) return void 0;
    return Math.floor(Math.log(Math.random()) / Math.log(1 - p));
  }
  function cauchy() {
    let rr;
    let v1;
    let v2;
    do {
      v1 = 2 * Math.random() - 1;
      v2 = 2 * Math.random() - 1;
      rr = v1 * v1 + v2 * v2;
    } while (rr >= 1);
    return v1 / v2;
  }
  function normalPDF(x, m = 1, v = 0) {
    return Math.exp(-((x - m) ** 2) / (2 * v)) / Math.sqrt(2 * Math.PI * v);
  }
  var G = 7;
  var P = [
    0.9999999999998099,
    676.5203681218851,
    -1259.1392167224028,
    771.3234287776531,
    -176.6150291621406,
    12.507343278686905,
    -0.13857109526572012,
    9984369578019572e-21,
    15056327351493116e-23
  ];
  function gamma(z) {
    if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    z -= 1;
    let x = P[0];
    for (let i = 1; i < G + 2; i++) x += P[i] / (z + i);
    const t = z + G + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
  }
  function integrate(fn, xMin, xMax, dx = 1) {
    let result = 0;
    for (let x = xMin; x < xMax; x += dx) {
      result += fn(x) * dx || 0;
    }
    return result;
  }
  function chiCDF(chi, deg) {
    const int = integrate((t) => Math.pow(t, (deg - 2) / 2) * Math.exp(-t / 2), 0, chi);
    return 1 - int / Math.pow(2, deg / 2) / gamma(deg / 2);
  }
  var regression_exports = {};
  __export2(regression_exports, {
    bestPolynomial: () => bestPolynomial,
    coefficient: () => coefficient,
    exponential: () => exponential2,
    linear: () => linear,
    logarithmic: () => logarithmic,
    polynomial: () => polynomial2,
    power: () => power
  });
  function evaluatePolynomial(regression, x) {
    let xs = 1;
    let t = regression[0];
    for (let i = 1; i < regression.length; ++i) {
      xs *= x;
      t += xs * regression[i];
    }
    return t;
  }
  function linear(data, throughOrigin = false) {
    let sX = 0;
    let sY = 0;
    let sXX = 0;
    let sXY = 0;
    const len = data.length;
    for (let n = 0; n < len; n++) {
      sX += data[n][0];
      sY += data[n][1];
      sXX += data[n][0] * data[n][0];
      sXY += data[n][0] * data[n][1];
    }
    if (throughOrigin) {
      const gradient2 = sXY / sXX;
      return [0, gradient2];
    }
    const gradient = (len * sXY - sX * sY) / (len * sXX - sX * sX);
    const intercept = sY / len - gradient * sX / len;
    return [intercept, gradient];
  }
  function exponential2(data) {
    const sum2 = [0, 0, 0, 0, 0, 0];
    for (const d of data) {
      sum2[0] += d[0];
      sum2[1] += d[1];
      sum2[2] += d[0] * d[0] * d[1];
      sum2[3] += d[1] * Math.log(d[1]);
      sum2[4] += d[0] * d[1] * Math.log(d[1]);
      sum2[5] += d[0] * d[1];
    }
    const denominator = sum2[1] * sum2[2] - sum2[5] * sum2[5];
    const a = Math.exp((sum2[2] * sum2[3] - sum2[5] * sum2[4]) / denominator);
    const b = (sum2[1] * sum2[4] - sum2[5] * sum2[3]) / denominator;
    return [a, b];
  }
  function logarithmic(data) {
    const sum2 = [0, 0, 0, 0];
    const len = data.length;
    for (const d of data) {
      sum2[0] += Math.log(d[0]);
      sum2[1] += d[1] * Math.log(d[0]);
      sum2[2] += d[1];
      sum2[3] += Math.pow(Math.log(d[0]), 2);
    }
    const b = (len * sum2[1] - sum2[2] * sum2[0]) / (len * sum2[3] - sum2[0] * sum2[0]);
    const a = (sum2[2] - b * sum2[0]) / len;
    return [a, b];
  }
  function power(data) {
    const sum2 = [0, 0, 0, 0];
    const len = data.length;
    for (const d of data) {
      sum2[0] += Math.log(d[0]);
      sum2[1] += Math.log(d[1]) * Math.log(d[0]);
      sum2[2] += Math.log(d[1]);
      sum2[3] += Math.pow(Math.log(d[0]), 2);
    }
    const b = (len * sum2[1] - sum2[2] * sum2[0]) / (len * sum2[3] - sum2[0] * sum2[0]);
    const a = Math.exp((sum2[2] - b * sum2[0]) / len);
    return [a, b];
  }
  function polynomial2(data, order = 2) {
    const X = data.map((d) => list(order + 1).map((p) => Math.pow(d[0], p)));
    const XT = transpose(X);
    const y = data.map((d) => [d[1]]);
    const XTX = product(XT, X);
    const inv = inverse(XTX);
    const r = product(inv, XT, y);
    return r.map((x) => x[0]);
  }
  function coefficient(data, fn) {
    const total4 = data.reduce((sum2, d) => sum2 + d[1], 0);
    const mean2 = total4 / data.length;
    const ssyy = data.reduce((sum2, d) => sum2 + (d[1] - mean2) ** 2, 0);
    const sse = data.reduce((sum2, d) => sum2 + (d[1] - fn(d[0])) ** 2, 0);
    return 1 - sse / ssyy;
  }
  function bestPolynomial(data, threshold = 0.85, maxOrder = 8) {
    if (data.length <= 1) return void 0;
    for (let i = 1; i < maxOrder; ++i) {
      const reg = polynomial2(data, i);
      const fn = (x) => evaluatePolynomial(reg, x);
      const coeff = coefficient(data, fn);
      if (coeff >= threshold) return { order: i, coefficients: reg, fn };
    }
    return void 0;
  }

  // node_modules/@mathigon/euclid/dist/index.esm.js
  var TWO_PI = 2 * Math.PI;
  function rad(p, c) {
    const a = Math.atan2(p.y - (c ? c.y : 0), p.x - (c ? c.x : 0));
    return mod(a, TWO_PI);
  }
  function findClosest(p, items) {
    let q = void 0;
    let d = Infinity;
    let index = -1;
    for (const [i, e] of items.entries()) {
      const q1 = e.project(p);
      const d1 = Point.distance(p, q1);
      if (d1 < d) {
        q = q1;
        d = d1;
        index = i;
      }
    }
    return q ? [q, index] : void 0;
  }
  var Point = class _Point {
    constructor(x = 0, y = 0) {
      this.x = x;
      this.y = y;
      this.type = "point";
    }
    get unitVector() {
      if (nearlyEquals(this.length, 0)) return new _Point(1, 0);
      return this.scale(1 / this.length);
    }
    get length() {
      return Math.sqrt(this.x ** 2 + this.y ** 2);
    }
    get inverse() {
      return new _Point(-this.x, -this.y);
    }
    get flip() {
      return new _Point(this.y, this.x);
    }
    get perpendicular() {
      return new _Point(-this.y, this.x);
    }
    get array() {
      return [this.x, this.y];
    }
    /** Finds the perpendicular distance between this point and a line. */
    distanceFromLine(l) {
      return _Point.distance(this, l.project(this));
    }
    /** Clamps this point to specific bounds. */
    clamp(bounds, padding = 0) {
      const x = clamp(this.x, bounds.xMin + padding, bounds.xMax - padding);
      const y = clamp(this.y, bounds.yMin + padding, bounds.yMax - padding);
      return new _Point(x, y);
    }
    changeCoordinates(originCoords, targetCoords) {
      const x = targetCoords.xMin + (this.x - originCoords.xMin) / originCoords.dx * targetCoords.dx;
      const y = targetCoords.yMin + (this.y - originCoords.yMin) / originCoords.dy * targetCoords.dy;
      return new _Point(x, y);
    }
    add(p) {
      return _Point.sum(this, p);
    }
    subtract(p) {
      return _Point.difference(this, p);
    }
    round(inc = 1) {
      return new _Point(roundTo(this.x, inc), roundTo(this.y, inc));
    }
    floor() {
      return new _Point(Math.floor(this.x), Math.floor(this.y));
    }
    mod(x, y = x) {
      return new _Point(this.x % x, this.y % y);
    }
    angle(c = ORIGIN) {
      return rad(this, c);
    }
    // Snap to the x or y values of another point
    snap(p, tolerance = 5) {
      if (nearlyEquals(this.x, p.x, tolerance)) return new _Point(p.x, this.y);
      if (nearlyEquals(this.y, p.y, tolerance)) return new _Point(this.x, p.y);
      return this;
    }
    /** Calculates the average of multiple points. */
    static average(...points) {
      const x = total(points.map((p) => p.x)) / points.length;
      const y = total(points.map((p) => p.y)) / points.length;
      return new _Point(x, y);
    }
    /** Calculates the dot product of two points p1 and p2. */
    static dot(p1, p2) {
      return p1.x * p2.x + p1.y * p2.y;
    }
    static sum(p1, p2) {
      return new _Point(p1.x + p2.x, p1.y + p2.y);
    }
    static difference(p1, p2) {
      return new _Point(p1.x - p2.x, p1.y - p2.y);
    }
    /** Returns the Euclidean distance between two points p1 and p2. */
    static distance(p1, p2) {
      return Math.sqrt(square(p1.x - p2.x) + square(p1.y - p2.y));
    }
    /** Returns the Manhattan distance between two points p1 and p2. */
    static manhattan(p1, p2) {
      return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
    }
    /** Interpolates two points p1 and p2 by a factor of t. */
    static interpolate(p1, p2, t = 0.5) {
      return new _Point(lerp(p1.x, p2.x, t), lerp(p1.y, p2.y, t));
    }
    /** Interpolates a list of multiple points. */
    static interpolateList(points, t = 0.5) {
      const n = points.length - 1;
      const a = Math.floor(clamp(t, 0, 1) * n);
      return _Point.interpolate(points[a], points[a + 1], n * t - a);
    }
    /** Creates a point from polar coordinates. */
    static fromPolar(angle, r = 1) {
      return new _Point(r * Math.cos(angle), r * Math.sin(angle));
    }
    static random(b) {
      const x = random_exports.uniform(b.xMin, b.xMax);
      const y = random_exports.uniform(b.yMin, b.yMax);
      return new _Point(x, y);
    }
    static equals(p1, p2, precision) {
      return nearlyEquals(p1.x, p2.x, precision) && nearlyEquals(p1.y, p2.y, precision);
    }
    /** Check if p1, p2 and p3 lie on a straight line. */
    static colinear(p1, p2, p3, tolerance) {
      const dx1 = p1.x - p2.x;
      const dy1 = p1.y - p2.y;
      const dx2 = p2.x - p3.x;
      const dy2 = p2.y - p3.y;
      return nearlyEquals(dx1 * dy2, dx2 * dy1, tolerance);
    }
    // ---------------------------------------------------------------------------
    /** Transforms this point using a 2x3 matrix m. */
    transform(m) {
      const x = m[0][0] * this.x + m[0][1] * this.y + m[0][2];
      const y = m[1][0] * this.x + m[1][1] * this.y + m[1][2];
      return new _Point(x, y);
    }
    /** Rotates this point by a given angle (in radians) around point `c`. */
    rotate(angle, c = ORIGIN) {
      if (nearlyEquals(angle, 0)) return this;
      const x0 = this.x - c.x;
      const y0 = this.y - c.y;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const x = x0 * cos - y0 * sin + c.x;
      const y = x0 * sin + y0 * cos + c.y;
      return new _Point(x, y);
    }
    /** Reflects this point across a line l. */
    reflect(l) {
      const v = l.p2.x - l.p1.x;
      const w = l.p2.y - l.p1.y;
      const x0 = this.x - l.p1.x;
      const y0 = this.y - l.p1.y;
      const mu = (v * y0 - w * x0) / (v * v + w * w);
      const x = this.x + 2 * mu * w;
      const y = this.y - 2 * mu * v;
      return new _Point(x, y);
    }
    scale(sx, sy = sx) {
      return new _Point(this.x * sx, this.y * sy);
    }
    shift(x, y = x) {
      return new _Point(this.x + x, this.y + y);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, precision) {
      return _Point.equals(this, other, precision);
    }
    toString() {
      return `point(${this.x},${this.y})`;
    }
  };
  var ORIGIN = new Point(0, 0);
  function isPolygonLike(shape) {
    return ["polygon", "polyline", "rectangle", "triangle"].includes(shape.type);
  }
  function isLineLike(shape) {
    return ["line", "ray", "segment"].includes(shape.type);
  }
  function isRay(shape) {
    return shape.type === "ray";
  }
  function isSegment(shape) {
    return shape.type === "segment";
  }
  function isCircle(shape) {
    return shape.type === "circle";
  }
  function isArc(shape) {
    return shape.type === "arc";
  }
  function isAngle(shape) {
    return shape.type === "angle";
  }
  var Line = class _Line {
    constructor(p1, p2) {
      this.p1 = p1;
      this.p2 = p2;
      this.type = "line";
    }
    /* The distance between the two points defining this line. */
    get length() {
      return Point.distance(this.p1, this.p2);
    }
    /* The squared distance between the two points defining this line. */
    get lengthSquared() {
      return (this.p1.x - this.p2.x) ** 2 + (this.p1.y - this.p2.y) ** 2;
    }
    /** The midpoint of this line. */
    get midpoint() {
      return Point.average(this.p1, this.p2);
    }
    /** The slope of this line. */
    get slope() {
      return (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x);
    }
    /** The y-axis intercept of this line. */
    get intercept() {
      return this.p1.y - this.slope * this.p1.x;
    }
    /** The angle formed between this line and the x-axis. */
    get angle() {
      return rad(this.p2, this.p1);
    }
    /** The point representing a unit vector along this line. */
    get unitVector() {
      return this.p2.subtract(this.p1).unitVector;
    }
    /** The point representing the perpendicular vector of this line. */
    get perpendicularVector() {
      return new Point(this.p2.y - this.p1.y, this.p1.x - this.p2.x).unitVector;
    }
    /** Finds the line parallel to this one, going through point p. */
    parallel(p) {
      return new _Line(p, p.add(this.p2).subtract(this.p1));
    }
    /** Finds the line perpendicular to this one, going through point p. */
    perpendicular(p) {
      const q = this.line.project(p);
      if (Point.equals(p, q)) return new _Line(q, q.add(this.perpendicularVector.scale(this.length / 2)));
      return new _Line(q, p);
    }
    /** The perpendicular bisector of this line. */
    get perpendicularBisector() {
      return this.perpendicular(this.midpoint);
    }
    /** Squared distance between a point and a line. */
    distanceSquared(p) {
      const proj = this.project(p);
      return (p.x - proj.x) ** 2 + (p.y - proj.y) ** 2;
    }
    get line() {
      return this.type === "line" ? this : new _Line(this.p1, this.p2);
    }
    get ray() {
      return isRay(this) ? this : new Ray(this.p1, this.p2);
    }
    get segment() {
      return isSegment(this) ? this : new Segment(this.p1, this.p2);
    }
    // ---------------------------------------------------------------------------
    /** Signed distance along the line (opposite of .at()). */
    offset(p) {
      const a = Point.difference(this.p2, this.p1);
      const b = Point.difference(p, this.p1);
      return Point.dot(a, b) / this.lengthSquared;
    }
    /** Projects a point `p` onto this line. */
    project(p) {
      return this.at(this.offset(p));
    }
    /** Returns which side of this line a point p is on (or 0 on the line). */
    side(p, tolerance) {
      const a = Point.difference(this.p2, this.p1);
      const b = Point.difference(p, this.p1);
      const d = b.x * a.y - b.y * a.x;
      return nearlyEquals(d, 0, tolerance) ? 0 : Math.sign(d);
    }
    /** Checks if a point p lies on this line. */
    contains(p, tolerance) {
      return this.side(p, tolerance) === 0;
    }
    /** Gets the point at a specific offset along the line (opposite of .offset()). */
    at(t) {
      return Point.interpolate(this.p1, this.p2, t);
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return new this.constructor(this.p1.transform(m), this.p2.transform(m));
    }
    /** Rotates this line by a given angle (in radians), optionally around point `c`. */
    rotate(a, c = ORIGIN) {
      if (nearlyEquals(a, 0)) return this;
      return new this.constructor(this.p1.rotate(a, c), this.p2.rotate(a, c));
    }
    reflect(l) {
      return new this.constructor(this.p1.reflect(l), this.p2.reflect(l));
    }
    scale(sx, sy = sx) {
      return new this.constructor(this.p1.scale(sx, sy), this.p2.scale(sx, sy));
    }
    shift(x, y = x) {
      return new this.constructor(this.p1.shift(x, y), this.p2.shift(x, y));
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, tolerance) {
      return this.contains(other.p1, tolerance) && this.contains(other.p2, tolerance);
    }
    toString() {
      return `line(${this.p1},${this.p2})`;
    }
  };
  var Ray = class extends Line {
    constructor() {
      super(...arguments);
      this.type = "ray";
    }
    equals(other, tolerance) {
      if (other.type !== "ray") return false;
      if (!this.p1.equals(other.p1, tolerance)) return false;
      if (this.p2.equals(other.p2, tolerance)) return true;
      return other.contains(this.p2, tolerance) || this.contains(other.p2, tolerance);
    }
    contains(p, tolerance) {
      if (!super.contains(p, tolerance)) return false;
      const offset = this.offset(p);
      return nearlyEquals(offset, 0, tolerance) || offset > 0;
    }
    toString() {
      return `ray(${this.p1},${this.p2})`;
    }
  };
  var Segment = class _Segment extends Line {
    constructor() {
      super(...arguments);
      this.type = "segment";
    }
    contains(p, tolerance) {
      if (!super.contains(p, tolerance)) return false;
      if (this.p1.equals(p, tolerance) || this.p2.equals(p, tolerance)) return true;
      if (nearlyEquals(this.p1.x, this.p2.x, tolerance)) {
        return isBetween(p.y, this.p1.y, this.p2.y);
      } else {
        return isBetween(p.x, this.p1.x, this.p2.x);
      }
    }
    project(p) {
      const a = Point.difference(this.p2, this.p1);
      const b = Point.difference(p, this.p1);
      const q = clamp(Point.dot(a, b) / this.lengthSquared, 0, 1);
      return this.p1.add(a.scale(q));
    }
    /** Contracts (or expands) a line by a specific ratio. */
    contract(x) {
      return new _Segment(this.at(x), this.at(1 - x));
    }
    equals(other, tolerance, oriented = false) {
      if (other.type !== "segment") return false;
      return this.p1.equals(other.p1, tolerance) && this.p2.equals(other.p2, tolerance) || !oriented && this.p1.equals(other.p2, tolerance) && this.p2.equals(other.p1, tolerance);
    }
    toString() {
      return `segment(${this.p1},${this.p2})`;
    }
  };
  var Circle = class _Circle {
    constructor(c = ORIGIN, r = 1) {
      this.c = c;
      this.r = r;
      this.type = "circle";
    }
    /** The length of the circumference of this circle. */
    get circumference() {
      return TWO_PI * this.r;
    }
    /** The area of this circle. */
    get area() {
      return Math.PI * this.r ** 2;
    }
    get arc() {
      const start = this.c.shift(this.r, 0);
      return new Arc(this.c, start, TWO_PI);
    }
    tangentAt(t) {
      const p1 = this.at(t);
      const p2 = this.c.rotate(Math.PI / 2, p1);
      return new Line(p1, p2);
    }
    collision(r) {
      const tX = this.c.x < r.p.x ? r.p.x : this.c.x > r.p.x + r.w ? r.p.x + r.w : this.c.x;
      const tY = this.c.y < r.p.y ? r.p.y : this.c.y > r.p.y + r.h ? r.p.y + r.h : this.c.y;
      const d = Point.distance(this.c, new Point(tX, tY));
      return d <= this.r;
    }
    // ---------------------------------------------------------------------------
    project(p) {
      const proj = p.subtract(this.c).unitVector.scale(this.r);
      return Point.sum(this.c, proj);
    }
    at(t) {
      const a = TWO_PI * t;
      return this.c.shift(this.r * Math.cos(a), this.r * Math.sin(a));
    }
    offset(p) {
      return rad(p, this.c) / TWO_PI;
    }
    contains(p) {
      return Point.distance(p, this.c) <= this.r;
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      const scale = Math.abs(m[0][0]) + Math.abs(m[1][1]);
      return new _Circle(this.c.transform(m), this.r * scale / 2);
    }
    rotate(a, c = ORIGIN) {
      if (nearlyEquals(a, 0)) return this;
      return new _Circle(this.c.rotate(a, c), this.r);
    }
    reflect(l) {
      return new _Circle(this.c.reflect(l), this.r);
    }
    scale(sx, sy = sx) {
      return new _Circle(this.c.scale(sx, sy), this.r * (sx + sy) / 2);
    }
    shift(x, y = x) {
      return new _Circle(this.c.shift(x, y), this.r);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, tolerance) {
      return nearlyEquals(this.r, other.r, tolerance) && this.c.equals(other.c, tolerance);
    }
    toString() {
      return `circle(${this.c},${this.r})`;
    }
  };
  var Arc = class {
    constructor(c, start, angle) {
      this.c = c;
      this.start = start;
      this.angle = angle;
      this.type = "arc";
    }
    get circle() {
      return new Circle(this.c, this.radius);
    }
    get radius() {
      return Point.distance(this.c, this.start);
    }
    get end() {
      return this.start.rotate(this.angle, this.c);
    }
    get startAngle() {
      return rad(this.start, this.c);
    }
    contract(p) {
      return new this.constructor(this.c, this.at(p / 2), this.angle * (1 - p));
    }
    get minor() {
      if (this.angle <= Math.PI) return this;
      return new this.constructor(this.c, this.end, TWO_PI - this.angle);
    }
    get major() {
      if (this.angle >= Math.PI) return this;
      return new this.constructor(this.c, this.end, TWO_PI - this.angle);
    }
    get center() {
      return this.at(0.5);
    }
    // ---------------------------------------------------------------------------
    project(p) {
      const start = this.startAngle;
      const end = start + this.angle;
      let angle = rad(p, this.c);
      if (end > TWO_PI && angle < end - TWO_PI) angle += TWO_PI;
      angle = clamp(angle, start, end);
      return this.c.shift(this.radius, 0).rotate(angle, this.c);
    }
    at(t) {
      return this.start.rotate(this.angle * t, this.c);
    }
    offset(p) {
      return new Angle(this.start, this.c, p).rad / this.angle;
    }
    contains(p) {
      return p.equals(this.project(p));
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return new this.constructor(
        this.c.transform(m),
        this.start.transform(m),
        this.angle
      );
    }
    /** Rotates this arc by a given angle (in radians), optionally around point `c`. */
    rotate(a, c = ORIGIN) {
      if (nearlyEquals(a, 0)) return this;
      return new this.constructor(
        this.c.rotate(a, c),
        this.start.rotate(a, c),
        this.angle
      );
    }
    reflect(l) {
      return new this.constructor(
        this.c.reflect(l),
        this.start.reflect(l),
        this.angle
      );
    }
    scale(sx, sy = sx) {
      return new this.constructor(
        this.c.scale(sx, sy),
        this.start.scale(sx, sy),
        this.angle
      );
    }
    shift(x, y = x) {
      return new this.constructor(
        this.c.shift(x, y),
        this.start.shift(x, y),
        this.angle
      );
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals() {
      return false;
    }
    toString() {
      return `arc(${this.c},${this.start},${this.angle})`;
    }
  };
  var Sector = class extends Arc {
    constructor() {
      super(...arguments);
      this.type = "sector";
    }
    contains(p) {
      return Point.distance(p, this.c) <= this.radius && new Angle(this.start, this.c, p).rad <= this.angle;
    }
    toString() {
      return `sector(${this.c},${this.start},${this.angle})`;
    }
  };
  function liesOnSegment(s, p) {
    if (nearlyEquals(s.p1.x, s.p2.x)) return isBetween(p.y, s.p1.y, s.p2.y);
    return isBetween(p.x, s.p1.x, s.p2.x);
  }
  function liesOnRay(r, p) {
    if (nearlyEquals(r.p1.x, r.p2.x)) return (p.y - r.p1.y) / (r.p2.y - r.p1.y) > 0;
    return (p.x - r.p1.x) / (r.p2.x - r.p1.x) > 0;
  }
  function liesOnArc(a, p) {
    return isBetween(a.offset(p), 0, 1);
  }
  function lineLineIntersection(l1, l2) {
    const d1x = l1.p1.x - l1.p2.x;
    const d1y = l1.p1.y - l1.p2.y;
    const d2x = l2.p1.x - l2.p2.x;
    const d2y = l2.p1.y - l2.p2.y;
    const d = d1x * d2y - d1y * d2x;
    if (nearlyEquals(d, 0)) return [];
    const q1 = l1.p1.x * l1.p2.y - l1.p1.y * l1.p2.x;
    const q2 = l2.p1.x * l2.p2.y - l2.p1.y * l2.p2.x;
    const x = q1 * d2x - d1x * q2;
    const y = q1 * d2y - d1y * q2;
    return [new Point(x / d, y / d)];
  }
  function circleCircleIntersection(c1, c2) {
    const d = Point.distance(c1.c, c2.c);
    if (d > c1.r + c2.r) return [];
    if (d < Math.abs(c1.r - c2.r)) return [];
    if (nearlyEquals(d, 0) && nearlyEquals(c1.r, c2.r)) return [];
    if (nearlyEquals(d, c1.r + c2.r)) return [new Line(c1.c, c2.c).midpoint];
    const a = (square(c1.r) - square(c2.r) + square(d)) / (2 * d);
    const b = Math.sqrt(square(c1.r) - square(a));
    const px = (c2.c.x - c1.c.x) * a / d + (c2.c.y - c1.c.y) * b / d + c1.c.x;
    const py = (c2.c.y - c1.c.y) * a / d - (c2.c.x - c1.c.x) * b / d + c1.c.y;
    const qx = (c2.c.x - c1.c.x) * a / d - (c2.c.y - c1.c.y) * b / d + c1.c.x;
    const qy = (c2.c.y - c1.c.y) * a / d + (c2.c.x - c1.c.x) * b / d + c1.c.y;
    return [new Point(px, py), new Point(qx, qy)];
  }
  function lineCircleIntersection(l, c) {
    const dx = l.p2.x - l.p1.x;
    const dy = l.p2.y - l.p1.y;
    const dr2 = square(dx) + square(dy);
    const cx = c.c.x;
    const cy = c.c.y;
    const D = (l.p1.x - cx) * (l.p2.y - cy) - (l.p2.x - cx) * (l.p1.y - cy);
    const disc = square(c.r) * dr2 - square(D);
    if (disc < 0) return [];
    const xa = D * dy / dr2;
    const ya = -D * dx / dr2;
    if (nearlyEquals(disc, 0)) return [c.c.shift(xa, ya)];
    const xb = dx * (dy < 0 ? -1 : 1) * Math.sqrt(disc) / dr2;
    const yb = Math.abs(dy) * Math.sqrt(disc) / dr2;
    return [c.c.shift(xa + xb, ya + yb), c.c.shift(xa - xb, ya - yb)];
  }
  function simpleIntersection(a, b) {
    let results = [];
    const a1 = isArc(a) ? a.circle : a;
    const b1 = isArc(b) ? b.circle : b;
    if (isLineLike(a) && isLineLike(b)) {
      results = lineLineIntersection(a, b);
    } else if (isLineLike(a1) && isCircle(b1)) {
      results = lineCircleIntersection(a1, b1);
    } else if (isCircle(a1) && isLineLike(b1)) {
      results = lineCircleIntersection(b1, a1);
    } else if (isCircle(a1) && isCircle(b1)) {
      results = circleCircleIntersection(a1, b1);
    }
    for (const x of [a, b]) {
      if (isSegment(x)) results = results.filter((i) => liesOnSegment(x, i));
      if (isRay(x)) results = results.filter((i) => liesOnRay(x, i));
      if (isArc(x)) results = results.filter((i) => liesOnArc(x, i));
    }
    return results;
  }
  function intersections(...elements) {
    if (elements.length < 2) return [];
    if (elements.length > 2) {
      return flatten(subsets(elements, 2).map((e) => intersections(...e)));
    }
    let [a, b] = elements;
    if (isAngle(a)) a = a.shape(true);
    if (isAngle(b)) b = b.shape(true);
    if (isPolygonLike(b)) [a, b] = [b, a];
    if (isPolygonLike(a)) {
      const results = isLineLike(b) ? a.points.filter((p) => b.contains(p)) : [];
      for (const e of a.edges) results.push(...intersections(e, b));
      return results;
    }
    return simpleIntersection(a, b);
  }
  var Polygon = class _Polygon {
    constructor(...points) {
      this.type = "polygon";
      this.points = points;
    }
    get circumference() {
      if (this.points.length <= 1) return 0;
      let length = Point.distance(this.points[0], last(this.points));
      for (let i = 1; i < this.points.length; ++i) {
        length += Point.distance(this.points[i - 1], this.points[i]);
      }
      return length;
    }
    /**
     * The (signed) area of this polygon. The result is positive if the vertices
     * are ordered clockwise, and negative otherwise.
     */
    get signedArea() {
      const p = this.points;
      const n = p.length;
      let A = p[n - 1].x * p[0].y - p[0].x * p[n - 1].y;
      for (let i = 1; i < n; ++i) {
        A += p[i - 1].x * p[i].y - p[i].x * p[i - 1].y;
      }
      return A / 2;
    }
    get area() {
      return Math.abs(this.signedArea);
    }
    get centroid() {
      const p = this.points;
      const n = p.length;
      let Cx = 0;
      for (let i = 0; i < n; ++i) Cx += p[i].x;
      let Cy = 0;
      for (let i = 0; i < n; ++i) Cy += p[i].y;
      return new Point(Cx / n, Cy / n);
    }
    get edges() {
      const n = this.points.length;
      const edges = [];
      for (let i = 0; i < n; ++i) {
        edges.push(new Segment(this.points[i], this.points[(i + 1) % n]));
      }
      return edges;
    }
    get radius() {
      const c = this.centroid;
      const radii = this.points.map((p) => Point.distance(p, c));
      return Math.max(...radii);
    }
    /** The oriented version of this polygon (vertices in clockwise order). */
    get oriented() {
      if (this.signedArea >= 0) return this;
      const points = [...this.points].reverse();
      return new this.constructor(...points);
    }
    /** Checks if two polygons p1 and p2 collide. */
    static collision(p1, p2) {
      if (p1.points.some((q) => p2.contains(q))) return true;
      if (p2.points.some((q) => p1.contains(q))) return true;
      for (const e1 of p1.edges) {
        for (const e2 of p2.edges) {
          if (intersections(e1, e2)[0]) return true;
        }
      }
      return false;
    }
    /** Creates a regular polygon. */
    static regular(n, radius = 1) {
      const da = TWO_PI / n;
      const a0 = Math.PI / 2 - da / 2;
      const points = tabulate((i) => Point.fromPolar(a0 + da * i, radius), n);
      return new _Polygon(...points);
    }
    /** Interpolates the points of two polygons */
    static interpolate(p1, p2, t = 0.5) {
      const points = p1.points.map(
        (p, i) => Point.interpolate(p, p2.points[i], t)
      );
      return new _Polygon(...points);
    }
    static convexHull(...points) {
      if (points.length <= 3) return new _Polygon(...points);
      const sorted = points.sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
      const sortedReverse = sorted.slice(0).reverse();
      const upper = [];
      const lower = [];
      for (const [source, target] of [[sorted, upper], [sortedReverse, lower]]) {
        for (const p of source) {
          while (target.length >= 2) {
            const p1 = target[target.length - 1];
            const p2 = target[target.length - 2];
            if ((p1.x - p2.x) * (p.y - p2.y) >= (p.x - p2.x) * (p1.y - p2.y)) {
              target.pop();
            } else {
              break;
            }
          }
          target.push(p);
        }
        target.pop();
      }
      return new _Polygon(...upper.concat(lower));
    }
    // ---------------------------------------------------------------------------
    /**
     * Checks if a point p lies inside this polygon, by using a ray-casting
     * algorithm and calculating the number of intersections.
     */
    contains(p) {
      let inside = false;
      for (const e of this.edges) {
        if (e.p1.equals(p) || e.contains(p)) return false;
        if (e.p1.y > p.y === e.p2.y > p.y) continue;
        const det = (e.p2.x - e.p1.x) / (e.p2.y - e.p1.y);
        if (p.x < det * (p.y - e.p1.y) + e.p1.x) inside = !inside;
      }
      return inside;
    }
    at(t) {
      if (t < 0) t += Math.floor(t);
      const offset = t * this.circumference;
      let cum = 0;
      for (const e of this.edges) {
        const l = e.length;
        if (cum + l > offset) return e.at((offset - cum) / l);
        cum += l;
      }
      return this.points[0];
    }
    offset(p) {
      const edges = this.edges;
      const proj = findClosest(p, this.edges) || [this.points[0], 0];
      let offset = 0;
      for (let i = 0; i < proj[1]; ++i) offset += edges[i].length;
      offset += edges[proj[1]].offset(p) * edges[proj[1]].length;
      return offset / this.circumference;
    }
    project(p) {
      const proj = findClosest(p, this.edges);
      return proj ? proj[0] : this.points[0];
    }
    /** Center this polygon on a given point or the origin */
    centerAt(on = ORIGIN) {
      return this.translate(on.subtract(this.centroid));
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return new this.constructor(...this.points.map((p) => p.transform(m)));
    }
    /** Rotates this polygon by a given angle (in radians), optionally around point `center`. */
    rotate(a, center = ORIGIN) {
      if (nearlyEquals(a, 0)) return this;
      const points = this.points.map((p) => p.rotate(a, center));
      return new this.constructor(...points);
    }
    reflect(line) {
      const points = this.points.map((p) => p.reflect(line));
      return new this.constructor(...points);
    }
    scale(sx, sy = sx) {
      const points = this.points.map((p) => p.scale(sx, sy));
      return new this.constructor(...points);
    }
    shift(x, y = x) {
      const points = this.points.map((p) => p.shift(x, y));
      return new this.constructor(...points);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, tolerance, oriented) {
      const n = this.points.length;
      if (n !== other.points.length) return false;
      const p1 = oriented ? this : this.oriented;
      const p2 = oriented ? other : other.oriented;
      for (let offset = 0; offset < n; ++offset) {
        if (p1.points.every((p, i) => p.equals(p2.points[(i + offset) % n], tolerance))) {
          return true;
        }
      }
      return false;
    }
    toString() {
      return `polygon(${this.points.join(",")})`;
    }
  };
  var Polyline = class extends Polygon {
    constructor() {
      super(...arguments);
      this.type = "polyline";
    }
    get circumference() {
      return this.length;
    }
    get length() {
      let length = 0;
      for (let i = 1; i < this.points.length; ++i) {
        length += Point.distance(this.points[i - 1], this.points[i]);
      }
      return length;
    }
    /** @returns {Segment[]} */
    get edges() {
      const edges = [];
      for (let i = 0; i < this.points.length - 1; ++i) {
        edges.push(new Segment(this.points[i], this.points[i + 1]));
      }
      return edges;
    }
    toString() {
      return `polyline(${this.points.join(",")})`;
    }
  };
  var RAD_TO_DEG = 180 / Math.PI;
  var DEG_TO_RAD = Math.PI / 180;
  var Angle = class _Angle {
    constructor(a, b, c) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.type = "angle";
    }
    static fromDegrees(val) {
      return _Angle.fromRadians(val * (Math.PI / 180));
    }
    static fromRadians(val) {
      const p1 = new Point(1, 0);
      const p2 = p1.rotate(val);
      return new _Angle(p1, ORIGIN, p2);
    }
    /** Checks if `a` and `b` are roughly equivalent (by default, within one degree of eachother) */
    static equals(a, b, precision = Math.PI / 360) {
      return nearlyEquals(a.rad, b.rad, precision);
    }
    /** The size, in radians, of this angle. */
    get rad() {
      const phiA = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x);
      const phiC = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x);
      let phi = phiC - phiA;
      if (phi < 0) phi += TWO_PI;
      return phi;
    }
    /** The size, in degrees, of this angle. */
    get deg() {
      return this.rad * 180 / Math.PI;
    }
    /** Checks if this angle is right-angled. */
    get isRight() {
      return nearlyEquals(this.rad, Math.PI / 2, Math.PI / 360);
    }
    /** The bisector of this angle. */
    get bisector() {
      if (this.b.equals(this.a)) return void 0;
      if (this.b.equals(this.c)) return void 0;
      const phiA = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x);
      const phiC = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x);
      let phi = (phiA + phiC) / 2;
      if (phiA > phiC) phi += Math.PI;
      const x = Math.cos(phi) + this.b.x;
      const y = Math.sin(phi) + this.b.y;
      return new Line(this.b, new Point(x, y));
    }
    /** Returns the smaller one of this and its supplementary angle. */
    get sup() {
      return this.rad < Math.PI ? this : new _Angle(this.c, this.b, this.a);
    }
    /** Returns the Arc element corresponding to this angle. */
    get arc() {
      return new Arc(this.b, this.a, this.rad);
    }
    // ---------------------------------------------------------------------------
    /** Radius of the arc or sector representing this angle. */
    get radius() {
      return 24 + 20 * (1 - clamp(this.rad, 0, Math.PI) / Math.PI);
    }
    /** Shape object that can be used to draw this angle. */
    shape(filled = true, radius, round2) {
      if (this.a.equals(this.b) || this.c.equals(this.b)) return new Polygon(ORIGIN);
      const angled = this.isRight && !round2;
      if (!radius) radius = angled ? 20 : this.radius;
      const ba = new Segment(this.b, this.a);
      const a = ba.at(radius / ba.length);
      if (angled) {
        const bc = Point.difference(this.c, this.b).unitVector.scale(radius);
        if (filled) return new Polygon(this.b, a, a.add(bc), this.b.add(bc));
        return new Polyline(a, a.add(bc), this.b.add(bc));
      }
      if (filled) return new Sector(this.b, a, this.rad);
      return new Arc(this.b, a, this.rad);
    }
    // ---------------------------------------------------------------------------
    // These functions are just included for compatibility with GeoPath
    project(p) {
      return this.contains(p) ? p : this.shape(true).project(p);
    }
    at() {
      return this.c;
    }
    offset() {
      return 0;
    }
    contains(p) {
      return this.shape(true).contains(p);
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return new _Angle(this.a.transform(m), this.b.transform(m), this.c.transform(m));
    }
    rotate(a, c) {
      if (nearlyEquals(a, 0)) return this;
      return new _Angle(this.a.rotate(a, c), this.b.rotate(a, c), this.c.rotate(a, c));
    }
    reflect(l) {
      return new _Angle(this.a.reflect(l), this.b.reflect(l), this.c.reflect(l));
    }
    scale(sx, sy = sx) {
      return new _Angle(this.a.scale(sx, sy), this.b.scale(sx, sy), this.c.scale(sx, sy));
    }
    shift(x, y = x) {
      return new _Angle(this.a.shift(x, y), this.b.shift(x, y), this.c.shift(x, y));
    }
    translate(p) {
      return new _Angle(this.a.translate(p), this.b.translate(p), this.c.translate(p));
    }
    equals(a, precision) {
      return _Angle.equals(a, this, precision);
    }
    toString() {
      return `angle(${this.a},${this.b},${this.c})`;
    }
  };
  var CIRCLE_MAGIC = 4 * (Math.sqrt(2) - 1) / 3;

  // content/triangles/functions.ts
  function waitToDraw($step, $geopad, shapes, classes, targets) {
    $geopad.waitForPaths(shapes, {
      onCorrect(path, i) {
        $step.addHint("correct");
        path.$el.addClass(classes[i]);
        path.$el.setAttr("target", targets[i]);
        $step.score("s" + i);
      },
      onIncorrect() {
        $step.addHint("incorrect");
      },
      onHint(path, i) {
        $step.addHint("draw-hint", { force: true });
        path.$el.addClass(classes[i]);
        path.$el.setAttr("target", targets[i]);
        $step.score("s" + i);
      }
    });
  }
  function medians($step) {
    const $geopad = $step.$("x-geopad");
    $geopad.switchTool("line");
    waitToDraw(
      $step,
      $geopad,
      ["segment(a,bc)", "segment(b,ac)", "segment(c,ab)"],
      ["red", "blue", "green"],
      ["ratio", "", ""]
    );
    $step.onScore("s0 s1 s2", () => {
      $geopad.switchTool("move");
      $geopad.on("moveEnd", () => $step.score("move"));
    });
  }
  function circumcircle($step) {
    const $geopad = $step.$("x-geopad");
    $step.onScore("blank-0", () => {
      $geopad.switchTool("perpBisector");
      $geopad.showGesture("a", "c");
    });
    $step.onScore("s0 s1 s2", () => $geopad.switchTool("move"));
    $step.onScore("blank-2", () => $geopad.animateConstruction("circumcircle"));
    waitToDraw(
      $step,
      $geopad,
      [
        "line(a,b).perpendicularBisector",
        "line(a,c).perpendicularBisector",
        "line(b,c).perpendicularBisector"
      ],
      ["red", "blue", "green"],
      ["b-red", "b-blue", "b-green"]
    );
  }
  function incircle($step) {
    const $geopad = $step.$("x-geopad");
    $geopad.switchTool("angleBisector");
    $step.onScore("s0 s1 s2", () => $geopad.switchTool("move"));
    $step.onScore("blank-1", () => $geopad.animateConstruction("incircle"));
    waitToDraw(
      $step,
      $geopad,
      ["xa.bisector", "xb.bisector", "xc.bisector"],
      ["red", "blue", "green"],
      ["b-red", "b-blue", "b-green"]
    );
  }
  function altitudes1($step) {
    const $alt = $step.$$(".altitude");
    $alt[0].enter("draw", 1e3, 1e3);
    $alt[1].enter("draw", 1e3, 1500);
    $alt[2].enter("draw", 1e3, 2e3);
    $step.$("circle.yellow").enter("pop", 400, 2500);
  }
  function midsegments($step) {
    const $geopad = $step.$("x-geopad");
    $geopad.switchTool("line");
    $step.onScore("s0 s1 s2", () => $geopad.switchTool("move"));
    waitToDraw(
      $step,
      $geopad,
      ["segment(p,q)", "segment(p,r)", "segment(q,r)"],
      ["red", "red", "red"],
      ["", "", ""]
    );
  }
  function sssConstruction($step) {
    return __async(this, null, function* () {
      const $geopad = $step.$("x-geopad");
      const model = $geopad.model;
      const getLength = (x) => round(x / 36, 1);
      model.getLength = getLength;
      $geopad.showGesture("point(50,200)", "point(250,200)");
      $geopad.switchTool("line");
      const base = yield $geopad.waitForPath((p) => isLineLike(p) && getLength(p.length) === 6, {
        onBegin: (p) => p.setLabel(`\${getLength(${p.name}.length)||''}`),
        onIncorrect: () => $step.addHint("incorrect")
      });
      $step.score("draw-base");
      base.$el.addClass("green");
      const [b1, b2] = base.components;
      for (const p of base.components) {
        p.lock();
        p.$el.setAttr("target", "base");
      }
      $geopad.switchTool("move");
      yield $step.onScore("next-0");
      $geopad.animatePoint(base.components[0].name, new Point(42, 220));
      $geopad.animatePoint(base.components[1].name, new Point(258, 220));
      $geopad.switchTool("circle");
      const circle1 = yield $geopad.waitForPath((path) => isCircle(path) && getLength(path.r) === 4 && isOneOf(path.c, b1.value, b2.value), {
        onBegin: (p) => p.setLabel(`\${getLength(${p.name}.r)||''}`, void 0, `${p.name}.c.shift(0,-${p.name}.r/2)`),
        onIncorrect: () => $step.addHint("incorrect")
      });
      $step.score("draw-c1");
      circle1.$el.addClass("green light thin");
      circle1.components[1].$el.setAttr("hidden", "hidden");
      const circle2 = yield $geopad.waitForPath((path) => isCircle(path) && getLength(path.r) === 5 && isOneOf(path.c, b1.value, b2.value) && path.c !== circle1.value.c, {
        onBegin: (p) => p.setLabel(`\${getLength(${p.name}.r)||''}`, void 0, `${p.name}.c.shift(0,-${p.name}.r/2)`),
        onIncorrect: () => $step.addHint("incorrect")
      });
      $step.score("draw-c2");
      circle2.$el.addClass("green light thin");
      circle2.components[1].$el.setAttr("hidden", "hidden");
      $geopad.switchTool("move");
      yield $step.onScore("blank-0");
      const i = circle1.components[0] === base.components[1] ? 1 : 0;
      $geopad.drawPoint(
        () => intersections(circle1.value, circle2.value)[i],
        { target: "top", name: "c", interactive: false }
      );
      $geopad.drawPath(
        `segment(${base.components[0].name},c)`,
        { name: "side1", classes: "green" }
      );
      yield $geopad.animateConstruction("side1", 1e3);
      $geopad.drawPath(
        `segment(c,${base.components[1].name})`,
        { name: "side2", classes: "green" }
      );
      yield $geopad.animateConstruction("side2", 1e3);
      yield $step.onScore("blank-1");
      circle1.setValue(() => new Circle(model[circle1.components[0].name], 4 * 36));
      circle2.setValue(() => new Circle(model[circle2.components[0].name], 5 * 36));
      $geopad.animatePoint(base.components[0].name, new Point(42, 150));
      $geopad.animatePoint(base.components[1].name, new Point(258, 150));
      $geopad.drawPoint(
        () => intersections(circle1.value, circle2.value)[1 - i],
        { target: "bottom", name: "d", interactive: false }
      );
      yield $step.onScore("blank-2");
      $geopad.drawPath(
        `polyline(${base.components[0].name},d,${base.components[1].name})`,
        { animated: 1e3, classes: "green" }
      );
    });
  }
  function pythagorasProof($step) {
    const $labels = $step.$$(".label");
    const model = $step.model;
    function updateLabels() {
      $labels[0].setClass(
        "visible",
        $step.scores.has("blank-0") && model.x < 0.1
      );
      $labels[1].setClass(
        "visible",
        $step.scores.has("blank-1") && model.x > 0.9
      );
      $labels[2].setClass(
        "visible",
        $step.scores.has("blank-1") && model.x > 0.9
      );
    }
    model.x = 0;
    const $slider = $step.$(".proof-1 x-slider");
    $slider.on("move", (n) => {
      model.x = n / 100;
      updateLabels();
    });
    $step.onScore("blank-0", () => {
      updateLabels();
      delay(() => $slider.play(), 1e3);
    });
    $step.onScore("blank-1", updateLabels);
    $step.model.set = (n) => $slider.moveTo(n);
    const $geopad = $step.$(".similar-triangle");
    $step.onScore("next-0", () => {
      $geopad.animatePoint("B1", new Point(10, 210), 1e3);
      $geopad.animatePoint("X1", new Point(120, 142), 1e3);
      $geopad.animatePoint("C1", new Point(162, 210), 1e3);
      $geopad.animatePoint("A2", new Point(250, 170), 1e3);
      $geopad.animatePoint("X2", new Point(224, 128), 1e3);
      $geopad.animatePoint("C2", new Point(156, 170), 1e3);
    });
  }
  function pythagoreanTriplesGrid($step) {
    const $geopad = $step.$("x-geopad");
    const found = /* @__PURE__ */ new Set();
    $step.model.watch((m) => {
      const p = m.a;
      const valid = p.x > 0 && p.y > 0 && isInteger(p.length);
      $geopad.setClass("triple", valid);
      if (!valid) return;
      if (found.has(p.x + "-" + p.y)) return;
      $step.score("p" + found.size);
      found.add(p.x + "-" + p.y);
      $geopad.drawPoint(() => p, { classes: "green", interactive: false });
      if (isOneOf(found.size, 1, 6, 12)) $step.addHint("correct");
    });
  }
  function mountains($step) {
    const $geopad = $step.$("x-geopad");
    $step.onScore("blank-0", () => {
      $geopad.shapes.get("angle-a").setLabel("151\xB0");
      $geopad.model.update();
    });
    $step.onScore("blank-1", () => {
      $geopad.shapes.get("angle-b").setLabel("\u03B2 = 6\xB0");
      $geopad.model.update();
    });
    $step.onScore("blank-3 blank-4", () => {
      $geopad.shapes.get("side-d").setLabel("d = 23km");
      $geopad.model.update();
    });
  }
  function applications2($step) {
    $step.$("x-video").on("end", () => $step.score("video"));
  }
  return __toCommonJS(functions_exports);
})();