/* (c) Mathigon, generated by Mathigon Studio */
"use strict";
var StepFunctions = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp(target, key, result);
    return result;
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var __await = function(promise, isYieldStar) {
    this[0] = promise;
    this[1] = isYieldStar;
  };
  var __yieldStar = (value) => {
    var obj = value[__knownSymbol("asyncIterator")], isAwait = false, method, it = {};
    if (obj == null) {
      obj = value[__knownSymbol("iterator")]();
      method = (k) => it[k] = (x) => obj[k](x);
    } else {
      obj = obj.call(value);
      method = (k) => it[k] = (v) => {
        if (isAwait) {
          isAwait = false;
          if (k === "throw") throw v;
          return v;
        }
        isAwait = true;
        return {
          done: false,
          value: new __await(new Promise((resolve) => {
            var x = obj[k](v);
            if (!(x instanceof Object)) __typeError("Object expected");
            resolve(x);
          }), 1)
        };
      };
    }
    return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
      throw x;
    }, "return" in obj && method("return"), it;
  };

  // content/solids/functions.ts
  var functions_exports = {};
  __export(functions_exports, {
    cubeDraw: () => cubeDraw,
    cubeNetDraw: () => cubeNetDraw,
    cubeTable: () => cubeTable,
    cuboidParts: () => cuboidParts,
    dieFaces1: () => dieFaces1,
    dieFaces2: () => dieFaces2,
    honeycombIntro: () => honeycombIntro,
    net1: () => net1,
    netsProperties: () => netsProperties,
    painting1: () => painting1,
    polyIdent: () => polyIdent,
    polyParts: () => polyParts,
    sidesRotation: () => sidesRotation,
    soccerNet: () => soccerNet,
    templeDisplay1: () => templeDisplay1,
    templeDisplay2: () => templeDisplay2,
    templeFilling: () => templeFilling,
    voxelBuilderQuestion: () => voxelBuilderQuestion,
    voxelSurface: () => voxelSurface
  });

  // node_modules/@mathigon/core/dist/index.esm.js
  function uid(n = 10) {
    return Math.random().toString(36).substr(2, n);
  }
  function isOneOf(x, ...values) {
    return values.includes(x);
  }
  var defaultMerge = (a2, b2) => a2.concat(b2);
  function deepExtend(obj1, obj2, arrayMergeFn = defaultMerge) {
    for (const i of Object.keys(obj2)) {
      if (i in obj1 && Array.isArray(obj1[i]) && Array.isArray(obj2[i])) {
        obj1[i] = arrayMergeFn(obj1[i], obj2[i]);
      } else if (i in obj1 && obj1[i] instanceof Object && obj2[i] instanceof Object) {
        deepExtend(obj1[i], obj2[i]);
      } else {
        obj1[i] = obj2[i];
      }
    }
  }
  function delay(fn, t = 0) {
    if (t) {
      return +setTimeout(fn, t);
    } else {
      fn();
      return 0;
    }
  }
  function defer() {
    let resolve = () => void 0;
    let reject = () => void 0;
    const promise = new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    });
    promise.catch((error) => error);
    return { promise, resolve, reject };
  }
  var CacheError = class extends Error {
    constructor(data) {
      super("[Cache Error]");
      this.data = data;
    }
  };
  function cache(fn) {
    const cached = /* @__PURE__ */ new Map();
    return function(...args) {
      const argString = args.join("--");
      if (!cached.has(argString)) {
        try {
          cached.set(argString, fn(...args));
        } catch (e2) {
          cached.set(argString, new CacheError(e2));
        }
      }
      const value = cached.get(argString);
      if (value instanceof CacheError) throw value.data;
      return value;
    };
  }
  function throttle(fn, t = 0, forceDelay = false) {
    let delay2 = false;
    let repeat2 = false;
    return (...args) => {
      if (delay2) {
        repeat2 = true;
      } else {
        if (forceDelay) {
          repeat2 = true;
        } else {
          fn(...args);
        }
        delay2 = true;
        setTimeout(() => {
          if (repeat2) fn(...args);
          delay2 = repeat2 = false;
        }, t);
      }
    };
  }
  function reviver(allowed) {
    return function(key, value) {
      if (!key || Array.isArray(this) || allowed.includes(key)) return value;
    };
  }
  function safeToJSON(str, fallback, allowedKeys) {
    if (!str) return fallback;
    try {
      return JSON.parse(str, allowedKeys ? reviver(allowedKeys) : void 0) || fallback;
    } catch (e2) {
      return fallback;
    }
  }
  function repeat(value, n) {
    return new Array(n).fill(value);
  }
  function repeat2D(value, x, y) {
    const result = [];
    for (let i = 0; i < x; ++i) {
      result.push(repeat(value, y));
    }
    return result;
  }
  function tabulate(fn, n) {
    const result = [];
    for (let i = 0; i < n; ++i) {
      result.push(fn(i));
    }
    return result;
  }
  function tabulate2D(fn, x, y) {
    const result = [];
    for (let i = 0; i < x; ++i) {
      const row = [];
      for (let j = 0; j < y; ++j) {
        row.push(fn(i, j));
      }
      result.push(row);
    }
    return result;
  }
  function list(a2, b2, step = 1) {
    const arr = [];
    if (b2 === void 0 && a2 >= 0) {
      for (let i = 0; i < a2; i += step) arr.push(i);
    } else if (b2 === void 0) {
      for (let i = 0; i > a2; i -= step) arr.push(i);
    } else if (a2 <= b2) {
      for (let i = a2; i <= b2; i += step) arr.push(i);
    } else {
      for (let i = a2; i >= b2; i -= step) arr.push(i);
    }
    return arr;
  }
  function last(array, i = 0) {
    return array[array.length - 1 - i];
  }
  function total(array) {
    return array.reduce((t, v) => t + v, 0);
  }
  function loop(array) {
    let i = 0;
    return () => array[i++ % array.length];
  }
  function unique(array) {
    return array.filter((a2, i) => array.indexOf(a2) === i);
  }
  function flatten(array) {
    return array.reduce((a2, b2) => a2.concat(Array.isArray(b2) ? flatten(b2) : b2), []);
  }
  function chunk(array, n) {
    const chunks = [];
    for (let i = 0; i < array.length; i += n) {
      chunks.push(array.slice(i, i + n));
    }
    return chunks;
  }
  function words(str, divider = /\s+/) {
    if (!str) return [];
    return str.trim().split(divider);
  }
  function toCamelCase(str) {
    return str.toLowerCase().replace(/^-/, "").replace(/-(.)/g, (_, g) => g.toUpperCase());
  }
  var EventTarget = class {
    constructor() {
      this.events = /* @__PURE__ */ new Map();
    }
    /** Adds an event listener for one or more events. */
    on(events, fn) {
      for (const e2 of words(events)) {
        if (!this.events.has(e2)) this.events.set(e2, []);
        this.events.get(e2).push(fn);
      }
    }
    /** Adds a one-time event listener to one or more events. */
    one(events, fn) {
      const callback = (e2) => {
        this.off(events, callback);
        fn(e2);
      };
      this.on(events, callback);
    }
    /** Removes an event listener from one or more events. */
    off(events, fn) {
      for (const e2 of words(events)) {
        if (this.events.has(e2)) {
          this.events.set(e2, this.events.get(e2).filter((x) => x !== fn));
        }
      }
    }
    /** Triggers one or more events, and executes all bound event listeners. */
    trigger(events, arg) {
      for (const e2 of words(events)) {
        if (this.events.has(e2)) {
          for (const callback of this.events.get(e2)) {
            callback(arg);
          }
        }
      }
    }
  };

  // node_modules/@mathigon/fermat/dist/index.esm.js
  var __defProp2 = Object.defineProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var PRECISION = 1e-6;
  function nearlyEquals(a2, b2, t = PRECISION) {
    if (isNaN(a2) || isNaN(b2)) return false;
    return Math.abs(a2 - b2) < t;
  }
  function isBetween(value, a2, b2, t = PRECISION) {
    if (a2 > b2) [a2, b2] = [b2, a2];
    return value > a2 + t && value < b2 - t;
  }
  function round(n, precision = 0) {
    const factor = Math.pow(10, precision);
    return Math.round(n * factor) / factor;
  }
  function roundTo(n, increment = 1) {
    return Math.round(n / increment) * increment;
  }
  function clamp(x, min = -Infinity, max = Infinity) {
    return Math.min(max, Math.max(min, x));
  }
  function lerp(a2, b2, t = 0.5) {
    return a2 + (b2 - a2) * t;
  }
  function square(x) {
    return x * x;
  }
  function mod(a2, m) {
    return (a2 % m + m) % m;
  }
  function subsets(array, length = 0) {
    const copy = array.slice(0);
    const results = subsetsHelper(copy);
    return length ? results.filter((x) => x.length === length) : results;
  }
  function subsetsHelper(array) {
    if (array.length === 1) return [[], array];
    const last2 = array.pop();
    const subsets2 = subsetsHelper(array);
    const result = [];
    for (const s of subsets2) {
      result.push(s, [...s, last2]);
    }
    return result;
  }
  var matrix_exports = {};
  __export2(matrix_exports, {
    determinant: () => determinant,
    fill: () => fill,
    identity: () => identity,
    inverse: () => inverse,
    product: () => product,
    reflection: () => reflection,
    rotation: () => rotation,
    scalarProduct: () => scalarProduct,
    shear: () => shear,
    sum: () => sum,
    transpose: () => transpose
  });
  function fill(value, x, y) {
    return repeat2D(value, x, y);
  }
  function identity(n = 2) {
    const x = fill(0, n, n);
    for (let i = 0; i < n; ++i) x[i][i] = 1;
    return x;
  }
  function rotation(angle) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);
    return [[cos, -sin], [sin, cos]];
  }
  function shear(lambda) {
    return [[1, lambda], [0, 1]];
  }
  function reflection(angle) {
    const sin = Math.sin(2 * angle);
    const cos = Math.cos(2 * angle);
    return [[cos, sin], [sin, -cos]];
  }
  function sum(...matrices) {
    const [M1, ...rest] = matrices;
    const M2 = rest.length > 1 ? sum(...rest) : rest[0];
    if (M1.length !== M2.length || M1[0].length !== M2[0].length) {
      throw new Error("Matrix sizes don\u2019t match");
    }
    const S = [];
    for (let i = 0; i < M1.length; ++i) {
      const row = [];
      for (let j = 0; j < M1[i].length; ++j) {
        row.push(M1[i][j] + M2[i][j]);
      }
      S.push(row);
    }
    return S;
  }
  function scalarProduct(M, v) {
    return M.map((row) => row.map((x) => x * v));
  }
  function product(...matrices) {
    const [M1, ...rest] = matrices;
    const M2 = rest.length > 1 ? product(...rest) : rest[0];
    if (M1[0].length !== M2.length) {
      throw new Error("Matrix sizes don\u2019t match.");
    }
    const P2 = [];
    for (let i = 0; i < M1.length; ++i) {
      const row = [];
      for (let j = 0; j < M2[0].length; ++j) {
        let value = 0;
        for (let k = 0; k < M2.length; ++k) {
          value += M1[i][k] * M2[k][j];
        }
        row.push(value);
      }
      P2.push(row);
    }
    return P2;
  }
  function transpose(M) {
    const T = [];
    for (let j = 0; j < M[0].length; ++j) {
      const row = [];
      for (let i = 0; i < M.length; ++i) {
        row.push(M[i][j]);
      }
      T.push(row);
    }
    return T;
  }
  function determinant(M) {
    if (M.length !== M[0].length) throw new Error("Not a square matrix.");
    const n = M.length;
    if (n === 1) return M[0][0];
    if (n === 2) return M[0][0] * M[1][1] - M[0][1] * M[1][0];
    let det = 0;
    for (let j = 0; j < n; ++j) {
      let diagLeft = M[0][j];
      let diagRight = M[0][j];
      for (let i = 1; i < n; ++i) {
        diagRight *= M[i][(j + i) % n];
        diagLeft *= M[i][(j - i + n) % n];
      }
      det += diagRight - diagLeft;
    }
    return det;
  }
  function inverse(M) {
    const n = M.length;
    if (n !== M[0].length) throw new Error("Not a square matrix.");
    const I = identity(n);
    const C = tabulate2D((x, y) => M[x][y], n, n);
    for (let i = 0; i < n; ++i) {
      let e2 = C[i][i];
      if (nearlyEquals(e2, 0)) {
        for (let ii = i + 1; ii < n; ++ii) {
          if (C[ii][i] !== 0) {
            for (let j = 0; j < n; ++j) {
              [C[ii][j], C[i][j]] = [C[i][j], C[ii][j]];
              [I[ii][j], I[i][j]] = [I[i][j], I[ii][j]];
            }
            break;
          }
        }
        e2 = C[i][i];
        if (nearlyEquals(e2, 0)) throw new Error("Matrix not invertible.");
      }
      for (let j = 0; j < n; ++j) {
        C[i][j] = C[i][j] / e2;
        I[i][j] = I[i][j] / e2;
      }
      for (let ii = 0; ii < n; ++ii) {
        if (ii === i) continue;
        const f = C[ii][i];
        for (let j = 0; j < n; ++j) {
          C[ii][j] -= f * C[i][j];
          I[ii][j] -= f * I[i][j];
        }
      }
    }
    return I;
  }
  var random_exports = {};
  __export2(random_exports, {
    bernoulli: () => bernoulli,
    binomial: () => binomial2,
    cauchy: () => cauchy,
    chiCDF: () => chiCDF,
    exponential: () => exponential,
    find: () => find,
    geometric: () => geometric,
    integer: () => integer,
    integrate: () => integrate,
    normal: () => normal,
    normalPDF: () => normalPDF,
    poisson: () => poisson,
    shuffle: () => shuffle,
    smart: () => smart,
    uniform: () => uniform,
    weighted: () => weighted
  });
  function shuffle(a2) {
    a2 = a2.slice(0);
    for (let i = a2.length - 1; i > 0; --i) {
      const j = Math.floor(Math.random() * (i + 1));
      [a2[i], a2[j]] = [a2[j], a2[i]];
    }
    return a2;
  }
  function integer(a2, b2) {
    const start = b2 === void 0 ? 0 : a2;
    const length = b2 === void 0 ? a2 : b2 - a2 + 1;
    return start + Math.floor(length * Math.random());
  }
  function weighted(weights) {
    const x = Math.random() * total(weights);
    let cum = 0;
    return weights.findIndex((w) => (cum += w) >= x);
  }
  function find(items) {
    return items[Math.floor(items.length * Math.random())];
  }
  var SMART_RANDOM_CACHE = /* @__PURE__ */ new Map();
  function smart(n, id) {
    if (!id) id = uid();
    if (!SMART_RANDOM_CACHE.has(id)) SMART_RANDOM_CACHE.set(id, repeat(1, n));
    const cache2 = SMART_RANDOM_CACHE.get(id);
    const x = weighted(cache2.map((x2) => x2 * x2));
    cache2[x] -= 1;
    if (cache2[x] <= 0) SMART_RANDOM_CACHE.set(id, cache2.map((x2) => x2 + 1));
    return x;
  }
  function bernoulli(p = 0.5) {
    return Math.random() < p ? 1 : 0;
  }
  function binomial2(n = 1, p = 0.5) {
    let t = 0;
    for (let i = 0; i < n; ++i) t += bernoulli(p);
    return t;
  }
  function poisson(l = 1) {
    if (l <= 0) return 0;
    const L = Math.exp(-l);
    let p = 1;
    let k = 0;
    for (; p > L; ++k) p *= Math.random();
    return k - 1;
  }
  function uniform(a2 = 0, b2 = 1) {
    return a2 + (b2 - a2) * Math.random();
  }
  function normal(m = 0, v = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const rand = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return rand * Math.sqrt(v) + m;
  }
  function exponential(l = 1) {
    return l <= 0 ? 0 : -Math.log(Math.random()) / l;
  }
  function geometric(p = 0.5) {
    if (p <= 0 || p > 1) return void 0;
    return Math.floor(Math.log(Math.random()) / Math.log(1 - p));
  }
  function cauchy() {
    let rr;
    let v1;
    let v2;
    do {
      v1 = 2 * Math.random() - 1;
      v2 = 2 * Math.random() - 1;
      rr = v1 * v1 + v2 * v2;
    } while (rr >= 1);
    return v1 / v2;
  }
  function normalPDF(x, m = 1, v = 0) {
    return Math.exp(-((x - m) ** 2) / (2 * v)) / Math.sqrt(2 * Math.PI * v);
  }
  var G = 7;
  var P = [
    0.9999999999998099,
    676.5203681218851,
    -1259.1392167224028,
    771.3234287776531,
    -176.6150291621406,
    12.507343278686905,
    -0.13857109526572012,
    9984369578019572e-21,
    15056327351493116e-23
  ];
  function gamma(z) {
    if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    z -= 1;
    let x = P[0];
    for (let i = 1; i < G + 2; i++) x += P[i] / (z + i);
    const t = z + G + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
  }
  function integrate(fn, xMin, xMax, dx = 1) {
    let result = 0;
    for (let x = xMin; x < xMax; x += dx) {
      result += fn(x) * dx || 0;
    }
    return result;
  }
  function chiCDF(chi, deg) {
    const int = integrate((t) => Math.pow(t, (deg - 2) / 2) * Math.exp(-t / 2), 0, chi);
    return 1 - int / Math.pow(2, deg / 2) / gamma(deg / 2);
  }
  var regression_exports = {};
  __export2(regression_exports, {
    bestPolynomial: () => bestPolynomial,
    coefficient: () => coefficient,
    exponential: () => exponential2,
    linear: () => linear,
    logarithmic: () => logarithmic,
    polynomial: () => polynomial2,
    power: () => power
  });
  function evaluatePolynomial(regression, x) {
    let xs = 1;
    let t = regression[0];
    for (let i = 1; i < regression.length; ++i) {
      xs *= x;
      t += xs * regression[i];
    }
    return t;
  }
  function linear(data, throughOrigin = false) {
    let sX = 0;
    let sY = 0;
    let sXX = 0;
    let sXY = 0;
    const len = data.length;
    for (let n = 0; n < len; n++) {
      sX += data[n][0];
      sY += data[n][1];
      sXX += data[n][0] * data[n][0];
      sXY += data[n][0] * data[n][1];
    }
    if (throughOrigin) {
      const gradient2 = sXY / sXX;
      return [0, gradient2];
    }
    const gradient = (len * sXY - sX * sY) / (len * sXX - sX * sX);
    const intercept = sY / len - gradient * sX / len;
    return [intercept, gradient];
  }
  function exponential2(data) {
    const sum2 = [0, 0, 0, 0, 0, 0];
    for (const d2 of data) {
      sum2[0] += d2[0];
      sum2[1] += d2[1];
      sum2[2] += d2[0] * d2[0] * d2[1];
      sum2[3] += d2[1] * Math.log(d2[1]);
      sum2[4] += d2[0] * d2[1] * Math.log(d2[1]);
      sum2[5] += d2[0] * d2[1];
    }
    const denominator = sum2[1] * sum2[2] - sum2[5] * sum2[5];
    const a2 = Math.exp((sum2[2] * sum2[3] - sum2[5] * sum2[4]) / denominator);
    const b2 = (sum2[1] * sum2[4] - sum2[5] * sum2[3]) / denominator;
    return [a2, b2];
  }
  function logarithmic(data) {
    const sum2 = [0, 0, 0, 0];
    const len = data.length;
    for (const d2 of data) {
      sum2[0] += Math.log(d2[0]);
      sum2[1] += d2[1] * Math.log(d2[0]);
      sum2[2] += d2[1];
      sum2[3] += Math.pow(Math.log(d2[0]), 2);
    }
    const b2 = (len * sum2[1] - sum2[2] * sum2[0]) / (len * sum2[3] - sum2[0] * sum2[0]);
    const a2 = (sum2[2] - b2 * sum2[0]) / len;
    return [a2, b2];
  }
  function power(data) {
    const sum2 = [0, 0, 0, 0];
    const len = data.length;
    for (const d2 of data) {
      sum2[0] += Math.log(d2[0]);
      sum2[1] += Math.log(d2[1]) * Math.log(d2[0]);
      sum2[2] += Math.log(d2[1]);
      sum2[3] += Math.pow(Math.log(d2[0]), 2);
    }
    const b2 = (len * sum2[1] - sum2[2] * sum2[0]) / (len * sum2[3] - sum2[0] * sum2[0]);
    const a2 = Math.exp((sum2[2] - b2 * sum2[0]) / len);
    return [a2, b2];
  }
  function polynomial2(data, order = 2) {
    const X = data.map((d2) => list(order + 1).map((p) => Math.pow(d2[0], p)));
    const XT = transpose(X);
    const y = data.map((d2) => [d2[1]]);
    const XTX = product(XT, X);
    const inv = inverse(XTX);
    const r = product(inv, XT, y);
    return r.map((x) => x[0]);
  }
  function coefficient(data, fn) {
    const total4 = data.reduce((sum2, d2) => sum2 + d2[1], 0);
    const mean2 = total4 / data.length;
    const ssyy = data.reduce((sum2, d2) => sum2 + (d2[1] - mean2) ** 2, 0);
    const sse = data.reduce((sum2, d2) => sum2 + (d2[1] - fn(d2[0])) ** 2, 0);
    return 1 - sse / ssyy;
  }
  function bestPolynomial(data, threshold = 0.85, maxOrder = 8) {
    if (data.length <= 1) return void 0;
    for (let i = 1; i < maxOrder; ++i) {
      const reg = polynomial2(data, i);
      const fn = (x) => evaluatePolynomial(reg, x);
      const coeff = coefficient(data, fn);
      if (coeff >= threshold) return { order: i, coefficients: reg, fn };
    }
    return void 0;
  }

  // node_modules/@mathigon/euclid/dist/index.esm.js
  var TWO_PI = 2 * Math.PI;
  function rad(p, c2) {
    const a2 = Math.atan2(p.y - (c2 ? c2.y : 0), p.x - (c2 ? c2.x : 0));
    return mod(a2, TWO_PI);
  }
  function findClosest(p, items) {
    let q = void 0;
    let d2 = Infinity;
    let index = -1;
    for (const [i, e2] of items.entries()) {
      const q1 = e2.project(p);
      const d1 = Point.distance(p, q1);
      if (d1 < d2) {
        q = q1;
        d2 = d1;
        index = i;
      }
    }
    return q ? [q, index] : void 0;
  }
  var Point = class _Point {
    constructor(x = 0, y = 0) {
      this.x = x;
      this.y = y;
      this.type = "point";
    }
    get unitVector() {
      if (nearlyEquals(this.length, 0)) return new _Point(1, 0);
      return this.scale(1 / this.length);
    }
    get length() {
      return Math.sqrt(this.x ** 2 + this.y ** 2);
    }
    get inverse() {
      return new _Point(-this.x, -this.y);
    }
    get flip() {
      return new _Point(this.y, this.x);
    }
    get perpendicular() {
      return new _Point(-this.y, this.x);
    }
    get array() {
      return [this.x, this.y];
    }
    /** Finds the perpendicular distance between this point and a line. */
    distanceFromLine(l) {
      return _Point.distance(this, l.project(this));
    }
    /** Clamps this point to specific bounds. */
    clamp(bounds, padding = 0) {
      const x = clamp(this.x, bounds.xMin + padding, bounds.xMax - padding);
      const y = clamp(this.y, bounds.yMin + padding, bounds.yMax - padding);
      return new _Point(x, y);
    }
    changeCoordinates(originCoords, targetCoords) {
      const x = targetCoords.xMin + (this.x - originCoords.xMin) / originCoords.dx * targetCoords.dx;
      const y = targetCoords.yMin + (this.y - originCoords.yMin) / originCoords.dy * targetCoords.dy;
      return new _Point(x, y);
    }
    add(p) {
      return _Point.sum(this, p);
    }
    subtract(p) {
      return _Point.difference(this, p);
    }
    round(inc = 1) {
      return new _Point(roundTo(this.x, inc), roundTo(this.y, inc));
    }
    floor() {
      return new _Point(Math.floor(this.x), Math.floor(this.y));
    }
    mod(x, y = x) {
      return new _Point(this.x % x, this.y % y);
    }
    angle(c2 = ORIGIN) {
      return rad(this, c2);
    }
    // Snap to the x or y values of another point
    snap(p, tolerance = 5) {
      if (nearlyEquals(this.x, p.x, tolerance)) return new _Point(p.x, this.y);
      if (nearlyEquals(this.y, p.y, tolerance)) return new _Point(this.x, p.y);
      return this;
    }
    /** Calculates the average of multiple points. */
    static average(...points) {
      const x = total(points.map((p) => p.x)) / points.length;
      const y = total(points.map((p) => p.y)) / points.length;
      return new _Point(x, y);
    }
    /** Calculates the dot product of two points p1 and p2. */
    static dot(p1, p2) {
      return p1.x * p2.x + p1.y * p2.y;
    }
    static sum(p1, p2) {
      return new _Point(p1.x + p2.x, p1.y + p2.y);
    }
    static difference(p1, p2) {
      return new _Point(p1.x - p2.x, p1.y - p2.y);
    }
    /** Returns the Euclidean distance between two points p1 and p2. */
    static distance(p1, p2) {
      return Math.sqrt(square(p1.x - p2.x) + square(p1.y - p2.y));
    }
    /** Returns the Manhattan distance between two points p1 and p2. */
    static manhattan(p1, p2) {
      return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
    }
    /** Interpolates two points p1 and p2 by a factor of t. */
    static interpolate(p1, p2, t = 0.5) {
      return new _Point(lerp(p1.x, p2.x, t), lerp(p1.y, p2.y, t));
    }
    /** Interpolates a list of multiple points. */
    static interpolateList(points, t = 0.5) {
      const n = points.length - 1;
      const a2 = Math.floor(clamp(t, 0, 1) * n);
      return _Point.interpolate(points[a2], points[a2 + 1], n * t - a2);
    }
    /** Creates a point from polar coordinates. */
    static fromPolar(angle, r = 1) {
      return new _Point(r * Math.cos(angle), r * Math.sin(angle));
    }
    static random(b2) {
      const x = random_exports.uniform(b2.xMin, b2.xMax);
      const y = random_exports.uniform(b2.yMin, b2.yMax);
      return new _Point(x, y);
    }
    static equals(p1, p2, precision) {
      return nearlyEquals(p1.x, p2.x, precision) && nearlyEquals(p1.y, p2.y, precision);
    }
    /** Check if p1, p2 and p3 lie on a straight line. */
    static colinear(p1, p2, p3, tolerance) {
      const dx1 = p1.x - p2.x;
      const dy1 = p1.y - p2.y;
      const dx2 = p2.x - p3.x;
      const dy2 = p2.y - p3.y;
      return nearlyEquals(dx1 * dy2, dx2 * dy1, tolerance);
    }
    // ---------------------------------------------------------------------------
    /** Transforms this point using a 2x3 matrix m. */
    transform(m) {
      const x = m[0][0] * this.x + m[0][1] * this.y + m[0][2];
      const y = m[1][0] * this.x + m[1][1] * this.y + m[1][2];
      return new _Point(x, y);
    }
    /** Rotates this point by a given angle (in radians) around point `c`. */
    rotate(angle, c2 = ORIGIN) {
      if (nearlyEquals(angle, 0)) return this;
      const x0 = this.x - c2.x;
      const y0 = this.y - c2.y;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const x = x0 * cos - y0 * sin + c2.x;
      const y = x0 * sin + y0 * cos + c2.y;
      return new _Point(x, y);
    }
    /** Reflects this point across a line l. */
    reflect(l) {
      const v = l.p2.x - l.p1.x;
      const w = l.p2.y - l.p1.y;
      const x0 = this.x - l.p1.x;
      const y0 = this.y - l.p1.y;
      const mu = (v * y0 - w * x0) / (v * v + w * w);
      const x = this.x + 2 * mu * w;
      const y = this.y - 2 * mu * v;
      return new _Point(x, y);
    }
    scale(sx, sy = sx) {
      return new _Point(this.x * sx, this.y * sy);
    }
    shift(x, y = x) {
      return new _Point(this.x + x, this.y + y);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, precision) {
      return _Point.equals(this, other, precision);
    }
    toString() {
      return `point(${this.x},${this.y})`;
    }
  };
  var ORIGIN = new Point(0, 0);
  function isPolygonLike(shape) {
    return ["polygon", "polyline", "rectangle", "triangle"].includes(shape.type);
  }
  function isPolygon(shape) {
    return ["polygon", "triangle"].includes(shape.type);
  }
  function isPolyline(shape) {
    return shape.type === "polyline";
  }
  function isRectangle(shape) {
    return shape.type === "rectangle";
  }
  function isLineLike(shape) {
    return ["line", "ray", "segment"].includes(shape.type);
  }
  function isLine(shape) {
    return shape.type === "line";
  }
  function isRay(shape) {
    return shape.type === "ray";
  }
  function isSegment(shape) {
    return shape.type === "segment";
  }
  function isCircle(shape) {
    return shape.type === "circle";
  }
  function isEllipse(shape) {
    return shape.type === "ellipse";
  }
  function isArc(shape) {
    return shape.type === "arc";
  }
  function isSector(shape) {
    return shape.type === "sector";
  }
  function isAngle(shape) {
    return shape.type === "angle";
  }
  var Line = class _Line {
    constructor(p1, p2) {
      this.p1 = p1;
      this.p2 = p2;
      this.type = "line";
    }
    /* The distance between the two points defining this line. */
    get length() {
      return Point.distance(this.p1, this.p2);
    }
    /* The squared distance between the two points defining this line. */
    get lengthSquared() {
      return (this.p1.x - this.p2.x) ** 2 + (this.p1.y - this.p2.y) ** 2;
    }
    /** The midpoint of this line. */
    get midpoint() {
      return Point.average(this.p1, this.p2);
    }
    /** The slope of this line. */
    get slope() {
      return (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x);
    }
    /** The y-axis intercept of this line. */
    get intercept() {
      return this.p1.y - this.slope * this.p1.x;
    }
    /** The angle formed between this line and the x-axis. */
    get angle() {
      return rad(this.p2, this.p1);
    }
    /** The point representing a unit vector along this line. */
    get unitVector() {
      return this.p2.subtract(this.p1).unitVector;
    }
    /** The point representing the perpendicular vector of this line. */
    get perpendicularVector() {
      return new Point(this.p2.y - this.p1.y, this.p1.x - this.p2.x).unitVector;
    }
    /** Finds the line parallel to this one, going through point p. */
    parallel(p) {
      return new _Line(p, p.add(this.p2).subtract(this.p1));
    }
    /** Finds the line perpendicular to this one, going through point p. */
    perpendicular(p) {
      const q = this.line.project(p);
      if (Point.equals(p, q)) return new _Line(q, q.add(this.perpendicularVector.scale(this.length / 2)));
      return new _Line(q, p);
    }
    /** The perpendicular bisector of this line. */
    get perpendicularBisector() {
      return this.perpendicular(this.midpoint);
    }
    /** Squared distance between a point and a line. */
    distanceSquared(p) {
      const proj = this.project(p);
      return (p.x - proj.x) ** 2 + (p.y - proj.y) ** 2;
    }
    get line() {
      return this.type === "line" ? this : new _Line(this.p1, this.p2);
    }
    get ray() {
      return isRay(this) ? this : new Ray(this.p1, this.p2);
    }
    get segment() {
      return isSegment(this) ? this : new Segment(this.p1, this.p2);
    }
    // ---------------------------------------------------------------------------
    /** Signed distance along the line (opposite of .at()). */
    offset(p) {
      const a2 = Point.difference(this.p2, this.p1);
      const b2 = Point.difference(p, this.p1);
      return Point.dot(a2, b2) / this.lengthSquared;
    }
    /** Projects a point `p` onto this line. */
    project(p) {
      return this.at(this.offset(p));
    }
    /** Returns which side of this line a point p is on (or 0 on the line). */
    side(p, tolerance) {
      const a2 = Point.difference(this.p2, this.p1);
      const b2 = Point.difference(p, this.p1);
      const d2 = b2.x * a2.y - b2.y * a2.x;
      return nearlyEquals(d2, 0, tolerance) ? 0 : Math.sign(d2);
    }
    /** Checks if a point p lies on this line. */
    contains(p, tolerance) {
      return this.side(p, tolerance) === 0;
    }
    /** Gets the point at a specific offset along the line (opposite of .offset()). */
    at(t) {
      return Point.interpolate(this.p1, this.p2, t);
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return new this.constructor(this.p1.transform(m), this.p2.transform(m));
    }
    /** Rotates this line by a given angle (in radians), optionally around point `c`. */
    rotate(a2, c2 = ORIGIN) {
      if (nearlyEquals(a2, 0)) return this;
      return new this.constructor(this.p1.rotate(a2, c2), this.p2.rotate(a2, c2));
    }
    reflect(l) {
      return new this.constructor(this.p1.reflect(l), this.p2.reflect(l));
    }
    scale(sx, sy = sx) {
      return new this.constructor(this.p1.scale(sx, sy), this.p2.scale(sx, sy));
    }
    shift(x, y = x) {
      return new this.constructor(this.p1.shift(x, y), this.p2.shift(x, y));
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, tolerance) {
      return this.contains(other.p1, tolerance) && this.contains(other.p2, tolerance);
    }
    toString() {
      return `line(${this.p1},${this.p2})`;
    }
  };
  var Ray = class extends Line {
    constructor() {
      super(...arguments);
      this.type = "ray";
    }
    equals(other, tolerance) {
      if (other.type !== "ray") return false;
      if (!this.p1.equals(other.p1, tolerance)) return false;
      if (this.p2.equals(other.p2, tolerance)) return true;
      return other.contains(this.p2, tolerance) || this.contains(other.p2, tolerance);
    }
    contains(p, tolerance) {
      if (!super.contains(p, tolerance)) return false;
      const offset = this.offset(p);
      return nearlyEquals(offset, 0, tolerance) || offset > 0;
    }
    toString() {
      return `ray(${this.p1},${this.p2})`;
    }
  };
  var Segment = class _Segment extends Line {
    constructor() {
      super(...arguments);
      this.type = "segment";
    }
    contains(p, tolerance) {
      if (!super.contains(p, tolerance)) return false;
      if (this.p1.equals(p, tolerance) || this.p2.equals(p, tolerance)) return true;
      if (nearlyEquals(this.p1.x, this.p2.x, tolerance)) {
        return isBetween(p.y, this.p1.y, this.p2.y);
      } else {
        return isBetween(p.x, this.p1.x, this.p2.x);
      }
    }
    project(p) {
      const a2 = Point.difference(this.p2, this.p1);
      const b2 = Point.difference(p, this.p1);
      const q = clamp(Point.dot(a2, b2) / this.lengthSquared, 0, 1);
      return this.p1.add(a2.scale(q));
    }
    /** Contracts (or expands) a line by a specific ratio. */
    contract(x) {
      return new _Segment(this.at(x), this.at(1 - x));
    }
    equals(other, tolerance, oriented = false) {
      if (other.type !== "segment") return false;
      return this.p1.equals(other.p1, tolerance) && this.p2.equals(other.p2, tolerance) || !oriented && this.p1.equals(other.p2, tolerance) && this.p2.equals(other.p1, tolerance);
    }
    toString() {
      return `segment(${this.p1},${this.p2})`;
    }
  };
  var Circle = class _Circle {
    constructor(c2 = ORIGIN, r = 1) {
      this.c = c2;
      this.r = r;
      this.type = "circle";
    }
    /** The length of the circumference of this circle. */
    get circumference() {
      return TWO_PI * this.r;
    }
    /** The area of this circle. */
    get area() {
      return Math.PI * this.r ** 2;
    }
    get arc() {
      const start = this.c.shift(this.r, 0);
      return new Arc(this.c, start, TWO_PI);
    }
    tangentAt(t) {
      const p1 = this.at(t);
      const p2 = this.c.rotate(Math.PI / 2, p1);
      return new Line(p1, p2);
    }
    collision(r) {
      const tX = this.c.x < r.p.x ? r.p.x : this.c.x > r.p.x + r.w ? r.p.x + r.w : this.c.x;
      const tY = this.c.y < r.p.y ? r.p.y : this.c.y > r.p.y + r.h ? r.p.y + r.h : this.c.y;
      const d2 = Point.distance(this.c, new Point(tX, tY));
      return d2 <= this.r;
    }
    // ---------------------------------------------------------------------------
    project(p) {
      const proj = p.subtract(this.c).unitVector.scale(this.r);
      return Point.sum(this.c, proj);
    }
    at(t) {
      const a2 = TWO_PI * t;
      return this.c.shift(this.r * Math.cos(a2), this.r * Math.sin(a2));
    }
    offset(p) {
      return rad(p, this.c) / TWO_PI;
    }
    contains(p) {
      return Point.distance(p, this.c) <= this.r;
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      const scale = Math.abs(m[0][0]) + Math.abs(m[1][1]);
      return new _Circle(this.c.transform(m), this.r * scale / 2);
    }
    rotate(a2, c2 = ORIGIN) {
      if (nearlyEquals(a2, 0)) return this;
      return new _Circle(this.c.rotate(a2, c2), this.r);
    }
    reflect(l) {
      return new _Circle(this.c.reflect(l), this.r);
    }
    scale(sx, sy = sx) {
      return new _Circle(this.c.scale(sx, sy), this.r * (sx + sy) / 2);
    }
    shift(x, y = x) {
      return new _Circle(this.c.shift(x, y), this.r);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, tolerance) {
      return nearlyEquals(this.r, other.r, tolerance) && this.c.equals(other.c, tolerance);
    }
    toString() {
      return `circle(${this.c},${this.r})`;
    }
  };
  var Arc = class {
    constructor(c2, start, angle) {
      this.c = c2;
      this.start = start;
      this.angle = angle;
      this.type = "arc";
    }
    get circle() {
      return new Circle(this.c, this.radius);
    }
    get radius() {
      return Point.distance(this.c, this.start);
    }
    get end() {
      return this.start.rotate(this.angle, this.c);
    }
    get startAngle() {
      return rad(this.start, this.c);
    }
    contract(p) {
      return new this.constructor(this.c, this.at(p / 2), this.angle * (1 - p));
    }
    get minor() {
      if (this.angle <= Math.PI) return this;
      return new this.constructor(this.c, this.end, TWO_PI - this.angle);
    }
    get major() {
      if (this.angle >= Math.PI) return this;
      return new this.constructor(this.c, this.end, TWO_PI - this.angle);
    }
    get center() {
      return this.at(0.5);
    }
    // ---------------------------------------------------------------------------
    project(p) {
      const start = this.startAngle;
      const end = start + this.angle;
      let angle = rad(p, this.c);
      if (end > TWO_PI && angle < end - TWO_PI) angle += TWO_PI;
      angle = clamp(angle, start, end);
      return this.c.shift(this.radius, 0).rotate(angle, this.c);
    }
    at(t) {
      return this.start.rotate(this.angle * t, this.c);
    }
    offset(p) {
      return new Angle(this.start, this.c, p).rad / this.angle;
    }
    contains(p) {
      return p.equals(this.project(p));
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return new this.constructor(
        this.c.transform(m),
        this.start.transform(m),
        this.angle
      );
    }
    /** Rotates this arc by a given angle (in radians), optionally around point `c`. */
    rotate(a2, c2 = ORIGIN) {
      if (nearlyEquals(a2, 0)) return this;
      return new this.constructor(
        this.c.rotate(a2, c2),
        this.start.rotate(a2, c2),
        this.angle
      );
    }
    reflect(l) {
      return new this.constructor(
        this.c.reflect(l),
        this.start.reflect(l),
        this.angle
      );
    }
    scale(sx, sy = sx) {
      return new this.constructor(
        this.c.scale(sx, sy),
        this.start.scale(sx, sy),
        this.angle
      );
    }
    shift(x, y = x) {
      return new this.constructor(
        this.c.shift(x, y),
        this.start.shift(x, y),
        this.angle
      );
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals() {
      return false;
    }
    toString() {
      return `arc(${this.c},${this.start},${this.angle})`;
    }
  };
  var Sector = class extends Arc {
    constructor() {
      super(...arguments);
      this.type = "sector";
    }
    contains(p) {
      return Point.distance(p, this.c) <= this.radius && new Angle(this.start, this.c, p).rad <= this.angle;
    }
    toString() {
      return `sector(${this.c},${this.start},${this.angle})`;
    }
  };
  function liesOnSegment(s, p) {
    if (nearlyEquals(s.p1.x, s.p2.x)) return isBetween(p.y, s.p1.y, s.p2.y);
    return isBetween(p.x, s.p1.x, s.p2.x);
  }
  function liesOnRay(r, p) {
    if (nearlyEquals(r.p1.x, r.p2.x)) return (p.y - r.p1.y) / (r.p2.y - r.p1.y) > 0;
    return (p.x - r.p1.x) / (r.p2.x - r.p1.x) > 0;
  }
  function liesOnArc(a2, p) {
    return isBetween(a2.offset(p), 0, 1);
  }
  function lineLineIntersection(l1, l2) {
    const d1x = l1.p1.x - l1.p2.x;
    const d1y = l1.p1.y - l1.p2.y;
    const d2x = l2.p1.x - l2.p2.x;
    const d2y = l2.p1.y - l2.p2.y;
    const d2 = d1x * d2y - d1y * d2x;
    if (nearlyEquals(d2, 0)) return [];
    const q1 = l1.p1.x * l1.p2.y - l1.p1.y * l1.p2.x;
    const q2 = l2.p1.x * l2.p2.y - l2.p1.y * l2.p2.x;
    const x = q1 * d2x - d1x * q2;
    const y = q1 * d2y - d1y * q2;
    return [new Point(x / d2, y / d2)];
  }
  function circleCircleIntersection(c1, c2) {
    const d2 = Point.distance(c1.c, c2.c);
    if (d2 > c1.r + c2.r) return [];
    if (d2 < Math.abs(c1.r - c2.r)) return [];
    if (nearlyEquals(d2, 0) && nearlyEquals(c1.r, c2.r)) return [];
    if (nearlyEquals(d2, c1.r + c2.r)) return [new Line(c1.c, c2.c).midpoint];
    const a2 = (square(c1.r) - square(c2.r) + square(d2)) / (2 * d2);
    const b2 = Math.sqrt(square(c1.r) - square(a2));
    const px = (c2.c.x - c1.c.x) * a2 / d2 + (c2.c.y - c1.c.y) * b2 / d2 + c1.c.x;
    const py = (c2.c.y - c1.c.y) * a2 / d2 - (c2.c.x - c1.c.x) * b2 / d2 + c1.c.y;
    const qx = (c2.c.x - c1.c.x) * a2 / d2 - (c2.c.y - c1.c.y) * b2 / d2 + c1.c.x;
    const qy = (c2.c.y - c1.c.y) * a2 / d2 + (c2.c.x - c1.c.x) * b2 / d2 + c1.c.y;
    return [new Point(px, py), new Point(qx, qy)];
  }
  function lineCircleIntersection(l, c2) {
    const dx = l.p2.x - l.p1.x;
    const dy = l.p2.y - l.p1.y;
    const dr2 = square(dx) + square(dy);
    const cx = c2.c.x;
    const cy = c2.c.y;
    const D = (l.p1.x - cx) * (l.p2.y - cy) - (l.p2.x - cx) * (l.p1.y - cy);
    const disc = square(c2.r) * dr2 - square(D);
    if (disc < 0) return [];
    const xa = D * dy / dr2;
    const ya = -D * dx / dr2;
    if (nearlyEquals(disc, 0)) return [c2.c.shift(xa, ya)];
    const xb = dx * (dy < 0 ? -1 : 1) * Math.sqrt(disc) / dr2;
    const yb = Math.abs(dy) * Math.sqrt(disc) / dr2;
    return [c2.c.shift(xa + xb, ya + yb), c2.c.shift(xa - xb, ya - yb)];
  }
  function simpleIntersection(a2, b2) {
    let results = [];
    const a1 = isArc(a2) ? a2.circle : a2;
    const b1 = isArc(b2) ? b2.circle : b2;
    if (isLineLike(a2) && isLineLike(b2)) {
      results = lineLineIntersection(a2, b2);
    } else if (isLineLike(a1) && isCircle(b1)) {
      results = lineCircleIntersection(a1, b1);
    } else if (isCircle(a1) && isLineLike(b1)) {
      results = lineCircleIntersection(b1, a1);
    } else if (isCircle(a1) && isCircle(b1)) {
      results = circleCircleIntersection(a1, b1);
    }
    for (const x of [a2, b2]) {
      if (isSegment(x)) results = results.filter((i) => liesOnSegment(x, i));
      if (isRay(x)) results = results.filter((i) => liesOnRay(x, i));
      if (isArc(x)) results = results.filter((i) => liesOnArc(x, i));
    }
    return results;
  }
  function intersections(...elements) {
    if (elements.length < 2) return [];
    if (elements.length > 2) {
      return flatten(subsets(elements, 2).map((e2) => intersections(...e2)));
    }
    let [a2, b2] = elements;
    if (isAngle(a2)) a2 = a2.shape(true);
    if (isAngle(b2)) b2 = b2.shape(true);
    if (isPolygonLike(b2)) [a2, b2] = [b2, a2];
    if (isPolygonLike(a2)) {
      const results = isLineLike(b2) ? a2.points.filter((p) => b2.contains(p)) : [];
      for (const e2 of a2.edges) results.push(...intersections(e2, b2));
      return results;
    }
    return simpleIntersection(a2, b2);
  }
  var Polygon = class _Polygon {
    constructor(...points) {
      this.type = "polygon";
      this.points = points;
    }
    get circumference() {
      if (this.points.length <= 1) return 0;
      let length = Point.distance(this.points[0], last(this.points));
      for (let i = 1; i < this.points.length; ++i) {
        length += Point.distance(this.points[i - 1], this.points[i]);
      }
      return length;
    }
    /**
     * The (signed) area of this polygon. The result is positive if the vertices
     * are ordered clockwise, and negative otherwise.
     */
    get signedArea() {
      const p = this.points;
      const n = p.length;
      let A = p[n - 1].x * p[0].y - p[0].x * p[n - 1].y;
      for (let i = 1; i < n; ++i) {
        A += p[i - 1].x * p[i].y - p[i].x * p[i - 1].y;
      }
      return A / 2;
    }
    get area() {
      return Math.abs(this.signedArea);
    }
    get centroid() {
      const p = this.points;
      const n = p.length;
      let Cx = 0;
      for (let i = 0; i < n; ++i) Cx += p[i].x;
      let Cy = 0;
      for (let i = 0; i < n; ++i) Cy += p[i].y;
      return new Point(Cx / n, Cy / n);
    }
    get edges() {
      const n = this.points.length;
      const edges = [];
      for (let i = 0; i < n; ++i) {
        edges.push(new Segment(this.points[i], this.points[(i + 1) % n]));
      }
      return edges;
    }
    get radius() {
      const c2 = this.centroid;
      const radii = this.points.map((p) => Point.distance(p, c2));
      return Math.max(...radii);
    }
    /** The oriented version of this polygon (vertices in clockwise order). */
    get oriented() {
      if (this.signedArea >= 0) return this;
      const points = [...this.points].reverse();
      return new this.constructor(...points);
    }
    /** Checks if two polygons p1 and p2 collide. */
    static collision(p1, p2) {
      if (p1.points.some((q) => p2.contains(q))) return true;
      if (p2.points.some((q) => p1.contains(q))) return true;
      for (const e1 of p1.edges) {
        for (const e2 of p2.edges) {
          if (intersections(e1, e2)[0]) return true;
        }
      }
      return false;
    }
    /** Creates a regular polygon. */
    static regular(n, radius = 1) {
      const da = TWO_PI / n;
      const a0 = Math.PI / 2 - da / 2;
      const points = tabulate((i) => Point.fromPolar(a0 + da * i, radius), n);
      return new _Polygon(...points);
    }
    /** Interpolates the points of two polygons */
    static interpolate(p1, p2, t = 0.5) {
      const points = p1.points.map(
        (p, i) => Point.interpolate(p, p2.points[i], t)
      );
      return new _Polygon(...points);
    }
    static convexHull(...points) {
      if (points.length <= 3) return new _Polygon(...points);
      const sorted = points.sort((a2, b2) => a2.x !== b2.x ? a2.x - b2.x : a2.y - b2.y);
      const sortedReverse = sorted.slice(0).reverse();
      const upper = [];
      const lower = [];
      for (const [source, target] of [[sorted, upper], [sortedReverse, lower]]) {
        for (const p of source) {
          while (target.length >= 2) {
            const p1 = target[target.length - 1];
            const p2 = target[target.length - 2];
            if ((p1.x - p2.x) * (p.y - p2.y) >= (p.x - p2.x) * (p1.y - p2.y)) {
              target.pop();
            } else {
              break;
            }
          }
          target.push(p);
        }
        target.pop();
      }
      return new _Polygon(...upper.concat(lower));
    }
    // ---------------------------------------------------------------------------
    /**
     * Checks if a point p lies inside this polygon, by using a ray-casting
     * algorithm and calculating the number of intersections.
     */
    contains(p) {
      let inside = false;
      for (const e2 of this.edges) {
        if (e2.p1.equals(p) || e2.contains(p)) return false;
        if (e2.p1.y > p.y === e2.p2.y > p.y) continue;
        const det = (e2.p2.x - e2.p1.x) / (e2.p2.y - e2.p1.y);
        if (p.x < det * (p.y - e2.p1.y) + e2.p1.x) inside = !inside;
      }
      return inside;
    }
    at(t) {
      if (t < 0) t += Math.floor(t);
      const offset = t * this.circumference;
      let cum = 0;
      for (const e2 of this.edges) {
        const l = e2.length;
        if (cum + l > offset) return e2.at((offset - cum) / l);
        cum += l;
      }
      return this.points[0];
    }
    offset(p) {
      const edges = this.edges;
      const proj = findClosest(p, this.edges) || [this.points[0], 0];
      let offset = 0;
      for (let i = 0; i < proj[1]; ++i) offset += edges[i].length;
      offset += edges[proj[1]].offset(p) * edges[proj[1]].length;
      return offset / this.circumference;
    }
    project(p) {
      const proj = findClosest(p, this.edges);
      return proj ? proj[0] : this.points[0];
    }
    /** Center this polygon on a given point or the origin */
    centerAt(on = ORIGIN) {
      return this.translate(on.subtract(this.centroid));
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return new this.constructor(...this.points.map((p) => p.transform(m)));
    }
    /** Rotates this polygon by a given angle (in radians), optionally around point `center`. */
    rotate(a2, center = ORIGIN) {
      if (nearlyEquals(a2, 0)) return this;
      const points = this.points.map((p) => p.rotate(a2, center));
      return new this.constructor(...points);
    }
    reflect(line) {
      const points = this.points.map((p) => p.reflect(line));
      return new this.constructor(...points);
    }
    scale(sx, sy = sx) {
      const points = this.points.map((p) => p.scale(sx, sy));
      return new this.constructor(...points);
    }
    shift(x, y = x) {
      const points = this.points.map((p) => p.shift(x, y));
      return new this.constructor(...points);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, tolerance, oriented) {
      const n = this.points.length;
      if (n !== other.points.length) return false;
      const p1 = oriented ? this : this.oriented;
      const p2 = oriented ? other : other.oriented;
      for (let offset = 0; offset < n; ++offset) {
        if (p1.points.every((p, i) => p.equals(p2.points[(i + offset) % n], tolerance))) {
          return true;
        }
      }
      return false;
    }
    toString() {
      return `polygon(${this.points.join(",")})`;
    }
  };
  var Polyline = class extends Polygon {
    constructor() {
      super(...arguments);
      this.type = "polyline";
    }
    get circumference() {
      return this.length;
    }
    get length() {
      let length = 0;
      for (let i = 1; i < this.points.length; ++i) {
        length += Point.distance(this.points[i - 1], this.points[i]);
      }
      return length;
    }
    /** @returns {Segment[]} */
    get edges() {
      const edges = [];
      for (let i = 0; i < this.points.length - 1; ++i) {
        edges.push(new Segment(this.points[i], this.points[i + 1]));
      }
      return edges;
    }
    toString() {
      return `polyline(${this.points.join(",")})`;
    }
  };
  var RAD_TO_DEG = 180 / Math.PI;
  var DEG_TO_RAD = Math.PI / 180;
  function toDeg(n) {
    return n * RAD_TO_DEG;
  }
  var Angle = class _Angle {
    constructor(a2, b2, c2) {
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.type = "angle";
    }
    static fromDegrees(val) {
      return _Angle.fromRadians(val * (Math.PI / 180));
    }
    static fromRadians(val) {
      const p1 = new Point(1, 0);
      const p2 = p1.rotate(val);
      return new _Angle(p1, ORIGIN, p2);
    }
    /** Checks if `a` and `b` are roughly equivalent (by default, within one degree of eachother) */
    static equals(a2, b2, precision = Math.PI / 360) {
      return nearlyEquals(a2.rad, b2.rad, precision);
    }
    /** The size, in radians, of this angle. */
    get rad() {
      const phiA = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x);
      const phiC = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x);
      let phi = phiC - phiA;
      if (phi < 0) phi += TWO_PI;
      return phi;
    }
    /** The size, in degrees, of this angle. */
    get deg() {
      return this.rad * 180 / Math.PI;
    }
    /** Checks if this angle is right-angled. */
    get isRight() {
      return nearlyEquals(this.rad, Math.PI / 2, Math.PI / 360);
    }
    /** The bisector of this angle. */
    get bisector() {
      if (this.b.equals(this.a)) return void 0;
      if (this.b.equals(this.c)) return void 0;
      const phiA = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x);
      const phiC = Math.atan2(this.c.y - this.b.y, this.c.x - this.b.x);
      let phi = (phiA + phiC) / 2;
      if (phiA > phiC) phi += Math.PI;
      const x = Math.cos(phi) + this.b.x;
      const y = Math.sin(phi) + this.b.y;
      return new Line(this.b, new Point(x, y));
    }
    /** Returns the smaller one of this and its supplementary angle. */
    get sup() {
      return this.rad < Math.PI ? this : new _Angle(this.c, this.b, this.a);
    }
    /** Returns the Arc element corresponding to this angle. */
    get arc() {
      return new Arc(this.b, this.a, this.rad);
    }
    // ---------------------------------------------------------------------------
    /** Radius of the arc or sector representing this angle. */
    get radius() {
      return 24 + 20 * (1 - clamp(this.rad, 0, Math.PI) / Math.PI);
    }
    /** Shape object that can be used to draw this angle. */
    shape(filled = true, radius, round2) {
      if (this.a.equals(this.b) || this.c.equals(this.b)) return new Polygon(ORIGIN);
      const angled = this.isRight && !round2;
      if (!radius) radius = angled ? 20 : this.radius;
      const ba = new Segment(this.b, this.a);
      const a2 = ba.at(radius / ba.length);
      if (angled) {
        const bc = Point.difference(this.c, this.b).unitVector.scale(radius);
        if (filled) return new Polygon(this.b, a2, a2.add(bc), this.b.add(bc));
        return new Polyline(a2, a2.add(bc), this.b.add(bc));
      }
      if (filled) return new Sector(this.b, a2, this.rad);
      return new Arc(this.b, a2, this.rad);
    }
    // ---------------------------------------------------------------------------
    // These functions are just included for compatibility with GeoPath
    project(p) {
      return this.contains(p) ? p : this.shape(true).project(p);
    }
    at() {
      return this.c;
    }
    offset() {
      return 0;
    }
    contains(p) {
      return this.shape(true).contains(p);
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return new _Angle(this.a.transform(m), this.b.transform(m), this.c.transform(m));
    }
    rotate(a2, c2) {
      if (nearlyEquals(a2, 0)) return this;
      return new _Angle(this.a.rotate(a2, c2), this.b.rotate(a2, c2), this.c.rotate(a2, c2));
    }
    reflect(l) {
      return new _Angle(this.a.reflect(l), this.b.reflect(l), this.c.reflect(l));
    }
    scale(sx, sy = sx) {
      return new _Angle(this.a.scale(sx, sy), this.b.scale(sx, sy), this.c.scale(sx, sy));
    }
    shift(x, y = x) {
      return new _Angle(this.a.shift(x, y), this.b.shift(x, y), this.c.shift(x, y));
    }
    translate(p) {
      return new _Angle(this.a.translate(p), this.b.translate(p), this.c.translate(p));
    }
    equals(a2, precision) {
      return _Angle.equals(a2, this, precision);
    }
    toString() {
      return `angle(${this.a},${this.b},${this.c})`;
    }
  };
  var Rectangle = class _Rectangle {
    constructor(p, w = 1, h = w) {
      this.p = p;
      this.w = w;
      this.h = h;
      this.type = "rectangle";
    }
    /** Creates the smallest rectangle containing all given points. */
    static aroundPoints(points) {
      let xMin = Infinity;
      let xMax = -Infinity;
      let yMin = Infinity;
      let yMax = -Infinity;
      for (const p of points) {
        xMin = xMin < p.x ? xMin : p.x;
        xMax = xMax > p.x ? xMax : p.x;
        yMin = yMin < p.y ? yMin : p.y;
        yMax = yMax > p.y ? yMax : p.y;
      }
      return new _Rectangle(new Point(xMin, yMin), xMax - xMin, yMax - yMin);
    }
    get center() {
      return new Point(this.p.x + this.w / 2, this.p.y + this.h / 2);
    }
    get centroid() {
      return this.center;
    }
    get circumference() {
      return 2 * Math.abs(this.w) + 2 * Math.abs(this.h);
    }
    get area() {
      return Math.abs(this.signedArea);
    }
    get signedArea() {
      return this.w * this.h;
    }
    /** @returns {Segment[]} */
    get edges() {
      return this.polygon.edges;
    }
    /** @returns {Point[]} */
    get points() {
      return this.polygon.points;
    }
    /** A polygon class representing this rectangle. */
    get polygon() {
      const b2 = new Point(this.p.x + this.w, this.p.y);
      const c2 = new Point(this.p.x + this.w, this.p.y + this.h);
      const d2 = new Point(this.p.x, this.p.y + this.h);
      return new Polygon(this.p, b2, c2, d2);
    }
    get bounds() {
      return new Bounds(this.p.x, this.p.x + this.w, this.p.y, this.p.y + this.h);
    }
    collision(r) {
      return this.p.x < r.p.x + r.w && this.p.x + this.w > r.p.x && this.p.y < r.p.y + r.h && this.p.y + this.h > r.p.y;
    }
    padding(top, right, bottom, left) {
      return new _Rectangle(this.p.shift(-left, -top), this.w + left + right, this.h + top + bottom);
    }
    get unsigned() {
      if (this.w > 0 && this.h > 0) return this;
      const p = this.p.shift(this.w < 0 ? this.w : 0, this.h < 0 ? this.h : 0);
      return new _Rectangle(p, Math.abs(this.w), Math.abs(this.h));
    }
    // ---------------------------------------------------------------------------
    contains(p, tolerance) {
      return isBetween(p.x, this.p.x, this.p.x + this.w, tolerance) && isBetween(p.y, this.p.y, this.p.y + this.h, tolerance);
    }
    project(p) {
      let q = void 0;
      for (const e2 of this.edges) {
        const q1 = e2.project(p);
        if (!q || Point.distance(p, q1) < Point.distance(p, q)) q = q1;
      }
      return q;
    }
    at(t) {
      return this.polygon.at(t);
    }
    offset(p) {
      return this.polygon.offset(p);
    }
    get oriented() {
      return this.polygon.oriented;
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return this.polygon.transform(m);
    }
    /** Rotates this rectangle by a given angle (in radians), optionally around point `c`. */
    rotate(a2, c2 = ORIGIN) {
      if (nearlyEquals(a2, 0)) return this;
      return this.polygon.rotate(a2, c2);
    }
    reflect(l) {
      return this.polygon.reflect(l);
    }
    scale(sx, sy = sx) {
      return new _Rectangle(this.p.scale(sx, sy), this.w * sx, this.h * sy);
    }
    shift(x, y = x) {
      return new _Rectangle(this.p.shift(x, y), this.w, this.h);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(_other) {
      return false;
    }
    toString() {
      return `rectangle(${this.p},${this.w},${this.h})`;
    }
  };
  var Bounds = class _Bounds {
    /**
     * Use the `errorHandling` option to decide how to deal with cases where the
     * min and max values are in the wrong order.
     */
    constructor(xMin, xMax, yMin, yMax, errorHandling) {
      this.xMin = xMin;
      this.xMax = xMax;
      this.yMin = yMin;
      this.yMax = yMax;
      if (errorHandling === "swap") {
        if (this.dx < 0) [this.xMin, this.xMax] = [xMax, xMin];
        if (this.dy < 0) [this.yMin, this.yMax] = [yMax, yMin];
      } else if (errorHandling === "center") {
        if (this.dx < 0) this.xMin = this.xMax = (xMin + xMax) / 2;
        if (this.dy < 0) this.yMin = this.yMax = (yMin + yMax) / 2;
      }
    }
    contains(p) {
      return this.containsX(p) && this.containsY(p);
    }
    containsX(p) {
      return isBetween(p.x, this.xMin, this.xMax);
    }
    containsY(p) {
      return isBetween(p.y, this.yMin, this.yMax);
    }
    resize(dx, dy) {
      return new _Bounds(this.xMin, this.xMax + dx, this.yMin, this.yMax + dy);
    }
    get dx() {
      return this.xMax - this.xMin;
    }
    get dy() {
      return this.yMax - this.yMin;
    }
    get xRange() {
      return [this.xMin, this.xMax];
    }
    get yRange() {
      return [this.yMin, this.yMax];
    }
    extend(top, right = top, bottom = top, left = right) {
      return new _Bounds(this.xMin - left, this.xMax + right, this.yMin - top, this.yMax + bottom);
    }
    get rect() {
      return new Rectangle(new Point(this.xMin, this.yMin), this.dx, this.dy);
    }
    get center() {
      return new Point(this.xMin + this.dx / 2, this.yMin + this.dy / 2);
    }
    get flip() {
      return new _Bounds(this.yMin, this.yMax, this.xMin, this.xMax);
    }
  };
  function drawCanvas(ctx, obj, options = {}) {
    if (isAngle(obj)) return drawCanvas(ctx, obj.shape(!!options.fill), options);
    if (options.fill) ctx.fillStyle = options.fill;
    if (options.opacity) ctx.globalAlpha = options.opacity;
    if (options.stroke) {
      ctx.strokeStyle = options.stroke;
      ctx.lineWidth = options.strokeWidth || 1;
      if (options.lineCap) ctx.lineCap = options.lineCap;
      if (options.lineJoin) ctx.lineJoin = options.lineJoin;
    }
    ctx.beginPath();
    if (isSegment(obj)) {
      ctx.moveTo(obj.p1.x, obj.p1.y);
      ctx.lineTo(obj.p2.x, obj.p2.y);
    } else if (isLineLike(obj)) {
      if (!options.box) return;
      let [start, end] = intersections(obj, options.box);
      if (isRay(obj)) end = obj.p1;
      if (!start || !end) return;
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
    } else if (isCircle(obj)) {
      ctx.arc(obj.c.x, obj.c.y, obj.r, 0, TWO_PI);
    } else if (isPolygonLike(obj)) {
      const points = obj.points;
      ctx.moveTo(points[0].x, points[0].y);
      for (const p of points.slice(1)) ctx.lineTo(p.x, p.y);
      ctx.closePath();
    } else if (isPolyline(obj)) {
      ctx.moveTo(obj.points[0].x, obj.points[0].y);
      for (const p of obj.points.slice(1)) ctx.lineTo(p.x, p.y);
    } else if (isEllipse(obj)) {
      ctx.ellipse(obj.c.x, obj.c.y, obj.a, obj.b, obj.angle, 0, TWO_PI);
    }
    if (options.fill) ctx.fill();
    if (options.stroke) ctx.stroke();
  }
  var CIRCLE_MAGIC = 4 * (Math.sqrt(2) - 1) / 3;
  function drawArc(a2, b2, c2) {
    const orient = b2.x * (c2.y - a2.y) + a2.x * (b2.y - c2.y) + c2.x * (a2.y - b2.y);
    const sweep = orient > 0 ? 1 : 0;
    const size = Point.distance(b2, a2);
    return [a2.x, `${a2.y}A${size}`, size, 0, sweep, 1, c2.x, c2.y].join(",");
  }
  function drawPath(...points) {
    return `M${points.map((p) => `${p.x},${p.y}`).join("L")}`;
  }
  function drawLineMark(x, type) {
    const p = x.perpendicularVector.scale(6);
    const n = x.unitVector.scale(3);
    const m = x.midpoint;
    switch (type) {
      case "bar":
        return drawPath(m.add(p), m.add(p.inverse));
      case "bar2":
        return drawPath(m.add(n).add(p), m.add(n).add(p.inverse)) + drawPath(m.add(n.inverse).add(p), m.add(n.inverse).add(p.inverse));
      case "arrow":
        return drawPath(
          m.add(n.inverse).add(p),
          m.add(n),
          m.add(n.inverse).add(p.inverse)
        );
      case "arrow2":
        return drawPath(
          m.add(n.scale(-2)).add(p),
          m,
          m.add(n.scale(-2)).add(p.inverse)
        ) + drawPath(m.add(p), m.add(n.scale(2)), m.add(p.inverse));
      default:
        return "";
    }
  }
  function arrowPath(start, normal2) {
    if (!start || !normal2) return "";
    const perp = normal2.perpendicular;
    const a2 = start.add(normal2.scale(9)).add(perp.scale(9));
    const b2 = start.add(normal2.scale(9)).add(perp.scale(-9));
    return drawPath(a2, start, b2);
  }
  function drawLineArrows(x, type) {
    let path = "";
    if (isOneOf(type, "start", "both")) {
      path += arrowPath(x.p1, x.unitVector);
    }
    if (isOneOf(type, "end", "both")) {
      path += arrowPath(x.p2, x.unitVector.inverse);
    }
    return path;
  }
  function drawArcArrows(x, type) {
    let path = "";
    if (isOneOf(type, "start", "both")) {
      const normal2 = new Line(x.c, x.start).perpendicularVector.inverse;
      path += arrowPath(x.start, normal2);
    }
    if (isOneOf(type, "end", "both")) {
      const normal2 = new Line(x.c, x.end).perpendicularVector;
      path += arrowPath(x.end, normal2);
    }
    return path;
  }
  function getBezierPoints(points, radius) {
    const length0 = Point.distance(points[0], points[1]);
    const length1 = Point.distance(points[1], points[2]);
    const r1 = Math.max(0.1, length0 / 2);
    const r2 = Math.max(0.1, length1 / 2);
    const rad2 = Math.min(radius, r1, r2);
    const d1 = rad2 / length0;
    const d2 = rad2 / length1;
    const shift = 1 - CIRCLE_MAGIC;
    const p1 = Point.interpolate(points[0], points[1], clamp(1 - d1, 0, 1));
    const p2 = Point.interpolate(points[0], points[1], clamp(1 - d1 * shift, 0, 1));
    const p3 = Point.interpolate(points[1], points[2], clamp(d2 * shift, 0, 1));
    const p4 = Point.interpolate(points[1], points[2], clamp(d2, 0, 1));
    return [p1, p2, p3, p4];
  }
  function drawRoundedPath(points, radius, close = false) {
    if (radius < 0) radius = 0;
    let path = "M";
    if (!close) {
      path += `${points[0].x} ${points[0].y}`;
    } else {
      const p1 = points[points.length - 1];
      const p2 = points[0];
      const p3 = points[1];
      const offsets = getBezierPoints([p1, p2, p3], radius);
      path += `${offsets[3].x} ${offsets[3].y}`;
    }
    for (let index = 0; index < points.length; index++) {
      if (index < points.length - 2 || close) {
        const p1 = points[index];
        const p2 = points[(index + 1) % points.length];
        const p3 = points[(index + 2) % points.length];
        const offsets = getBezierPoints([p1, p2, p3], radius).map((p) => `${p.x} ${p.y}`);
        path += `L${offsets[0]}C${offsets[1]} ${offsets[2]} ${offsets[3]}`;
      } else if (index === points.length - 2 && !close) {
        path += `L${points[index + 1].x} ${points[index + 1].y}`;
      }
    }
    return path;
  }
  function drawSVG(obj, options = {}) {
    if (isAngle(obj)) {
      const shape = obj.shape(!!options.fill, options.size, options.round);
      return drawSVG(shape, options);
    }
    if (isSegment(obj)) {
      if (obj.p1.equals(obj.p2)) return "";
      let line = drawPath(obj.p1, obj.p2);
      if (options.mark) line += drawLineMark(obj, options.mark);
      if (options.arrows) line += drawLineArrows(obj, options.arrows);
      return line;
    }
    if (isRay(obj)) {
      if (!options.box) return "";
      const end = intersections(obj, options.box)[0];
      if (!end) return "";
      let line = drawPath(obj.p1, end);
      if (options.mark) line += drawLineMark(obj, options.mark);
      return line;
    }
    if (isLine(obj)) {
      if (!options.box) return "";
      const points = intersections(obj, options.box);
      if (points.length < 2) return "";
      let line = drawPath(points[0], points[1]);
      if (options.mark) line += drawLineMark(obj, options.mark);
      return line;
    }
    if (isCircle(obj)) {
      return `M${obj.c.x - obj.r} ${obj.c.y}a${obj.r},${obj.r} 0 1 0 ${2 * obj.r} 0a${obj.r} ${obj.r} 0 1 0 ${-2 * obj.r} 0Z`;
    }
    if (isEllipse(obj)) {
      const [u, v] = obj.majorVertices;
      const rot = toDeg(obj.angle);
      return `M${u.x} ${u.y}A${obj.a} ${obj.b} ${rot} 0 0 ${v.x} ${v.y}A${obj.a} ${obj.b} ${rot} 0 0 ${u.x} ${u.y}Z`;
    }
    if (isArc(obj)) {
      let path = `M${drawArc(obj.start, obj.c, obj.end)}`;
      if (options.arrows) path += drawArcArrows(obj, options.arrows);
      return path;
    }
    if (isSector(obj)) {
      return `M${obj.c.x} ${obj.c.y} L ${drawArc(obj.start, obj.c, obj.end)}Z`;
    }
    if (isPolyline(obj)) {
      if (options.cornerRadius) return drawRoundedPath(obj.points, options.cornerRadius, false);
      return drawPath(...obj.points);
    }
    if (isPolygon(obj) || isRectangle(obj) && options.cornerRadius) {
      if (options.cornerRadius) {
        return drawRoundedPath(obj.points, options.cornerRadius, true);
      }
      return `${drawPath(...obj.points)}Z`;
    }
    if (isRectangle(obj)) {
      return `${drawPath(...obj.polygon.points)}Z`;
    }
    return "";
  }

  // content/shared/constants.ts
  var RED = "#cd0e66";
  var BLUE = "#0f82f2";
  var GREEN = "#22ab24";
  var YELLOW = "#fd8c00";
  var ORANGE = "#eb4726";
  var PURPLE = "#6d3bbf";
  var LIME = "#bfc212";
  var GREY = "#3a3645";

  // content/solids/data/voxel-data.ts
  var layers = [
    { locs: [], color: "" },
    {
      locs: [
        [-1, -2, -2],
        [0, -2, -2],
        [1, -2, -2],
        [2, -2, -2],
        [-2, -2, -2],
        [-2, -1, -2],
        [-2, 0, -2],
        [-2, 1, -2],
        [-2, 2, -2],
        [-1, -1, -2],
        [-1, 0, -2],
        [-1, 1, -2],
        [-1, 2, -2],
        [0, -1, -2],
        [0, 0, -2],
        [0, 1, -2],
        [0, 2, -2],
        [1, -1, -2],
        [1, 0, -2],
        [1, 1, -2],
        [1, 2, -2],
        [2, -1, -2],
        [2, 0, -2],
        [2, 1, -2],
        [2, 2, -2]
      ],
      color: BLUE
    },
    {
      locs: [
        [-1, -2, -1],
        [0, -2, -1],
        [1, -2, -1],
        [2, -2, -1],
        [-2, -2, -1],
        [-2, -1, -1],
        [-2, 0, -1],
        [-2, 1, -1],
        [-2, 2, -1],
        [-1, -1, -1],
        [-1, 0, -1],
        [-1, 1, -1],
        [-1, 2, -1],
        [0, -1, -1],
        [0, 0, -1],
        [0, 1, -1],
        [0, 2, -1],
        [1, -1, -1],
        [1, 0, -1],
        [1, 1, -1],
        [1, 2, -1],
        [2, -1, -1],
        [2, 0, -1],
        [2, 1, -1],
        [2, 2, -1]
      ],
      color: GREEN
    },
    {
      locs: [
        [-1, -2, 0],
        [0, -2, 0],
        [1, -2, 0],
        [2, -2, 0],
        [-2, -2, 0],
        [-2, -1, 0],
        [-2, 0, 0],
        [-2, 1, 0],
        [-2, 2, 0],
        [-1, -1, 0],
        [-1, 0, 0],
        [-1, 1, 0],
        [-1, 2, 0],
        [0, -1, 0],
        [0, 0, 0],
        [0, 1, 0],
        [0, 2, 0],
        [1, -1, 0],
        [1, 0, 0],
        [1, 1, 0],
        [1, 2, 0],
        [2, -1, 0],
        [2, 0, 0],
        [2, 1, 0],
        [2, 2, 0]
      ],
      color: YELLOW
    },
    {
      locs: [
        [-1, -2, 1],
        [0, -2, 1],
        [1, -2, 1],
        [2, -2, 1],
        [-2, -2, 1],
        [-2, -1, 1],
        [-2, 0, 1],
        [-2, 1, 1],
        [-2, 2, 1],
        [-1, -1, 1],
        [-1, 0, 1],
        [-1, 1, 1],
        [-1, 2, 1],
        [0, -1, 1],
        [0, 0, 1],
        [0, 1, 1],
        [0, 2, 1],
        [1, -1, 1],
        [1, 0, 1],
        [1, 1, 1],
        [1, 2, 1],
        [2, -1, 1],
        [2, 0, 1],
        [2, 1, 1],
        [2, 2, 1]
      ],
      color: RED
    },
    {
      locs: [
        [-1, -2, 2],
        [0, -2, 2],
        [1, -2, 2],
        [2, -2, 2],
        [-2, -2, 2],
        [-2, -1, 2],
        [-2, 0, 2],
        [-2, 1, 2],
        [-2, 2, 2],
        [-1, -1, 2],
        [-1, 0, 2],
        [-1, 1, 2],
        [-1, 2, 2],
        [0, -1, 2],
        [0, 0, 2],
        [0, 1, 2],
        [0, 2, 2],
        [1, -1, 2],
        [1, 0, 2],
        [1, 1, 2],
        [1, 2, 2],
        [2, -1, 2],
        [2, 0, 2],
        [2, 1, 2],
        [2, 2, 2]
      ],
      color: LIME
    }
  ];
  var templeParts = [
    {
      // Floor
      locs: [
        [-1, -2, -2],
        [0, -2, -2],
        [1, -2, -2],
        [2, -2, -2],
        [-2, -2, -2],
        [-2, -1, -2],
        [-2, 0, -2],
        [-2, 1, -2],
        [-2, 2, -2],
        [-1, -1, -2],
        [-1, 0, -2],
        [-1, 1, -2],
        [-1, 2, -2],
        [0, -1, -2],
        [0, 0, -2],
        [0, 1, -2],
        [0, 2, -2],
        [1, -1, -2],
        [1, 0, -2],
        [1, 1, -2],
        [1, 2, -2],
        [2, -1, -2],
        [2, 0, -2],
        [2, 1, -2],
        [2, 2, -2]
      ],
      color: BLUE
    },
    {
      // Pillars
      locs: [
        [2, -2, 0],
        [-2, -2, 0],
        [-2, 2, 0],
        [2, -2, -1],
        [-2, -2, -1],
        [-2, 2, -1],
        [2, -2, 1],
        [-2, -2, 1],
        [-2, 2, 1]
      ],
      color: GREY
    },
    {
      // Top
      locs: [
        [-1, -2, 2],
        [0, -2, 2],
        [1, -2, 2],
        [2, -2, 2],
        [-2, -2, 2],
        [-2, -1, 2],
        [-2, 0, 2],
        [-2, 1, 2],
        [-2, 2, 2]
      ],
      color: YELLOW
    }
  ];

  // content/solids/data/net-data.ts
  var dihed1 = 180 - 70.528779;
  var pyramid1 = {
    faces: [
      new Polygon(
        // Circle
        new Point(-0.866, 0.5),
        new Point(0, -1),
        new Point(0.866, 0.5)
      ),
      new Polygon(
        // Circle.001
        new Point(1.7321, -1),
        new Point(0, -1),
        new Point(0.866, 0.5)
      ),
      new Polygon(
        // Circle.002
        new Point(0, 2),
        new Point(0.866, 0.5),
        new Point(-0.866, 0.5)
      ),
      new Polygon(
        // Circle.003
        new Point(-1.7321, -1),
        new Point(0, -1),
        new Point(-0.866, 0.5)
      )
    ],
    hinges: [
      [0, 1, dihed1],
      [0, 2, dihed1],
      [0, 3, dihed1]
    ]
  };
  var a = 3;
  var b = 2;
  var c = Math.sqrt(b ** 2 - (a / 2) ** 2);
  var d = a / 2;
  var e = d + b;
  var dihed2 = Angle.fromRadians(Math.asin(c / b)).deg;
  var triangularPrism = {
    faces: [
      new Polygon(
        new Point(-a, -d),
        new Point(a, -d),
        new Point(a, d),
        new Point(-a, d)
      ),
      new Polygon(
        new Point(-a, -d),
        new Point(-a, -e),
        new Point(a, -e),
        new Point(a, -d)
      ),
      new Polygon(
        new Point(-a, d),
        new Point(a, d),
        new Point(a, e),
        new Point(-a, e)
      ),
      new Polygon(
        new Point(a, d),
        new Point(a, -d),
        new Point(a + c, 0)
      ),
      new Polygon(
        new Point(-a, d),
        new Point(-a, -d),
        new Point(-(a + c), 0)
      )
    ],
    hinges: [
      [0, 1, 180 - dihed2],
      [0, 2, 180 - dihed2],
      [0, 3, 90],
      [0, 4, 90]
    ]
  };
  var dihedHH = 180 - 138.189685;
  var dihedHP = 180 - 142.62263;
  var truncatedIcosahedron = {
    faces: [
      new Polygon(
        // base
        new Point(0, -1.3951),
        new Point(1.2085, -0.6976),
        new Point(1.2085, 0.6976),
        new Point(0, 1.3951),
        new Point(-1.2085, 0.6976),
        new Point(-1.2085, -0.6976)
      ),
      new Polygon(
        // Curve.001
        new Point(-2.4169, 2.7902),
        new Point(-1.2085, 3.4878),
        new Point(-1.2085, 4.8829),
        new Point(-2.4169, 5.5805),
        new Point(-3.6254, 4.8829),
        new Point(-3.6254, 3.4878)
      ),
      new Polygon(
        // Curve.002
        new Point(0, 2.7902),
        new Point(1.2085, 3.4878),
        new Point(1.2085, 4.8829),
        new Point(0, 5.5805),
        new Point(-1.2085, 4.8829),
        new Point(-1.2085, 3.4878)
      ),
      new Polygon(
        // Curve.003
        new Point(1.2085, 0.6976),
        new Point(2.4169, 1.3951),
        new Point(2.4169, 2.7902),
        new Point(1.2085, 3.4878),
        new Point(0, 2.7902),
        new Point(0, 1.3951)
      ),
      new Polygon(
        // Curve.004
        new Point(1.2085, -3.4879),
        new Point(2.4169, -2.7903),
        new Point(2.4169, -1.3952),
        new Point(1.2085, -0.6976),
        new Point(0, -1.3952),
        new Point(0, -2.7903)
      ),
      new Polygon(
        // Curve.005
        new Point(3.6254, -3.4878),
        new Point(4.8338, -2.7902),
        new Point(4.8338, -1.3951),
        new Point(3.6254, -0.6976),
        new Point(2.4169, -1.3951),
        new Point(2.4169, -2.7902)
      ),
      new Polygon(
        // Curve.006
        new Point(4.8339, -5.5805),
        new Point(6.0423, -4.883),
        new Point(6.0423, -3.4879),
        new Point(4.8339, -2.7903),
        new Point(3.6254, -3.4879),
        new Point(3.6254, -4.883)
      ),
      new Polygon(
        // Curve.007
        new Point(-2.4169, -1.3951),
        new Point(-1.2084, -0.6976),
        new Point(-1.2084, 0.6976),
        new Point(-2.4169, 1.3951),
        new Point(-3.6254, 0.6976),
        new Point(-3.6254, -0.6976)
      ),
      new Polygon(
        // Curve.008
        new Point(-3.6254, -3.4878),
        new Point(-2.4169, -2.7903),
        new Point(-2.4169, -1.3951),
        new Point(-3.6254, -0.6976),
        new Point(-4.8338, -1.3951),
        new Point(-4.8338, -2.7903)
      ),
      new Polygon(
        // Curve.009
        new Point(-2.4169, -5.5805),
        new Point(-1.2085, -4.8829),
        new Point(-1.2085, -3.4878),
        new Point(-2.4169, -2.7903),
        new Point(-3.6254, -3.4878),
        new Point(-3.6254, -4.8829)
      ),
      new Polygon(
        // Curve.010
        new Point(3.6254, 0.6975),
        new Point(4.8339, 1.3951),
        new Point(4.8339, 2.7902),
        new Point(3.6254, 3.4878),
        new Point(2.4169, 2.7902),
        new Point(2.4169, 1.3951)
      ),
      new Polygon(
        // Curve.011
        new Point(1.2085, 4.8829),
        new Point(2.4169, 5.5804),
        new Point(2.4169, 6.9756),
        new Point(1.2085, 7.6731),
        new Point(0, 6.9756),
        new Point(0, 5.5804)
      ),
      new Polygon(
        // Curve.012
        new Point(0, 6.9756),
        new Point(1.2085, 7.6731),
        new Point(1.2085, 9.0683),
        new Point(0, 9.7658),
        new Point(-1.2085, 9.0683),
        new Point(-1.2085, 7.6731)
      ),
      new Polygon(
        // Curve.013
        new Point(-3.6254, 4.8829),
        new Point(-2.4169, 5.5805),
        new Point(-2.4169, 6.9756),
        new Point(-3.6254, 7.6731),
        new Point(-4.8339, 6.9756),
        new Point(-4.8339, 5.5805)
      ),
      new Polygon(
        // Curve.014
        new Point(-6.0423, 4.8829),
        new Point(-4.8339, 5.5804),
        new Point(-4.8339, 6.9756),
        new Point(-6.0423, 7.6731),
        new Point(-7.2508, 6.9756),
        new Point(-7.2508, 5.5804)
      ),
      new Polygon(
        // Curve.015
        new Point(-0.1715, 5.8164),
        new Point(-1.2085, 4.8829),
        new Point(-2.4169, 5.5805),
        new Point(-2.1268, 6.9451),
        new Point(-0.739, 7.0909)
      ),
      new Polygon(
        // Curve.016
        new Point(3.4539, 7.9091),
        new Point(2.4169, 6.9756),
        new Point(1.2084, 7.6731),
        new Point(1.4986, 9.0378),
        new Point(2.8863, 9.1836)
      ),
      new Polygon(
        // Curve.017
        new Point(3.3558, 4.1853),
        new Point(2.5356, 3.0567),
        new Point(1.2085, 3.4878),
        new Point(1.2085, 4.8829),
        new Point(2.5356, 5.314)
      ),
      new Polygon(
        // Curve.018
        new Point(6.9812, 2.0927),
        new Point(6.161, 0.964),
        new Point(4.8339, 1.3951),
        new Point(4.8339, 2.7902),
        new Point(6.161, 3.2213)
      ),
      new Polygon(
        // Curve.019
        new Point(-5.7727, 0),
        new Point(-4.9525, -1.1287),
        new Point(-3.6254, -0.6976),
        new Point(-3.6254, 0.6975),
        new Point(-4.9525, 1.1287)
      ),
      new Polygon(
        // Curve.020
        new Point(-5.8708, 7.9091),
        new Point(-4.8338, 6.9756),
        new Point(-3.6254, 7.6731),
        new Point(-3.9155, 9.0378),
        new Point(-5.3033, 9.1836)
      ),
      new Polygon(
        // Curve.021
        new Point(-0.1714, 2.5543),
        new Point(-1.2084, 3.4878),
        new Point(-2.4169, 2.7902),
        new Point(-2.1268, 1.4256),
        new Point(-0.739, 1.2798)
      ),
      new Polygon(
        // Curve.022
        new Point(3.454, -3.7238),
        new Point(2.417, -2.7903),
        new Point(1.2086, -3.4878),
        new Point(1.4987, -4.8524),
        new Point(2.8865, -4.9983)
      ),
      new Polygon(
        // Curve.023
        new Point(3.4539, 0.4616),
        new Point(2.4169, 1.3951),
        new Point(1.2085, 0.6975),
        new Point(1.4986, -0.6671),
        new Point(2.8863, -0.8129)
      ),
      new Polygon(
        // Curve.024
        new Point(-2.2454, -1.6311),
        new Point(-1.2084, -0.6976),
        new Point(0, -1.3951),
        new Point(-0.2901, -2.7598),
        new Point(-1.6779, -2.9056)
      ),
      new Polygon(
        // Curve.025
        new Point(5.0053, -5.8164),
        new Point(6.0423, -4.8829),
        new Point(7.2508, -5.5805),
        new Point(6.9607, -6.9451),
        new Point(5.5729, -7.0909)
      ),
      new Polygon(
        // Curve.026
        new Point(-5.8708, -3.7238),
        new Point(-4.8338, -2.7903),
        new Point(-3.6254, -3.4878),
        new Point(-3.9155, -4.8524),
        new Point(-5.3033, -4.9983)
      ),
      new Polygon(
        // Curve.027
        new Point(4.8339, 2.7902),
        new Point(6.0423, 3.4878),
        new Point(6.0423, 4.8829),
        new Point(4.8339, 5.5804),
        new Point(3.6254, 4.8829),
        new Point(3.6254, 3.4878)
      ),
      new Polygon(
        // Curve.028
        new Point(7.2508, -5.5805),
        new Point(8.4592, -4.8829),
        new Point(8.4592, -3.4878),
        new Point(7.2508, -2.7902),
        new Point(6.0423, -3.4878),
        new Point(6.0423, -4.8829)
      ),
      new Polygon(
        // Curve.029
        new Point(8.4592, -7.6732),
        new Point(9.6676, -6.9757),
        new Point(9.6676, -5.5805),
        new Point(8.4592, -4.883),
        new Point(7.2507, -5.5805),
        new Point(7.2507, -6.9757)
      ),
      new Polygon(
        // Curve.030
        new Point(7.2506, -9.7658),
        new Point(8.4591, -9.0683),
        new Point(8.4591, -7.6732),
        new Point(7.2506, -6.9756),
        new Point(6.0422, -7.6732),
        new Point(6.0422, -9.0683)
      ),
      new Polygon(
        // Curve.031
        new Point(3.6253, -7.6732),
        new Point(4.8338, -6.9756),
        new Point(4.8338, -5.5805),
        new Point(3.6253, -4.8829),
        new Point(2.4169, -5.5805),
        new Point(2.4169, -6.9756)
      )
    ],
    hinges: [
      [0, 3, dihedHH],
      [0, 7, dihedHH],
      [0, 24, dihedHP],
      [0, 4, dihedHH],
      [7, 19, dihedHP],
      [7, 8, dihedHH],
      [8, 26, dihedHP],
      [8, 9, dihedHH],
      [4, 22, dihedHP],
      [4, 5, dihedHH],
      [5, 6, dihedHH],
      [6, 31, dihedHH],
      [6, 28, dihedHH],
      [28, 25, dihedHP],
      [28, 29, dihedHH],
      [29, 30, dihedHH],
      [3, 23, dihedHP],
      [3, 10, dihedHH],
      [3, 2, dihedHH],
      [10, 18, dihedHP],
      [10, 27, dihedHH],
      [2, 17, dihedHP],
      [2, 11, dihedHH],
      [2, 1, dihedHH],
      [11, 16, dihedHP],
      [11, 12, dihedHH],
      [1, 15, dihedHP],
      [1, 13, dihedHH],
      [1, 21, dihedHP],
      [13, 20, dihedHP],
      [13, 14, dihedHH]
    ]
  };

  // node_modules/@mathigon/boost/dist/index.esm.js
  var __knownSymbol2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
  var __typeError2 = (msg) => {
    throw TypeError(msg);
  };
  var __async2 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var __await2 = function(promise, isYieldStar) {
    this[0] = promise;
    this[1] = isYieldStar;
  };
  var __yieldStar2 = (value) => {
    var obj = value[__knownSymbol2("asyncIterator")], isAwait = false, method, it = {};
    if (obj == null) {
      obj = value[__knownSymbol2("iterator")]();
      method = (k) => it[k] = (x) => obj[k](x);
    } else {
      obj = obj.call(value);
      method = (k) => it[k] = (v) => {
        if (isAwait) {
          isAwait = false;
          if (k === "throw") throw v;
          return v;
        }
        isAwait = true;
        return {
          done: false,
          value: new __await2(new Promise((resolve) => {
            var x = obj[k](v);
            if (!(x instanceof Object)) __typeError2("Object expected");
            resolve(x);
          }), 1)
        };
      };
    }
    return it[__knownSymbol2("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
      throw x;
    }, "return" in obj && method("return"), it;
  };
  var STORAGE_KEY = "_M";
  var UA = window.navigator.userAgent.toLowerCase();
  var MOBILE_REGEX = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;
  var IOS_REGEX = /iphone|ipad|ipod/i;
  var SAFARI_REGEX = /^((?!chrome|android).)*safari/i;
  var _a;
  var BrowserInstance = class {
    constructor() {
      this.isMobile = MOBILE_REGEX.test(UA);
      this.isRetina = (window.devicePixelRatio || 1) > 1;
      this.isTouch = !!window.Touch || "ontouchstart" in window;
      this.isChrome = !!window.chrome;
      this.isFirefox = UA.indexOf("firefox") >= 0;
      this.isAndroid = UA.indexOf("android") >= 0;
      this.isIOS = IOS_REGEX.test(UA);
      this.isSafari = IOS_REGEX.test(UA) || SAFARI_REGEX.test(UA);
      this.loadQueue = [];
      this.loaded = false;
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.resizeCallbacks = [];
      this.theme = { name: "light", isDark: false };
      this.themeChangedCallbacks = [];
      this.themeOverride = "";
      this.darkQuery = (_a = window.matchMedia) == null ? void 0 : _a.call(window, "(prefers-color-scheme: dark)");
      var _a2, _b;
      window.onload = () => this.afterLoad();
      document.addEventListener("DOMContentLoaded", () => this.afterLoad());
      const applyResizeThrottled = throttle(() => this.applyResize());
      window.addEventListener("resize", applyResizeThrottled);
      try {
        (_a2 = this.darkQuery) == null ? void 0 : _a2.addEventListener("change", () => this.applyThemeChange());
      } catch (e2) {
        (_b = this.darkQuery) == null ? void 0 : _b.addListener(() => this.applyThemeChange());
      }
      const initial = this.getCookie("theme");
      if (initial) this.setTheme(initial);
      try {
        this.localStorage = window.localStorage;
      } catch (e2) {
        console.warn("Unable to access Local Storage in this context.");
      }
    }
    afterLoad() {
      if (this.loaded) return;
      this.loaded = true;
      for (const fn of this.loadQueue) fn();
      setTimeout(() => this.resize());
    }
    /** Binds an event listener that is triggered when the page is loaded. */
    ready(fn) {
      if (this.loaded) {
        fn();
      } else {
        this.loadQueue.push(fn);
      }
    }
    /** Forces a re-paint. This is useful when updating transition properties. */
    redraw() {
      document.body.offsetHeight;
    }
    applyResize() {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;
      if (this.width === newWidth && this.height === newHeight) return;
      this.width = newWidth;
      this.height = newHeight;
      for (const fn of this.resizeCallbacks) fn({ width: this.width, height: this.height });
      $body.trigger("scroll", { top: $body.scrollTop });
    }
    onResize(fn) {
      fn({ width: this.width, height: this.height });
      this.resizeCallbacks.push(fn);
    }
    offResize(fn) {
      const i = this.resizeCallbacks.indexOf(fn);
      if (i >= 0) this.resizeCallbacks.splice(i, 1);
    }
    resize() {
      this.applyResize();
    }
    applyThemeChange() {
      const name = this.theme.name;
      const isDark = name === "dark" || name === "auto" && this.darkQuery.matches;
      if (isDark === this.theme.isDark) return;
      this.theme.isDark = isDark;
      for (const c2 of this.themeChangedCallbacks) c2(this.theme);
      setTimeout(() => $html.setAttr("theme", this.themeOverride || (isDark ? "dark" : "light")));
    }
    setTheme(name) {
      if (name === this.theme.name) return;
      this.theme.name = name;
      this.setCookie("theme", name);
      this.applyThemeChange();
    }
    onThemeChange(fn) {
      this.themeChangedCallbacks.push(fn);
    }
    // ---------------------------------------------------------------------------
    // Location
    /** Returns the hash string of the current window. */
    getHash() {
      return window.location.hash.slice(1);
    }
    /** Set the hash string of the current window. */
    setHash(h) {
      const scroll = document.body.scrollTop;
      window.location.hash = h;
      document.body.scrollTop = scroll;
    }
    /** Set the URL of the current window. */
    setURL(url2, title = "") {
      window.history.replaceState({}, title, url2);
      if (title) window.document.title = title;
    }
    // ---------------------------------------------------------------------------
    // Cookies
    /** Returns a JSON object of all cookies. */
    getCookies() {
      const pairs = document.cookie.split(";");
      const result = {};
      for (let i = 0, n = pairs.length; i < n; ++i) {
        const pair = pairs[i].split("=");
        result[decodeURIComponent(pair[0]).trim()] = decodeURIComponent(pair[1]);
      }
      return result;
    }
    getCookie(name) {
      const v = document.cookie.match(new RegExp(`(^|;) ?${name}=([^;]*)(;|$)`));
      return v ? v[2] : void 0;
    }
    setCookie(name, value, maxAge = 60 * 60 * 24 * 365) {
      const domain = window.location.hostname.replace(/^[a-z]{2}\./, "");
      document.cookie = `${name}=${value};path=/;max-age=${maxAge};domain=${domain}`;
    }
    deleteCookie(name) {
      this.setCookie(name, "", -1);
    }
    setStorage(key, value) {
      var _a2, _b;
      const keys = (key || "").split(".");
      const storage = safeToJSON(((_a2 = this.localStorage) == null ? void 0 : _a2.getItem(STORAGE_KEY)) || void 0, {});
      let path = storage;
      for (let i = 0; i < keys.length - 1; ++i) {
        if (path[keys[i]] === void 0) path[keys[i]] = {};
        path = path[keys[i]];
      }
      path[keys[keys.length - 1]] = value;
      (_b = this.localStorage) == null ? void 0 : _b.setItem(STORAGE_KEY, JSON.stringify(storage));
    }
    getStorage(key) {
      var _a2;
      let path = safeToJSON((_a2 = this.localStorage) == null ? void 0 : _a2.getItem(STORAGE_KEY), {});
      if (!key) return path;
      const keys = (key || "").split(".");
      const lastKey = keys.pop();
      for (const k of keys) {
        if (!(k in path)) return;
        path = path[k];
      }
      return path[lastKey];
    }
    deleteStorage(key) {
      var _a2;
      if (key) {
        this.setStorage(key, void 0);
      } else {
        (_a2 = this.localStorage) == null ? void 0 : _a2.setItem(STORAGE_KEY, "");
      }
    }
    // ---------------------------------------------------------------------------
    // Keyboard Event Handling
    /** The current active element on the page (e.g. and `<input>`). */
    getActiveInput() {
      let active = document.activeElement;
      if (active == null ? void 0 : active.shadowRoot) active = active.shadowRoot.activeElement;
      return active === document.body ? void 0 : $(active);
    }
    get formIsActive() {
      var _a2;
      return !!((_a2 = this.getActiveInput()) == null ? void 0 : _a2.is("input, select, textarea, [contenteditable]"));
    }
  };
  var Browser = window.BoostBrowser || new BrowserInstance();
  window.BoostBrowser = Browser;
  var IEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/;
  var webkitUA = /\bAppleWebKit\/(\d+)\b/;
  var EdgeUA = /\bEdge\/12\.(\d+)\b/;
  var polyfill = IEUA.test(navigator.userAgent) || +(navigator.userAgent.match(EdgeUA) || [])[1] < 10547 || +(navigator.userAgent.match(webkitUA) || [])[1] < 537;
  var requests = {};
  function replaceSvgImports() {
    if (!polyfill) return;
    const uses = Array.from(document.querySelectorAll("svg > use"));
    uses.forEach(function(use) {
      const src = use.getAttribute("xlink:href");
      const [url2, id] = src.split("#");
      if (!url2.length || !id) return;
      const svg = use.parentNode;
      svg.removeChild(use);
      if (!(url2 in requests)) requests[url2] = fetch(url2).then((r) => r.text());
      const request = requests[url2];
      request.then((response) => {
        const doc = document.implementation.createHTMLDocument("");
        doc.documentElement.innerHTML = response;
        const icon = doc.getElementById(id);
        const clone = icon.cloneNode(true);
        const fragment = document.createDocumentFragment();
        while (clone.childNodes.length) fragment.appendChild(clone.firstChild);
        svg.appendChild(fragment);
      });
    });
  }
  var KEY_FALLBACKS = new Map(Object.entries({
    " ": "Space",
    "Spacebar": "Space",
    "Del": "Delete",
    "Esc": "Escape",
    "Left": "ArrowLeft",
    "Right": "ArrowRight",
    "Down": "ArrowDown",
    "Up": "ArrowUp"
  }));
  function keyCode(e2) {
    return KEY_FALLBACKS.get(e2.key) || e2.key;
  }
  var isReady = false;
  setTimeout(() => isReady = true);
  var BOUNCE_IN = "cubic-bezier(0.175, 0.885, 0.32, 1.275)";
  var BOUNCE_OUT = "cubic-bezier(0.68, -0.275, 0.825, 0.115)";
  var ResolvedAnimation = { cancel: () => void 0, promise: Promise.resolve() };
  function animate(callback, duration) {
    if (duration === 0) {
      callback(1, 0, () => void 0);
      return ResolvedAnimation;
    }
    const startTime = Date.now();
    const deferred = defer();
    let lastTime = 0;
    let running = true;
    const cancel = () => {
      running = false;
      deferred.reject();
    };
    function getFrame() {
      if (!running) return;
      if (!duration || lastTime <= duration) {
        window.requestAnimationFrame(getFrame);
      }
      const time = Date.now() - startTime;
      callback(duration ? Math.min(1, time / duration) : time, time - lastTime, cancel);
      if (duration && time >= duration) deferred.resolve();
      lastTime = time;
    }
    getFrame();
    return { cancel, promise: deferred.promise };
  }
  function easeIn(type, t = 0, s = 0) {
    switch (type) {
      case "quad":
        return t ** 2;
      case "cubic":
        return t ** 3;
      case "quart":
        return t ** 4;
      case "quint":
        return t ** 5;
      case "circ":
        return 1 - Math.sqrt(1 - t ** 2);
      case "sine":
        return 1 - Math.cos(t * Math.PI / 2);
      case "exp":
        return t <= 0 ? 0 : Math.pow(2, 10 * (t - 1));
      case "back":
        if (!s) s = 1.70158;
        return t * t * ((s + 1) * t - s);
      case "elastic":
        if (!s) s = 0.3;
        return -Math.pow(2, 10 * (t - 1)) * Math.sin(((t - 1) * 2 / s - 0.5) * Math.PI);
      case "swing":
        return 0.5 - Math.cos(t * Math.PI) / 2;
      case "spring":
        return 1 - Math.cos(t * 4.5 * Math.PI) * Math.exp(-t * 6);
      case "bounce":
        if (t < 1 / 11) return 1 / 64 - 7.5625 * (0.5 / 11 - t) * (0.5 / 11 - t);
        if (t < 3 / 11) return 1 / 16 - 7.5625 * (2 / 11 - t) * (2 / 11 - t);
        if (t < 7 / 11) return 1 / 4 - 7.5625 * (5 / 11 - t) * (5 / 11 - t);
        return 1 - 7.5625 * (1 - t) * (1 - t);
      default:
        return t;
    }
  }
  function ease(type, t = 0, s = 0) {
    if (t === 0) return 0;
    if (t === 1) return 1;
    const [name, direction] = type.split("-");
    if (direction === "in") return easeIn(name, t, s);
    if (direction === "out") return 1 - easeIn(name, 1 - t, s);
    if (t <= 0.5) return easeIn(name, 2 * t, s) / 2;
    return 1 - easeIn(name, 2 * (1 - t), s) / 2;
  }
  function transition($el, properties, duration = 400, _delay = 0, easing = "ease-in-out") {
    if (!isReady) {
      Object.keys(properties).forEach((k) => {
        const p = properties[k];
        $el.css(k, Array.isArray(p) ? p[1] : p);
      });
      return ResolvedAnimation;
    }
    if (easing === "bounce-in") easing = BOUNCE_IN;
    if (easing === "bounce-out") easing = BOUNCE_OUT;
    let oldTransition = "";
    if (Browser.isSafari) {
      oldTransition = $el._el.style.transition;
      $el.css("transition", "none");
      Browser.redraw();
    }
    const currentAnimation = $el._data.animation;
    if (currentAnimation) currentAnimation.cancel();
    const to = {};
    const from = {};
    const deferred = defer();
    const style2 = window.getComputedStyle($el._el);
    Object.keys(properties).forEach((k) => {
      const p = properties[k];
      const k1 = toCamelCase(k);
      from[k1] = Array.isArray(p) ? p[0] : style2.getPropertyValue(k);
      to[k1] = Array.isArray(p) ? p[1] : p;
      if (_delay) $el.css(k, from[k1]);
    });
    const oldHeight = to.height;
    if (to.height === "auto") {
      const children = $el.children.filter((c2) => c2.css("position") !== "absolute");
      to.height = `${total(children.map(($c) => $c.outerHeight))}px`;
    }
    let player;
    let cancelled = false;
    delay(() => {
      if (cancelled) return;
      player = $el._el.animate([from, to], { duration, easing, fill: "forwards" });
      player.onfinish = () => {
        if ($el._el) {
          Object.keys(properties).forEach((k) => $el.css(k, k === "height" ? oldHeight : to[k]));
        }
        if (Browser.isSafari) $el.css("transition", oldTransition);
        deferred.resolve();
        player.cancel();
        $el._data.animation = void 0;
      };
    }, _delay);
    const animation = {
      cancel() {
        if (cancelled) return;
        cancelled = true;
        if ($el._el) Object.keys(properties).forEach((k) => $el.css(k, $el.css(k)));
        if (player) player.cancel();
        $el._data.animation = void 0;
      },
      promise: deferred.promise
    };
    setTimeout(() => $el._data.animation = animation);
    return animation;
  }
  var CSS_MATRIX = /matrix\([0-9.\-\s]+,[0-9.\-\s]+,[0-9.\-\s]+,[0-9.\-\s]+,([0-9.\-\s]+),([0-9.\-\s]+)\)/;
  function enter($el, effect = "fade", duration = 500, _delay = 0) {
    $el.show();
    if (!isReady) return ResolvedAnimation;
    const opacity = $el._data.animation ? 1 : +$el.css("opacity") || 1;
    if (effect === "fade") {
      return transition($el, { opacity: [0, opacity] }, duration, _delay);
    } else if (effect === "pop") {
      const transform = $el.transform.replace(/scale\([0-9.]*\)/, "").replace(CSS_MATRIX, "translate($1px,$2px)");
      transition($el, { opacity: [0, opacity] }, duration, _delay);
      return transition($el, {
        transform: [`${transform} scale(0.5)`, `${transform} scale(1)`]
      }, duration, _delay, "bounce-in");
    } else if (effect === "descend") {
      const rules = { opacity: [0, 1], transform: ["translateY(-50%)", "none"] };
      return transition($el, rules, duration, _delay);
    } else if (effect.startsWith("draw")) {
      const l = $el.strokeLength;
      $el.css("stroke-dasharray", `${l}px`);
      if (!$el.css("opacity")) $el.css("opacity", 1);
      const end = effect === "draw-reverse" ? `${2 * l}px` : 0;
      const rules = { "stroke-dashoffset": [`${l}px`, end] };
      const animation = transition($el, rules, duration, _delay, "linear");
      animation.promise.then(() => $el.css("stroke-dasharray", ""));
      return animation;
    } else if (effect.startsWith("slide")) {
      const rules = { opacity: [0, opacity], transform: ["translateY(50px)", "none"] };
      if (effect.includes("down")) rules.transform[0] = "translateY(-50px)";
      if (effect.includes("right")) rules.transform[0] = "translateX(-50px)";
      if (effect.includes("left")) rules.transform[0] = "translateX(50px)";
      return transition($el, rules, duration, _delay);
    } else if (effect.startsWith("reveal")) {
      const rules = { opacity: [0, opacity], height: [0, "auto"] };
      if (effect.includes("left")) rules.transform = ["translateX(-50%)", "none"];
      if (effect.includes("right")) rules.transform = ["translateX(50%)", "none"];
      return transition($el, rules, duration, _delay);
    }
    return ResolvedAnimation;
  }
  function exit($el, effect = "fade", duration = 400, delay3 = 0, remove = false) {
    if (!$el._el) return ResolvedAnimation;
    if (!isReady) {
      $el.hide();
      return ResolvedAnimation;
    }
    if ($el.css("display") === "none") return ResolvedAnimation;
    let animation;
    if (effect === "fade") {
      animation = transition($el, { opacity: [1, 0] }, duration, delay3);
    } else if (effect === "pop") {
      const transform = $el.transform.replace(/scale\([0-9.]*\)/, "");
      transition($el, { opacity: [1, 0] }, duration, delay3);
      animation = transition($el, {
        transform: [`${transform} scale(1)`, `${transform} scale(0.5)`]
      }, duration, delay3, "bounce-out");
    } else if (effect === "ascend") {
      const rules = { opacity: [1, 0], transform: ["none", "translateY(-50%)"] };
      animation = transition($el, rules, duration, delay3);
    } else if (effect.startsWith("draw")) {
      const l = $el.strokeLength;
      $el.css("stroke-dasharray", l);
      const start = effect === "draw-reverse" ? `${2 * l}px` : 0;
      const rules = { "stroke-dashoffset": [start, `${l}px`] };
      animation = transition($el, rules, duration, delay3, "linear");
    } else if (effect.startsWith("slide")) {
      const rules = { opacity: 0, transform: "translateY(50px)" };
      if (effect.includes("up")) rules.transform = "translateY(-50px)";
      animation = transition($el, rules, duration, delay3);
    } else if (effect.startsWith("reveal")) {
      const rules = { opacity: 0, height: 0 };
      if (effect.includes("left")) rules.transform = "translateX(-50%)";
      if (effect.includes("right")) rules.transform = "translateX(50%)";
      animation = transition($el, rules, duration, delay3);
    }
    animation.promise.then(() => remove ? $el.remove() : $el.hide());
    return animation;
  }
  var BINARY_OPS = {
    // TODO Operator overloading (e.g. add vectors or complex numbers)
    "===": (a2, b2) => a2 === b2,
    "!==": (a2, b2) => a2 !== b2,
    "||": (a2, b2) => a2 || b2,
    "&&": (a2, b2) => a2 && b2,
    // eslint-disable-next-line eqeqeq
    "==": (a2, b2) => a2 == b2,
    // eslint-disable-next-line eqeqeq
    "!=": (a2, b2) => a2 != b2,
    "<=": (a2, b2) => a2 <= b2,
    ">=": (a2, b2) => a2 >= b2,
    "**": (a2, b2) => a2 ** b2,
    "<": (a2, b2) => a2 < b2,
    ">": (a2, b2) => a2 > b2,
    "+": (a2, b2) => a2 + b2,
    "-": (a2, b2) => a2 - b2,
    "*": (a2, b2) => a2 * b2,
    "/": (a2, b2) => a2 / b2,
    "%": (a2, b2) => a2 % b2
  };
  var UNARY_OPS = {
    "-": (a2) => -a2,
    "+": (a2) => +a2,
    "!": (a2) => !a2
  };
  var BINARY_PRECEDENCE = {
    "||": 1,
    "&&": 2,
    "==": 3,
    "!=": 3,
    "===": 3,
    "!==": 3,
    "<": 4,
    ">": 4,
    "<=": 4,
    ">=": 4,
    "+": 5,
    "-": 5,
    "*": 6,
    "/": 6,
    "%": 6,
    "**": 7
    // TODO Exponentiation should be right-to-left.
  };
  var LITERALS = {
    "true": true,
    "false": false,
    "undefined": void 0
  };
  var SPACE = /\s/;
  var DIGIT = /[0-9]/;
  var IDENTIFIER_START = /[a-zA-Z--$_]/;
  var IDENTIFIER_PART = /[0-9a-zA-Z--$_]/;
  function parseSyntaxTree(expr) {
    const length = expr.length;
    let index = 0;
    function throwError(message) {
      throw new Error(`${message} at character ${index} of "${expr}"`);
    }
    function gobbleSpaces() {
      while (SPACE.test(expr[index])) index += 1;
    }
    function gobbleNumericLiteral() {
      var _a2;
      const number = ((_a2 = expr.slice(index).match(/^\d*(\.\d+)?([eE][+-]?\d+)?/)) == null ? void 0 : _a2[0]) || "";
      index += number.length;
      const char = expr[index];
      if (char && (IDENTIFIER_START.test(char) || char === ".")) {
        throwError(`Unexpected character (${number + char})`);
      }
      return { type: 5, value: parseFloat(number) };
    }
    function gobbleStringLiteral() {
      const quote = expr[index];
      index += 1;
      let closed = false;
      let string = "";
      while (index < length) {
        const char = expr[index++];
        if (char === quote) {
          closed = true;
          break;
        }
        string += char;
      }
      if (!closed) throwError(`Unclosed quote after "${string}"`);
      return { type: 5, value: string };
    }
    function gobbleIdentifier() {
      let name = expr[index];
      if (!IDENTIFIER_START.test(expr[index])) throwError(`Unexpected ${name}`);
      index += 1;
      while (index < length) {
        if (IDENTIFIER_PART.test(expr[index])) {
          name += expr[index++];
        } else {
          break;
        }
      }
      if (name in LITERALS) {
        return { type: 5, value: LITERALS[name] };
      } else {
        return { type: 4, name };
      }
    }
    function gobbleArguments(termination) {
      const args = [];
      let closed = false;
      let lastArg = void 0;
      while (index < length) {
        if (expr[index] === termination) {
          if (lastArg) args.push(lastArg);
          closed = true;
          index += 1;
          break;
        } else if (expr[index] === ",") {
          args.push(lastArg || { type: 5, value: void 0 });
          index += 1;
        } else {
          lastArg = gobbleExpression();
        }
      }
      if (!closed) throwError(`Expected ${termination}`);
      return args;
    }
    function gobbleVariable() {
      let node2;
      if (expr[index] === "(") {
        index += 1;
        node2 = gobbleExpression();
        gobbleSpaces();
        if (expr[index] === ")") {
          index += 1;
          return node2;
        } else {
          throwError("Unclosed (");
        }
      } else {
        node2 = gobbleIdentifier();
      }
      gobbleSpaces();
      while (".[(".includes(expr[index])) {
        if (expr[index] === ".") {
          index++;
          gobbleSpaces();
          node2 = {
            type: 6,
            object: node2,
            computed: false,
            property: gobbleIdentifier()
          };
        } else if (expr[index] === "[") {
          index++;
          node2 = {
            type: 6,
            object: node2,
            computed: true,
            property: gobbleExpression()
          };
          gobbleSpaces();
          if (expr[index] !== "]") throwError("Unclosed [");
          index++;
        } else if (expr[index] === "(") {
          index++;
          node2 = {
            type: 2,
            args: gobbleArguments(")"),
            callee: node2
          };
        }
        gobbleSpaces();
      }
      return node2;
    }
    function gobbleBinaryOp() {
      gobbleSpaces();
      for (const length2 of [3, 2, 1]) {
        const substr = expr.substr(index, length2);
        if (substr in BINARY_OPS) {
          index += length2;
          return substr;
        }
      }
    }
    function gobbleToken() {
      gobbleSpaces();
      const operator = expr[index];
      if (DIGIT.test(operator) || operator === ".") {
        return gobbleNumericLiteral();
      } else if (operator === "'" || operator === '"') {
        return gobbleStringLiteral();
      } else if (operator === "[") {
        index += 1;
        return { type: 0, elements: gobbleArguments("]") };
      } else if (operator in UNARY_OPS) {
        index += 1;
        return { type: 7, operator, argument: gobbleToken() };
      } else if (IDENTIFIER_START.test(operator) || operator === "(") {
        return gobbleVariable();
      }
      throwError("Expression parsing error");
    }
    function gobbleBinaryExpression() {
      let left = gobbleToken();
      let biop = gobbleBinaryOp();
      if (!biop) return left;
      let right = gobbleToken();
      if (!right) throwError(`Expected expression after ${biop}`);
      let node2;
      const stack = [left, biop, right];
      while (biop = gobbleBinaryOp()) {
        const prec = BINARY_PRECEDENCE[biop];
        const curBiop = biop;
        while (stack.length > 2 && prec <= BINARY_PRECEDENCE[stack[stack.length - 2]]) {
          right = stack.pop();
          biop = stack.pop();
          left = stack.pop();
          node2 = { type: 1, operator: biop, left, right };
          stack.push(node2);
        }
        node2 = gobbleToken();
        if (!node2) throwError(`Expected expression after ${curBiop}`);
        stack.push(curBiop, node2);
      }
      let i = stack.length - 1;
      node2 = stack[i];
      while (i > 1) {
        node2 = {
          type: 1,
          operator: stack[i - 1],
          left: stack[i - 2],
          right: node2
        };
        i -= 2;
      }
      return node2;
    }
    function gobbleExpression() {
      const test = gobbleBinaryExpression();
      gobbleSpaces();
      if (test && expr[index] === "?") {
        index += 1;
        const consequent = gobbleExpression();
        if (!consequent) throwError("Expected expression");
        gobbleSpaces();
        if (expr[index] === ":") {
          index++;
          const alternate = gobbleExpression();
          if (!alternate) throwError("Expected expression");
          return { type: 3, test, consequent, alternate };
        } else {
          throwError("Expected :");
        }
      } else {
        return test;
      }
    }
    const node = gobbleExpression();
    if (index < expr.length) throwError(`Unexpected "${expr[index]}"`);
    return node;
  }
  var EMPTY = [void 0, void 0];
  var FORBIDDEN_KEYS = ["__proto__", "constructor", "prototype"];
  function evaluate(node, context, local) {
    switch (node.type) {
      case 0:
        const v1 = node.elements.map((n) => evaluate(n, context, local)[0]);
        if (v1.some((v) => v === void 0)) return EMPTY;
        return [v1, void 0];
      case 1:
        const left = evaluate(node.left, context, local)[0];
        const right = evaluate(node.right, context, local)[0];
        if ("+-**/%".includes(node.operator) && (left === void 0 || right === void 0)) return EMPTY;
        return [BINARY_OPS[node.operator](left, right), void 0];
      case 2:
        const [fn, self] = evaluate(node.callee, context, local);
        if (fn === Function || fn === eval) return EMPTY;
        const args = node.args.map((n) => evaluate(n, context, local)[0]);
        if (args.some((v) => v === void 0) || typeof fn !== "function") return EMPTY;
        return [fn.apply(self, args), void 0];
      case 3:
        const consequent = evaluate(node.consequent, context, local);
        const alternate = evaluate(node.alternate, context, local);
        return evaluate(node.test, context, local)[0] ? consequent : alternate;
      case 4:
        if (FORBIDDEN_KEYS.includes(node.name)) return EMPTY;
        return [local[node.name] || context[node.name], void 0];
      case 5:
        return [node.value, void 0];
      case 6:
        const object = evaluate(node.object, context, local)[0];
        const property = node.computed ? evaluate(node.property, context, local)[0] : node.property.name;
        if (FORBIDDEN_KEYS.includes(property)) return EMPTY;
        return object ? [object[property], object] : [void 0, void 0];
      case 7:
        const arg = evaluate(node.argument, context, local)[0];
        if (arg === void 0 && node.operator !== "!") return EMPTY;
        return [UNARY_OPS[node.operator](arg), void 0];
    }
  }
  function compile(expr) {
    const node = parseSyntaxTree(expr);
    if (!node) return (_context = {}) => void 0;
    return (context = {}, local = {}) => evaluate(node, context, local)[0];
  }
  var TEMPLATE = /\${([^}]+)}/g;
  function compileString(expr, isAttribute = false) {
    const parts = expr.split(TEMPLATE);
    const fns = parts.map((p, i) => i % 2 ? compile(p.replace(//g, "*")) : void 0);
    return (context) => {
      return parts.map((p, i) => {
        if (!(i % 2)) return p;
        const value = fns[i](context);
        return !isAttribute && typeof value === "number" && value < 0 ? `\u2013${-value}` : value;
      }).join("");
    };
  }
  var touchSupport = "ontouchstart" in window;
  var pointerSupport = "onpointerdown" in window;
  function pointerPosition(e2) {
    if (e2.touches) {
      const touches = e2.targetTouches.length ? e2.targetTouches : e2.changedTouches;
      return new Point(touches[0].clientX, touches[0].clientY);
    } else {
      return new Point(e2.clientX || 0, e2.clientY || 0);
    }
  }
  function getTouches(e2) {
    return e2.touches || [];
  }
  function svgPointerPosn(event, $svg) {
    const posn = pointerPosition(event);
    return posn.transform($svg.inverseTransformMatrix);
  }
  function canvasPointerPosition(event, $canvas) {
    const posn = pointerPosition(event);
    const bounds = $canvas.bounds;
    const x = (posn.x - bounds.left) * $canvas.canvasWidth / bounds.width;
    const y = (posn.y - bounds.top) * $canvas.canvasHeight / bounds.height;
    return new Point(x, y);
  }
  function getEventTarget(event) {
    if (event instanceof PointerEvent && event.pointerType === "mouse") {
      return $(event.target);
    }
    const posn = pointerPosition(event);
    return $(document.elementFromPoint(posn.x, posn.y) || void 0);
  }
  function makeTapEvent($el) {
    if ($el._data["tapEvent"]) return;
    $el._data["tapEvent"] = true;
    let start = void 0;
    $el.on("pointerdown", (e2) => start = pointerPosition(e2));
    $el.on("pointerup", (e2) => {
      if (!start) return;
      const end = pointerPosition(e2);
      if (Point.distance(start, end) < 6) $el.trigger("tap", e2);
      start = void 0;
    });
    $el.on("pointercancel", () => start = void 0);
  }
  function makeClickOutsideEvent($el) {
    if ($el._data["clickOutsideEvent"]) return;
    $el._data["clickOutsideEvent"] = true;
    $body.on("pointerdown", (e2) => {
      const target = e2.composedPath()[0] || e2.target;
      if (!target || $el._el === target || $el._el.contains(target)) return;
      $el.trigger("clickOutside", e2);
    });
  }
  function slide($el, fns) {
    const $box = fns.$box || $el;
    let posn = pointerPosition;
    if ($box.type === "svg") {
      posn = (e2) => svgPointerPosn(e2, $box.$ownerSVG);
    } else if ($box.type === "canvas") {
      posn = (e2) => canvasPointerPosition(e2, $box);
    }
    const $parent = fns.justInside ? $el : $body;
    let startPosn = void 0;
    let lastPosn = void 0;
    let hasMoved = false;
    let pointerId = 0;
    if ($el.css("touch-action") === "auto") $el.css("touch-action", "none");
    $el.addClass("noselect");
    function start(e2) {
      if (e2.handled || getTouches(e2).length > 1) return;
      e2.preventDefault();
      hasMoved = false;
      pointerId = e2.pointerId || 0;
      $parent.on("pointermove", move);
      $parent.on("pointerstop", end);
      startPosn = lastPosn = posn(e2);
      if (fns.down) fns.down(startPosn);
    }
    function move(e2) {
      if (!startPosn) return;
      if (pointerId && e2.pointerId !== pointerId) return;
      e2.preventDefault();
      const p = posn(e2);
      if (Point.distance(p, lastPosn) < 0.5) return;
      if (!hasMoved && fns.start) fns.start(startPosn);
      if (fns.move) fns.move(p, startPosn, lastPosn);
      lastPosn = p;
      hasMoved = true;
    }
    function end(e2, preventClick = false) {
      if (!startPosn) return;
      if (pointerId && e2.pointerId !== pointerId) return;
      e2.preventDefault();
      $parent.off("pointermove", move);
      $parent.off("pointerstop", end);
      if (fns.up) fns.up(lastPosn, startPosn);
      if (hasMoved && fns.end) fns.end(lastPosn, startPosn);
      if (!hasMoved && fns.click && !preventClick) fns.click(startPosn);
      startPosn = void 0;
    }
    $body.onKey("Escape", () => {
      if (!startPosn) return;
      if (hasMoved && fns.move) fns.move(startPosn, startPosn, lastPosn);
      lastPosn = startPosn;
      const event = document.createEvent("MouseEvent");
      event.pointerId = pointerId;
      end(event, true);
    });
    $el.on("pointerdown", start);
    if (fns.justInside) $el.on("mouseleave", end);
    if (fns.accessible) {
      $el.setAttr("tabindex", "0");
      document.addEventListener("keydown", (e2) => {
        if (![37, 38, 39, 40].includes(e2.keyCode)) return;
        if ($el !== Browser.getActiveInput()) return;
        const center = $el.boxCenter;
        const start2 = posn({ clientX: center.x, clientY: center.y });
        const dx = e2.keyCode === 37 ? -25 : e2.keyCode === 39 ? 25 : 0;
        const dy = e2.keyCode === 38 ? -25 : e2.keyCode === 40 ? 25 : 0;
        const end2 = start2.shift(dx, dy);
        if (fns.down) fns.down(start2);
        if (fns.start) fns.start(start2);
        if (fns.move) fns.move(end2, start2, start2);
        if (fns.end) fns.end(end2, start2);
      });
    }
  }
  function makeScrollEvents($el) {
    if ($el._data["scrollEvents"]) return;
    $el._data["scrollEvents"] = true;
    let ticking = false;
    let top = void 0;
    function tick() {
      const newTop = $el.scrollTop;
      if (newTop === top) {
        ticking = false;
        return;
      }
      top = newTop;
      $el.trigger("scroll", { top });
      window.requestAnimationFrame(tick);
    }
    function scroll() {
      if (!ticking) window.requestAnimationFrame(tick);
      ticking = true;
    }
    const target = $el.type === "window" ? window : $el._el;
    target.addEventListener("scroll", scroll);
    function touchStart() {
      window.addEventListener("touchmove", scroll);
      window.addEventListener("touchend", touchEnd);
    }
    function touchEnd() {
      window.removeEventListener("touchmove", scroll);
      window.removeEventListener("touchend", touchEnd);
    }
    $el._el.addEventListener("touchstart", function(e2) {
      if (!e2.handled) touchStart();
    });
  }
  var observer;
  function intersectionCallback(entries) {
    for (const e2 of entries) {
      const event = e2.isIntersecting ? "enterViewport" : "exitViewport";
      setTimeout(() => $(e2.target).trigger(event));
    }
  }
  function makeIntersectionEvents($el) {
    if ($el._data["intersectionEvents"]) return;
    $el._data["intersectionEvents"] = true;
    if (!window.IntersectionObserver) {
      let wasVisible = false;
      $body.on("scroll", () => {
        const isVisible = $el.isInViewport;
        if (wasVisible && !isVisible) {
          $el.trigger("exitViewport");
          wasVisible = false;
        } else if (isVisible && !wasVisible) {
          $el.trigger("enterViewport");
          wasVisible = true;
        }
      });
      return;
    }
    if (!observer) observer = new IntersectionObserver(intersectionCallback);
    observer.observe($el._el);
  }
  function makeResizeEvents($el, remove = false) {
    if (remove) {
      if ($el._data["resizeObserver"]) $el._data["resizeObserver"].disconnect();
      $el._data["resizeObserver"] = void 0;
    }
    if ($el._data["resizeObserver"]) return;
    if (window.ResizeObserver) {
      const observer2 = new window.ResizeObserver(() => $el.trigger("resize"));
      observer2.observe($el._el);
      $el._data["resizeObserver"] = observer2;
    } else if (window.MutationObserver) {
      const observer2 = new MutationObserver(() => $el.trigger("resize"));
      observer2.observe($el._el, { attributes: true, childList: true, characterData: true, subtree: true });
      $el._data["resizeObserver"] = observer2;
    }
  }
  function makePointerPositionEvents($el) {
    if ($el._data["pointerPositionEvents"]) return;
    $el._data["pointerPositionEvents"] = true;
    const parent = $el.parent;
    let isInside;
    parent.on("pointerend", () => isInside = void 0);
    parent.on("pointermove", (e2) => {
      const wasInside = isInside;
      const target = getEventTarget(e2);
      isInside = target.equals($el) || target.hasParent($el);
      if (wasInside !== void 0 && isInside && !wasInside) $el.trigger("pointerenter", e2);
      if (!isInside && wasInside) $el.trigger("pointerleave", e2);
    });
  }
  function makeMouseEvent(eventName, $el) {
    if ($el._data[`_${eventName}`]) return;
    $el._data[`_${eventName}`] = true;
    if (pointerSupport) {
      $el.on(eventName.replace("mouse", "pointer"), (e2) => {
        if (e2.pointerType === "mouse") $el.trigger(eventName, e2);
      });
    } else if (!touchSupport) {
      $el._el.addEventListener(eventName, (e2) => $el.trigger(eventName, e2));
    }
  }
  function makeKeyEvent($el) {
    $el.on("keydown", (e2) => {
      if (e2.metaKey || e2.ctrlKey) return;
      if (Browser.isAndroid && e2.keyCode === 229) return;
      const key = e2.key || String.fromCharCode(e2.which);
      const shift = !!e2.shiftKey;
      $el.trigger("key", { code: e2.keyCode, key, char: key, shift });
    });
    if (Browser.isAndroid && $el.type === "input") {
      $el.on("input", (e2) => {
        const key = e2.key || e2.data[e2.data.length - 1];
        $el.trigger("key", { code: void 0, key, char: key });
        $el.value = "";
      });
    }
  }
  var aliases = {
    scrollwheel: "DOMMouseScroll mousewheel",
    pointerdown: pointerSupport ? "pointerdown" : touchSupport ? "touchstart" : "mousedown",
    pointermove: pointerSupport ? "pointermove" : touchSupport ? "touchmove" : "mousemove",
    pointerup: pointerSupport ? "pointerup" : touchSupport ? "touchend" : "mouseup",
    pointercancel: pointerSupport ? "pointercancel" : "touchcancel",
    pointerstop: pointerSupport ? "pointerup pointercancel" : touchSupport ? "touchend touchcancel" : "mouseup"
  };
  var customEvents = {
    scroll: makeScrollEvents,
    tap: makeTapEvent,
    clickOutside: makeClickOutsideEvent,
    key: makeKeyEvent,
    mousedown: makeMouseEvent.bind(void 0, "mousedown"),
    mousemove: makeMouseEvent.bind(void 0, "mousemove"),
    mouseup: makeMouseEvent.bind(void 0, "mouseup"),
    pointerenter: makePointerPositionEvents,
    pointerleave: makePointerPositionEvents,
    enterViewport: makeIntersectionEvents,
    exitViewport: makeIntersectionEvents,
    resize: makeResizeEvents
  };
  function bindEvent($el, event, fn, options) {
    if (event in customEvents) {
      customEvents[event]($el, false);
    } else if (event in aliases) {
      const events = words(aliases[event]);
      for (const e2 of events) $el._el.addEventListener(e2, fn, options);
    } else {
      $el._el.addEventListener(event, fn, options);
    }
  }
  function unbindEvent($el, event, fn) {
    if (event in customEvents) {
      if (!$el._events[event] || !$el._events[event].length) {
        customEvents[event]($el, true);
      }
    } else if (fn && event in aliases) {
      const events = words(aliases[event]);
      for (const e2 of events) $el._el.removeEventListener(e2, fn);
    } else if (fn) {
      $el._el.removeEventListener(event, fn);
    }
  }
  var batchDepth = 0;
  var batchedCallbacks = /* @__PURE__ */ new Map();
  function enqueueCallback(callback, state) {
    batchedCallbacks.set(callback, state);
  }
  function batch(callback) {
    batchDepth++;
    callback();
    batchDepth--;
    if (batchDepth === 0) {
      for (const [callback2, state] of batchedCallbacks.entries()) callback2(state);
      batchedCallbacks.clear();
    }
  }
  function observe(state, parentModel) {
    const callbackMap = /* @__PURE__ */ new Map();
    const computedKeys = /* @__PURE__ */ new Map();
    const watchAllCallbacks = /* @__PURE__ */ new Set();
    let pendingCallback = void 0;
    let lastKey = 0;
    function watch(callback) {
      pendingCallback = callback;
      const result = callback(proxy, true);
      pendingCallback = void 0;
      return result;
    }
    function watchKeys(keys, fn) {
      for (const key of keys.split(" ")) {
        if (!callbackMap.has(key)) callbackMap.set(key, /* @__PURE__ */ new Set());
        callbackMap.get(key).add(fn);
      }
      return fn(proxy, true);
    }
    function unwatch(callback) {
      for (const callbacks of callbackMap.values()) {
        if (callbacks.has(callback)) callbacks.delete(callback);
      }
      watchAllCallbacks.delete(callback);
    }
    function watchAll(callback, dontRun) {
      watchAllCallbacks.add(callback);
      return dontRun ? void 0 : callback(proxy, true);
    }
    function setComputed(key, expr) {
      if (computedKeys.has(key)) unwatch(computedKeys.get(key));
      const callback = () => {
        state[key] = expr(proxy);
        if (pendingCallback === callback) pendingCallback = void 0;
        triggerCallbacks(key);
      };
      computedKeys.set(key, callback);
      watch(callback);
    }
    function triggerCallbacks(key) {
      if (batchDepth > 0) {
        for (const callback of callbackMap.get(key) || []) enqueueCallback(callback, state);
        for (const callback of watchAllCallbacks) enqueueCallback(callback, state);
      } else {
        for (const callback of callbackMap.get(key) || []) callback(state);
        for (const callback of watchAllCallbacks) callback(state);
      }
    }
    function forceUpdate() {
      for (const callbacks of callbackMap.values()) {
        for (const callback of callbacks) callback(state);
      }
      for (const callback of watchAllCallbacks) callback(state);
    }
    function assign(changes, clear2) {
      if (clear2) state = {};
      batch(() => {
        for (const [key, value] of Object.entries(changes)) {
          if (!(key in previous)) previous[key] = state[key];
          proxy[key] = value;
        }
      });
    }
    function getKey() {
      lastKey += 1;
      while (`_x${lastKey}` in state) lastKey += 1;
      return `_x${lastKey}`;
    }
    function clear() {
      state = {};
      callbackMap.clear();
      computedKeys.clear();
      lastKey = 0;
    }
    function copy() {
      return Object.assign({}, state);
    }
    let previous = {};
    function getChanges() {
      const changes = [{}, {}];
      for (const k of Object.keys(previous)) {
        if (previous[k] === state[k]) continue;
        changes[0][k] = previous[k];
        changes[1][k] = state[k];
      }
      previous = {};
      return changes;
    }
    function inherit(key) {
      if (!parentModel) return;
      parentModel.watch(() => proxy[key] = parentModel[key]);
    }
    const proxy = new Proxy(state, {
      get(_, key) {
        if (key === "watch") return watch;
        if (key === "watchKeys") return watchKeys;
        if (key === "unwatch") return unwatch;
        if (key === "watchAll") return watchAll;
        if (key === "setComputed") return setComputed;
        if (key === "forceUpdate") return forceUpdate;
        if (key === "getChanges") return getChanges;
        if (key === "assign") return assign;
        if (key === "getKey") return getKey;
        if (key === "clear") return clear;
        if (key === "copy") return copy;
        if (key === "_internal") return [state, callbackMap];
        if (pendingCallback) {
          if (!callbackMap.has(key)) callbackMap.set(key, /* @__PURE__ */ new Set());
          callbackMap.get(key).add(pendingCallback);
        }
        if (!(key in state)) inherit(key);
        return state[key];
      },
      set(_, key, value) {
        if (state[key] === value) return true;
        if (!(key in previous)) previous[key] = state[key];
        state[key] = value;
        if (computedKeys.has(key)) {
          unwatch(computedKeys.get(key));
          computedKeys.delete(key);
        }
        triggerCallbacks(key);
        return true;
      },
      deleteProperty(_, p) {
        delete state[p];
        callbackMap.delete(p);
        computedKeys.delete(p);
        return true;
      }
    });
    return proxy;
  }
  var pathLength = { A: 7, C: 6, H: 1, L: 2, M: 2, Q: 4, S: 4, T: 2, V: 1, Z: 0 };
  var pathSegment = /[astvzqmhlc]([^astvzqmhlc]*)/ig;
  var pathPoint = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
  function pathCommands(path) {
    const commands = [];
    let lastPoint = void 0;
    for (const match of path.match(pathSegment) || []) {
      const uType = match[0].toUpperCase();
      if (uType === "Z") {
        commands.push({ type: "Z", points: [] });
        continue;
      }
      const args = (match.slice(1).match(pathPoint) || []).map((p) => +p);
      const isAbsolute = uType === match[0];
      for (const [i, p] of chunk(args, pathLength[uType]).entries()) {
        let points = [];
        let type = uType === "M" && i > 0 ? "L" : uType;
        let options = void 0;
        if (uType === "H") {
          type = "L";
          points = [new Point(p[0], isAbsolute ? (lastPoint == null ? void 0 : lastPoint.y) || 0 : 0)];
        } else if (uType === "V") {
          type = "L";
          points = [new Point(isAbsolute ? (lastPoint == null ? void 0 : lastPoint.x) || 0 : 0, p[0])];
        } else if (uType === "A") {
          type = "A";
          points = [new Point(p[5], p[6])];
          options = p.slice(0, 5);
        } else if ("MLCSQT".includes(uType)) {
          points = chunk(p, 2).map((q) => new Point(q[0], q[1]));
        }
        if (!isAbsolute && lastPoint) points = points.map((p2) => p2.translate(lastPoint));
        lastPoint = last(points);
        commands.push({ type, points, options });
      }
    }
    return commands;
  }
  function parsePath(d2) {
    if (!d2) return [];
    const commands = pathCommands(d2);
    return commands.map((c2) => last(c2.points)).filter((p) => !!p);
  }
  var COMMON_STYLES = [
    "font-family",
    "font-size",
    "font-style",
    "font-weight",
    "letter-spacing",
    "text-decoration",
    "color",
    "display",
    "visibility",
    "alignment-baseline",
    "baseline-shift",
    "opacity",
    "text-anchor",
    "clip",
    "clip-path",
    "clip-rule",
    "mask",
    "filter",
    "transform",
    "transform-origin",
    "white-space",
    "line-height"
  ];
  var SVG_STYLES = [
    "fill",
    "fill-rule",
    "marker",
    "marker-start",
    "marker-mid",
    "marker-end",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-width",
    "text-rendering",
    "dominant-baseline",
    "transform-box",
    "paint-order"
  ];
  var HTML_STYLES = [
    "padding",
    "min-width",
    "max-width",
    "height",
    "border-width",
    "border-style",
    "border-color",
    "box-sizing",
    "background",
    "width",
    "grid-template-columns",
    "text-align"
  ];
  var REMOVE_ATTRIBUTES = ["class", "tabindex", "contenteditable"];
  var DONT_INHERIT = /* @__PURE__ */ new Set(["opacity", "transform-box", "transform-origin", "border-width", "border-style", "border-color"]);
  var STYLE_DEFAULTS = {
    "font-style": "normal",
    "font-weight": "400",
    "letter-spacing": "normal",
    "text-decoration": "none",
    "display": "block",
    "visibility": "visible",
    "alignment-baseline": "auto",
    "baseline-shift": "0px",
    "text-anchor": "start",
    "clip": "auto",
    "clip-path": "none",
    "clip-rule": "nonzero",
    "mask": "none",
    "opacity": "1",
    "filter": "none",
    "fill": "rgb(0, 0, 0)",
    "fill-rule": "nonzero",
    "marker": "none",
    "stroke": "none",
    "stroke-dasharray": "none",
    "stroke-dashoffset": "0px",
    "stroke-linecap": "butt",
    "stroke-linejoin": "miter",
    "stroke-width": "1px",
    "text-rendering": "auto",
    "transform": "none",
    "dominant-baseline": "auto",
    "transform-origin": "0px 0px",
    "transform-box": "view-box",
    "paint-order": "normal"
  };
  function cleanSVG(node) {
    var _a2, _b;
    if (node.getAttribute("hidden") || node.style.opacity === "0" || node.style.display === "none") {
      (_a2 = node.parentNode) == null ? void 0 : _a2.removeChild(node);
    } else {
      for (const child of Array.from(node.children)) cleanSVG(child);
      if (node.tagName === "g" && node.childElementCount === 0) {
        (_b = node.parentNode) == null ? void 0 : _b.removeChild(node);
      } else {
        for (const a2 of REMOVE_ATTRIBUTES) {
          if (node.hasAttribute(a2)) node.removeAttribute(a2);
        }
      }
    }
  }
  function inheritedStyle(node, prop) {
    let n = node.parentElement;
    while (n) {
      const value = n.style.getPropertyValue(prop);
      if (value) return value;
      n = n.parentElement;
    }
  }
  function copySVGStyles(source, copy, isHTML = false) {
    const style2 = window.getComputedStyle(source);
    copy.removeAttribute("style");
    const html = isHTML || source.tagName === "foreignObject";
    const properties = [...COMMON_STYLES, ...html ? HTML_STYLES : SVG_STYLES];
    for (const p of properties) {
      const value = style2.getPropertyValue(p);
      const inherited = inheritedStyle(copy, p);
      if (value === STYLE_DEFAULTS[p] && !inherited) continue;
      if (!DONT_INHERIT.has(p) && value === inherited) continue;
      copy.style.setProperty(p, value);
    }
    const sourceChildren = source.children;
    const copyChildren = copy.children;
    for (let i = 0; i < copyChildren.length; ++i) {
      copySVGStyles(sourceChildren[i], copyChildren[i], html);
    }
  }
  var BaseView = class {
    constructor(_el) {
      this._el = _el;
      this._data = {};
      this._events = {};
      this.type = "default";
      _el._view = this;
    }
    get id() {
      return this._el.id;
    }
    get data() {
      return this._el.dataset;
    }
    get tagName() {
      return this._el.tagName.toUpperCase();
    }
    equals(el) {
      return this._el === el._el;
    }
    /** Adds one or more space-separated classes to this element. */
    addClass(className) {
      for (const c2 of words(className)) this._el.classList.add(c2);
    }
    removeClass(className) {
      for (const c2 of words(className)) this._el.classList.remove(c2);
    }
    hasClass(className) {
      return this._el.classList.contains(className);
    }
    toggleClass(className) {
      return this._el.classList.toggle(className);
    }
    /** Toggles multiple space-separated class names based on a condition. */
    setClass(className, condition) {
      if (condition) {
        this.addClass(className);
      } else {
        this.removeClass(className);
      }
    }
    attr(attr) {
      return this._el.getAttribute(attr) || "";
    }
    hasAttr(attr) {
      return this._el.hasAttribute(attr);
    }
    setAttr(attr, value) {
      if (value === void 0) {
        this.removeAttr(attr);
      } else {
        this._el.setAttribute(attr, `${value}`);
      }
    }
    removeAttr(attr) {
      this._el.removeAttribute(attr);
    }
    get attributes() {
      return Array.from(this._el.attributes || []);
    }
    get html() {
      return this._el.innerHTML || "";
    }
    set html(h) {
      this._el.innerHTML = h;
    }
    get text() {
      return this._el.textContent || "";
    }
    set text(t) {
      this._el.textContent = t;
    }
    // Required because TS doesn't allow getters and setters with different types.
    set textStr(t) {
      this._el.textContent = `${t}`;
    }
    /** Blurs this DOM element. */
    blur() {
      this._el.blur();
    }
    /** Focuses this DOM element. */
    focus() {
      this._el.focus();
    }
    // ---------------------------------------------------------------------------
    // Templates and Model Binding
    getParentModel() {
      const parent = this.parent;
      return parent ? parent.model || parent.getParentModel() : void 0;
    }
    bindModel(model, recursive = true) {
      var _a2;
      if (this.model) return;
      this.model = model;
      if (this.hasAttr(":for")) return this.makeDynamicList(model);
      for (const { name, value } of this.attributes) {
        this.makeDynamicAttribute(name, value, model);
      }
      for (const $c of this.childNodes) {
        if ($c instanceof Text) {
          if ((_a2 = $c.textContent) == null ? void 0 : _a2.includes("${")) {
            const expr = compileString($c.textContent);
            model.watch(() => $c.textContent = expr(model) || "");
          }
        } else if (recursive) {
          $c.bindModel(model);
        }
      }
    }
    bindVariable(_model, _name) {
    }
    /** Conditionally hide this element from the DOM (using placeholder comments). */
    toggleDOM(show = true) {
      if (show === !!this._el.parentNode) return;
      if (!this.$placeholder) {
        this.$placeholder = $(document.createComment(""));
        this.insertBefore(this.$placeholder);
      }
      if (show) {
        this.$placeholder.insertBefore(this);
      } else {
        this.detach();
      }
    }
    makeDynamicAttribute(name, value, model) {
      if (name.startsWith("@")) {
        const event = name.slice(1);
        const expr = compile(value);
        this.on(event, (e2) => expr(model, { $event: e2 }));
      } else if (name === ":show") {
        const expr = compile(value);
        model.watch(() => this.toggle(!!expr(model)));
      } else if (name === ":if") {
        const expr = compile(value);
        model.watch(() => this.toggleDOM(!!expr(model)));
      } else if (name === ":html") {
        const expr = compile(value);
        model.watch(() => this.html = expr(model) || "");
      } else if (name === ":draw") {
        const expr = compile(value);
        model.watch(() => this.draw(expr(model)));
      } else if (name === ":class") {
        const expr = compile(value);
        const initialClass = `${this.attr("class")} `;
        model.watch(() => this.setAttr("class", initialClass + expr(model)));
      } else if (name === ":bind") {
        this.bindVariable(model, value);
      } else if (name.startsWith(":")) {
        const expr = compile(value);
        const attr = name.slice(1);
        model.watch(() => this.setAttr(attr, expr(model)));
      } else if (value.includes("${")) {
        const expr = compileString(value, true);
        model.watch(() => this.setAttr(name, expr(model) || ""));
      }
      if (name.startsWith("@") || name.startsWith(":")) this.removeAttr(name);
    }
    makeDynamicList(model) {
      const [name, value] = this.attr(":for").split(" in ");
      this.removeAttr(":for");
      const expr = compile(value);
      const $placeholder = $(document.createComment(""));
      this.insertBefore($placeholder);
      this.detach();
      const $cached = [];
      let visible = 0;
      model.watch(() => {
        let array = expr(model);
        if (!Array.isArray(array)) array = [];
        for (let i = array.length; i < visible; ++i) $cached[i].detach();
        for (let i = visible; i < $cached.length; ++i) $placeholder.insertBefore($cached[i]);
        for (let i = $cached.length; i < array.length; ++i) {
          const $el = this.copy(true);
          $el.bindModel(observe({ [name]: void 0 }, model));
          $placeholder.insertBefore($el);
          $cached.push($el);
        }
        visible = array.length;
        for (let i = 0; i < visible; ++i) $cached[i].model[name] = array[i];
      });
    }
    // -------------------------------------------------------------------------
    // Scrolling and Dimensions
    get bounds() {
      return this._el.getBoundingClientRect();
    }
    get boundsRect() {
      const bounds = this.bounds;
      return new Rectangle(new Point(bounds.x, bounds.y), bounds.width, bounds.height);
    }
    contains(point) {
      return this.boundsRect.contains(point);
    }
    /** Checks if this element is currently visible in the viewport. */
    get isInViewport() {
      if (this.height === 0) return false;
      const bounds = this.bounds;
      return isBetween(bounds.top, -bounds.height, Browser.height);
    }
    get topLeftPosition() {
      const bounds = this.bounds;
      return new Point(bounds.left, bounds.top);
    }
    get boxCenter() {
      const box = this.bounds;
      return new Point(box.left + box.width / 2, box.top + box.height / 2);
    }
    get scrollWidth() {
      return this._el.scrollWidth;
    }
    get scrollHeight() {
      return this._el.scrollHeight;
    }
    get scrollTop() {
      return this._el.scrollTop;
    }
    set scrollTop(y) {
      this._el.scrollTop = y;
      this.trigger("scroll", { top: y, left: this.scrollLeft });
    }
    get scrollLeft() {
      return this._el.scrollLeft;
    }
    set scrollLeft(x) {
      this._el.scrollLeft = x;
      this.trigger("scroll", { top: this.scrollTop, left: x });
    }
    /** Scrolls the element to a specific position. */
    scrollTo(pos, time = 1e3, easing = "cubic") {
      if (pos < 0) pos = 0;
      const startPosition = this.scrollTop;
      const distance = pos - startPosition;
      if (this._data.scrollAnimation) this._data.scrollAnimation.cancel();
      this._data.scrollAnimation = animate((t) => {
        const y = startPosition + distance * ease(easing, t);
        this.scrollTop = y;
        this.trigger("scroll", { top: y });
      }, time);
    }
    /** Scrolls the element by a given distance. */
    scrollBy(distance, time = 1e3, easing = "cubic") {
      if (!distance) return;
      this.scrollTo(this.scrollTop + distance, time, easing);
    }
    // -------------------------------------------------------------------------
    // Styles
    /**
     * Retrieves or sets CSS properties on this element. Examples:
     *   * $el.css('color');  // returns 'red'
     *   * $el.css('color', 'blue');
     *   * $el.css({color: 'blue'});
     */
    css(props, value) {
      if (value === void 0) {
        if (typeof props === "string") {
          return window.getComputedStyle(this._el).getPropertyValue(props);
        } else {
          const keys = Object.keys(props);
          for (const p of keys) this._el.style.setProperty(p, `${props[p]}`);
        }
      } else if (typeof props === "string") {
        this._el.style.setProperty(props, `${value}`);
      }
    }
    /** Shortcut for getting the CSS transform style of an element. */
    get transform() {
      return this.css("transform").replace("none", "");
    }
    get transformMatrix() {
      const transform = this.transform;
      if (!transform) return [[1, 0, 0], [0, 1, 0]];
      const coords = transform.match(/matrix\(([0-9,.\s-]*)\)/);
      if (!coords || !coords[1]) return [[1, 0, 0], [0, 1, 0]];
      const matrix = coords[1].split(",");
      return [
        [+matrix[0], +matrix[2], +matrix[4]],
        [+matrix[1], +matrix[3], +matrix[5]]
      ];
    }
    /** Finds the x and y scale of this element. */
    get scale() {
      const matrix = this.transformMatrix;
      return [matrix[0][0], matrix[1][1]];
    }
    /** Sets the CSS transform on this element. */
    setTransform(posn, angle = 0, scale = 1) {
      let t = "";
      if (posn) t += `translate(${roundTo(posn.x, 0.1)}px,${roundTo(posn.y, 0.1)}px)`;
      if (angle) t += ` rotate(${angle}rad)`;
      if (scale) t += ` scale(${scale})`;
      this._el.style.transform = t;
    }
    /** Sets the CSS transform of this element to an x/y translation. */
    translate(x, y) {
      this.setTransform(new Point(x, y));
    }
    /**
     * Makes the element visible. Use the `data-display` attribute to determine
     * how this is done. Possible options are `visibility`, to use CSS visibility,
     * or CSS display values. The default is `display: block`.
     */
    show() {
      if (this.hasAttr("hidden")) this.removeAttr("hidden");
      if (this.data["display"] === "visibility") {
        this._el.style.visibility = "visible";
      } else {
        this._el.style.display = this.data.display || "block";
      }
    }
    /**
     * Makes the element invisible, using CSS visibility (if
     * `data-display="visibility"`), or `display: none`.
     */
    hide() {
      if (this.data["display"] === "visibility") {
        this._el.style.visibility = "hidden";
      } else {
        this._el.style.display = "none";
      }
    }
    /** Hides or shows the element based on a boolean value. */
    toggle(show) {
      if (show) {
        this.show();
      } else {
        this.hide();
      }
    }
    // -------------------------------------------------------------------------
    // DOM Manipulation
    /** Checks if an element matches a given CSS selector. */
    is(selector) {
      if (this._el.matches) return this._el.matches(selector);
      return Array.from(document.querySelectorAll(selector)).includes(this._el);
    }
    /** Finds the index of an elements, in the list of its siblings. */
    index() {
      let i = 0;
      let child = this._el;
      while ((child = child.previousSibling || void 0) !== void 0) ++i;
      return i;
    }
    /** Adds a new child element at the beginning of this one. */
    prepend(newChild) {
      const children = this._el.childNodes;
      if (children.length) {
        this._el.insertBefore(newChild._el, children[0]);
      } else {
        this._el.appendChild(newChild._el);
      }
    }
    /** Adds a new child element at the end of this one. */
    append(newChild) {
      this._el.appendChild(newChild instanceof Text ? newChild : newChild._el);
    }
    /** Adds a new element immediately before this one, as a sibling. */
    insertBefore(newChild) {
      this.parent._el.insertBefore(newChild._el, this._el);
    }
    /** Adds a new element immediately after this one, as a sibling. */
    insertAfter(newChild) {
      const next = this._el.nextSibling;
      if (next) {
        this.parent._el.insertBefore(newChild._el, next);
      } else {
        this.parent._el.appendChild(newChild._el);
      }
    }
    /** Returns this element's next sibling, or undefined. */
    get next() {
      return $(this._el.nextSibling);
    }
    /** Returns this element's previous sibling, or undefined. */
    get prev() {
      return $(this._el.previousSibling);
    }
    /** The first child element matching a given selector. */
    $(selector) {
      return $(selector, this);
    }
    /** All child elements matching a given selector. */
    $$(selector) {
      return $$(selector, this);
    }
    /** Returns this element's parent, or undefined. */
    get parent() {
      return $(this._el.parentElement || void 0);
    }
    /** Finds all parent elements that match a specific selector. */
    parents(selector) {
      const result = [];
      let parent = this.parent;
      while (parent) {
        if (!selector || parent.is(selector)) result.push(parent);
        parent = parent.parent;
      }
      return result;
    }
    /** Checks if this element has one of the given elements as parent. */
    hasParent(...$p) {
      const tests = $p.map((p) => p._el);
      let parent = this._el.parentNode;
      while (parent) {
        if (isOneOf(parent, ...tests)) return true;
        parent = parent.parentNode;
      }
      return false;
    }
    /** Returns an array of all children of this element. */
    get children() {
      return Array.from(this._el.children || [], (n) => $(n));
    }
    /** Returns an array of all child nodes, including text nodes. */
    get childNodes() {
      return Array.from(this._el.childNodes, (node) => {
        if (node instanceof Comment) return void 0;
        if (node instanceof Text) return node;
        return $(node);
      }).filter((x) => x);
    }
    /** Detach and re-insert to restart CSS animations. */
    restartAnimation() {
      const n = this.next;
      const p = this.parent;
      this.detach();
      if (n) {
        n.insertBefore(this);
      } else {
        p.append(this);
      }
    }
    /** Detaches an element from the DOM. */
    detach() {
      if (this._el && this._el.parentNode) {
        this._el.parentNode.removeChild(this._el);
      }
    }
    /** Removes this element. */
    remove() {
      this.detach();
    }
    /** Removes all children of this element. */
    removeChildren() {
      while (this._el.firstChild) this._el.removeChild(this._el.firstChild);
    }
    /** Creates a copy of this element, and optionally its children. */
    copy(recursive = true) {
      return $(this._el.cloneNode(recursive));
    }
    // -------------------------------------------------------------------------
    // Events
    /** Binds one ore more space-separated event listeners on this element. */
    on(events, callback, options) {
      for (const e2 of words(events)) {
        if (e2 in this._events) {
          if (!this._events[e2].includes(callback)) this._events[e2].push(callback);
        } else {
          this._events[e2] = [callback];
        }
        bindEvent(this, e2, callback, options);
      }
    }
    /** Binds a one-time event listener on this element. */
    one(events, callback, options) {
      const callbackWrap = (e2) => {
        this.off(events, callbackWrap);
        callback(e2);
      };
      this.on(events, callbackWrap, options);
    }
    /**
     * Removes an event listener on this element. If callback is undefined, it
     * removes all event listeners for this event.
     */
    off(events, callback) {
      for (const e2 of words(events)) {
        if (e2 in this._events) {
          this._events[e2] = callback ? this._events[e2].filter((fn) => fn !== callback) : [];
        }
        unbindEvent(this, e2, callback);
      }
    }
    /** Triggers a specific event on this element. */
    trigger(events, args = {}) {
      for (const e2 of words(events)) {
        if (!this._events[e2]) return;
        for (const fn of this._events[e2]) fn.call(this, args);
      }
    }
    /**
     * Binds an event listener for a specific key that is pressed while this
     * element is in focus.
     */
    onKey(keys, callback, options) {
      keys = keys.replace("AllArrows", "ArrowUp ArrowDown ArrowLeft ArrowRight");
      const keyNames = new Set(words(keys));
      const event = (options == null ? void 0 : options.up) ? "keyup" : "keydown";
      const target = this._el === document.body ? document : this._el;
      target.addEventListener(event, (e2) => {
        var _a2, _b;
        const key = keyCode(e2);
        if ((options == null ? void 0 : options.meta) ? !e2.ctrlKey && !e2.metaKey : e2.ctrlKey || e2.metaKey) return;
        if (!key || !keyNames.has(key)) return;
        if (document.activeElement !== this._el && ((_b = (_a2 = document.activeElement) == null ? void 0 : _a2.shadowRoot) == null ? void 0 : _b.activeElement) !== this._el && Browser.formIsActive) return;
        callback(e2, key);
      });
    }
    onAttr(name, callback) {
      const observer2 = new MutationObserver((mutations) => {
        for (const m of mutations) {
          if (m.type === "attributes" && m.attributeName === name) {
            callback(this.attr(name));
          }
        }
      });
      observer2.observe(this._el, { attributes: true });
      callback(this.attr(name), true);
    }
    /** Returns a promise that is resolved when an event is triggered. */
    onPromise(event, resolveImmediately = false) {
      if (resolveImmediately) return Promise.resolve();
      return new Promise((resolve) => this.one(event, () => resolve()));
    }
    // -------------------------------------------------------------------------
    // Animations
    /**
     * Animates multiple CSS properties of this element, with a given duration,
     * delay and ease function.
     */
    animate(rules, duration = 400, delay3 = 0, easing = "ease-in-out") {
      return transition(this, rules, duration, delay3, easing);
    }
    /**
     * Runs an enter animation on this element. Valid effect names are
     *   * 'fade', 'pop' and 'descend'
     *   * 'draw' and 'draw-reverse'
     *   * 'slide' and 'slide-down'
     *   * 'reveal', 'reveal-left' and 'reveal-right'
     */
    enter(effect = "fade", duration = 500, delay3 = 0) {
      return enter(this, effect, duration, delay3);
    }
    /**
     * Runs an exit animation on this element. See `.enter()` for options.
     */
    exit(effect = "fade", duration = 500, delay3 = 0, remove = false) {
      return exit(this, effect, duration, delay3, remove);
    }
    /**
     * Triggers a CSS animation in an element by adding a class and removing it
     * after the `animationEnd` event.
     */
    effect(className) {
      this.one("animationend", () => this.removeClass(`effects-${className}`));
      this.addClass(`effects-${className}`);
    }
  };
  var HTMLBaseView = class extends BaseView {
    get offsetTop() {
      return this._el.offsetTop;
    }
    get offsetLeft() {
      return this._el.offsetLeft;
    }
    get offsetParent() {
      return $(this._el.offsetParent || void 0);
    }
    /** Returns this element's width, including border and padding. */
    get width() {
      return this._el.offsetWidth;
    }
    /** Returns this element's height, including border and padding. */
    get height() {
      return this._el.offsetHeight;
    }
    /** Returns this element's width, excluding border and padding. */
    get innerWidth() {
      const left = parseFloat(this.css("padding-left"));
      const right = parseFloat(this.css("padding-right"));
      return this._el.clientWidth - left - right;
    }
    /** Returns this element's height, excluding border and padding. */
    get innerHeight() {
      const bottom = parseFloat(this.css("padding-bottom"));
      const top = parseFloat(this.css("padding-top"));
      return this._el.clientHeight - bottom - top;
    }
    /** Returns this element's width, including margins. */
    get outerWidth() {
      const left = parseFloat(this.css("margin-left"));
      const right = parseFloat(this.css("margin-right"));
      return this.width + left + right || 0;
    }
    /** Returns this element's height, including margins. */
    get outerHeight() {
      const bottom = parseFloat(this.css("margin-bottom"));
      const top = parseFloat(this.css("margin-top"));
      return this.height + bottom + top || 0;
    }
    /** @returns {number} */
    get positionTop() {
      let el = this._el;
      let offset = 0;
      while (el) {
        offset += el.offsetTop;
        el = el.offsetParent;
      }
      return offset;
    }
    /** @returns {number} */
    get positionLeft() {
      let el = this._el;
      let offset = 0;
      while (el) {
        offset += el.offsetLeft;
        el = el.offsetParent;
      }
      return offset;
    }
    /** Calculates the element offset relative to any other parent element. */
    offset(parent) {
      if (parent._el === this._el.offsetParent) {
        const top = this.offsetTop + parent._el.clientTop;
        const left = this.offsetLeft + parent._el.clientLeft;
        const bottom = top + this.height;
        const right = left + this.width;
        return { top, left, bottom, right };
      } else {
        const parentBox = parent._el.getBoundingClientRect();
        const box = this._el.getBoundingClientRect();
        return {
          top: box.top - parentBox.top,
          left: box.left - parentBox.left,
          bottom: box.bottom - parentBox.top,
          right: box.right - parentBox.left
        };
      }
    }
  };
  var SVGBaseView = class extends BaseView {
    constructor() {
      super(...arguments);
      this.type = "svg";
    }
    /** Returns the owner `<svg>` which this element is a child of. */
    get $ownerSVG() {
      return $(this._el.ownerSVGElement || void 0);
    }
    // See https://www.chromestatus.com/features/5724912467574784
    get width() {
      return this.bounds.width;
    }
    get height() {
      return this.bounds.height;
    }
    // SVG Elements don't have offset properties. We instead use the position of
    // the first non-SVG parent, plus the margin of the SVG owner, plus the SVG
    // position of the individual element. This doesn't work for absolutely
    // positioned SVG elements, and some other edge cases.
    get positionLeft() {
      const svgLeft = this._el.getBBox().x + this._el.getCTM().e;
      return this.$ownerSVG.positionLeft + svgLeft;
    }
    get positionTop() {
      const svgTop = this._el.getBBox().y + this._el.getCTM().f;
      return this.$ownerSVG.positionTop + svgTop;
    }
    get inverseTransformMatrix() {
      const m = this._el.getScreenCTM().inverse();
      const matrix = [[m.a, m.c, m.e], [m.b, m.d, m.f]];
      if (Browser.isFirefox) {
        const transform = this.transformMatrix;
        matrix[0][2] -= transform[0][2];
        matrix[1][2] -= transform[1][2];
      }
      return matrix;
    }
    setTransform(posn, angle = 0, scale = 1) {
      const t1 = posn ? `translate(${roundTo(posn.x, 0.1)} ${roundTo(posn.y, 0.1)})` : "";
      const t2 = nearlyEquals(angle, 0) ? "" : `rotate(${angle * 180 / Math.PI})`;
      const t3 = nearlyEquals(scale, 1) ? "" : `scale(${scale})`;
      this.setAttr("transform", [t1, t2, t3].join(" "));
    }
    /**
     * Finds the total stroke length of this element. Similar to the SVG
     * `getTotalLength()` function, but works for a wider variety of elements.
     */
    get strokeLength() {
      if (this._el instanceof SVGGeometryElement) {
        return this._el.getTotalLength();
      } else {
        const dim = this.bounds;
        return 2 * dim.height + 2 * dim.width;
      }
    }
    /**
     * Gets the coordinates of the point at a distance `d` along the length of the
     * stroke of this `<path>` element.
     */
    getPointAtLength(d2) {
      if (this._el instanceof SVGGeometryElement) {
        const point = this._el.getPointAtLength(d2);
        return new Point(point.x, point.y);
      } else {
        return new Point(0, 0);
      }
    }
    /**
     * Gets the coordinates of the point at a position `p` along the length of the
     * stroke of this `<path>` element, where `0  p  1`.
     */
    getPointAt(p) {
      return this.getPointAtLength(p * this.strokeLength);
    }
    /** Returns a list of all points along an SVG `<path>` element. */
    get points() {
      return parsePath(this.attr("d"));
    }
    /** Sets the list of points for an SVG `<path>` element.c*/
    set points(p) {
      const d2 = p.length ? `M${p.map((x) => `${x.x},${x.y}`).join("L")}` : "";
      this.setAttr("d", d2);
    }
    /** Appends a new point to an SVG `<path>` element. */
    addPoint(p) {
      const d2 = `${this.attr("d")} L ${p.x},${p.y}`;
      this.setAttr("d", d2);
    }
    /** Finds the center of an SVG `<circle>` element. */
    get center() {
      const x = +this.attr(this.tagName === "TEXT" ? "x" : "cx") || 0;
      const y = +this.attr(this.tagName === "TEXT" ? "y" : "cy") || 0;
      return new Point(x, y);
    }
    /** Sets the center of an SVG `<circle>` or `<text>` element. */
    setCenter(c2) {
      this.setAttr(this.tagName === "TEXT" ? "x" : "cx", c2.x);
      this.setAttr(this.tagName === "TEXT" ? "y" : "cy", c2.y);
    }
    /** Sets the end points of an SVG `<line>` element. */
    setLine(p, q) {
      this.setAttr("x1", p.x);
      this.setAttr("y1", p.y);
      this.setAttr("x2", q.x);
      this.setAttr("y2", q.y);
    }
    /** Sets the bounds of an SVG `<rectangle>` element. */
    setRect(rect) {
      this.setAttr("x", rect.p.x);
      this.setAttr("y", rect.p.y);
      this.setAttr("width", rect.w);
      this.setAttr("height", rect.h);
    }
    /** Draws a generic geometry object onto an SVG `<path>` element. */
    draw(obj, options = {}) {
      if (!obj) return this.setAttr("d", "");
      const attributes = {};
      for (const p of ["mark", "arrows", "round"]) {
        if (this.hasAttr(p)) attributes[p] = this.attr(p);
      }
      if (this.hasClass("fill")) attributes.fill = "fill";
      if (this.hasAttr("size")) attributes.size = +this.attr("size") || void 0;
      this.setAttr("d", drawSVG(obj, Object.assign(options, attributes)));
    }
  };
  var SVGParentView2 = class extends SVGBaseView {
    /** Returns the viewport coordinates of this `<svg>` element. */
    get viewBox() {
      return this._el.viewBox.baseVal || { width: 0, height: 0 };
    }
    get $ownerSVG() {
      return this;
    }
    get positionLeft() {
      return parseInt(this.css("margin-left")) + this.parent.positionLeft;
    }
    get positionTop() {
      return parseInt(this.css("margin-top")) + this.parent.positionTop;
    }
    /** Returns the intrinsic width of this `<svg>` element. */
    get svgWidth() {
      return this.viewBox.width || this.width;
    }
    /** Returns the intrinsic height of this `<svg>` element. */
    get svgHeight() {
      return this.viewBox.height || this.height;
    }
    /** Create a new `<path>` element child and draw a geometry object onto it. */
    drawPath(obj, attributes = {}, options = {}) {
      const $el = $N("path", attributes, this);
      $el.draw(obj, options);
      return $el;
    }
    /** Converts an SVG element into a PNG, JPG or SVG data URI. */
    image(type, width, height, viewBox) {
      return __async2(this, null, function* () {
        const $copy = this.copy(true);
        copySVGStyles(this._el, $copy._el);
        if (type === "svg") cleanSVG($copy._el);
        if (!height) height = width || this.svgHeight;
        if (!width) width = this.svgWidth;
        $copy.setAttr("width", width);
        $copy.setAttr("height", height);
        $copy.setAttr("viewBox", viewBox || this.attr("viewBox") || `0 0 ${this.svgWidth} ${this.svgHeight}`);
        $copy.setAttr("xmlns", "http://www.w3.org/2000/svg");
        const $images = $copy.$$("image");
        if (type === "svg") {
          for (const $i of $images) $i.setAttr("href", new URL($i.attr("href"), location.href));
        } else {
          yield Promise.all($images.map(($i) => __async2(this, null, function* () {
            $i.setAttr("href", yield loadImageDataURI($i.attr("href")));
          })));
        }
        const serialised = new XMLSerializer().serializeToString($copy._el);
        const url2 = `data:image/svg+xml;utf8,${encodeURIComponent(serialised)}`;
        if (type === "svg") return url2;
        const $canvas = $N("canvas", { width, height });
        if (type === "jpg") {
          $canvas.ctx.fillStyle = "white";
          $canvas.ctx.fillRect(0, 0, width, height);
        }
        const image = yield loadImage(url2);
        $canvas.ctx.drawImage(image, 0, 0, width, height);
        return $canvas.image(type);
      });
    }
    downloadImage(fileName, width, height, viewBox) {
      const windowRef = Browser.isIOS ? window.open("", "_blank") : void 0;
      const isDarkTheme = Browser.theme.isDark;
      if (isDarkTheme) Browser.setTheme("light");
      const type = fileName.endsWith(".jpg") ? "jpg" : fileName.endsWith(".svg") ? "svg" : "png";
      const dataUri = this.image(type, width, height, viewBox);
      if (isDarkTheme) Browser.setTheme("dark");
      dataUri.then((href) => {
        if (windowRef) return windowRef.location.href = href;
        const $a = $N("a", { download: fileName, href, target: "_blank" });
        $a._el.dispatchEvent(new MouseEvent(
          "click",
          { view: window, bubbles: false, cancelable: true }
        ));
      });
    }
  };
  var WindowView = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "window";
    }
    get width() {
      return window.innerWidth;
    }
    get height() {
      return window.innerHeight;
    }
    get innerWidth() {
      return window.innerWidth;
    }
    get innerHeight() {
      return window.innerHeight;
    }
    get outerWidth() {
      return window.outerWidth;
    }
    get outerHeight() {
      return window.outerHeight;
    }
    get scrollWidth() {
      return document.body.scrollWidth;
    }
    get scrollHeight() {
      return document.body.scrollHeight;
    }
    get scrollTop() {
      return window.pageYOffset;
    }
    set scrollTop(y) {
      document.body.scrollTop = document.documentElement.scrollTop = y;
      this.trigger("scroll", { top: y, left: this.scrollLeft });
    }
    get scrollLeft() {
      return window.pageXOffset;
    }
    set scrollLeft(x) {
      document.body.scrollLeft = document.documentElement.scrollLeft = x;
      this.trigger("scroll", { top: this.scrollTop, left: x });
    }
  };
  var FormView = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "form";
    }
    get action() {
      return this._el.action;
    }
    /** Summarises the data for an HTML <form> element in an JSON Object. */
    get formData() {
      const data = {};
      for (const el of Array.from(this._el.elements)) {
        const id = el.name || el.id;
        if (id) data[id] = el.value;
      }
      return data;
    }
    get isValid() {
      return this._el.checkValidity();
    }
  };
  var InputView2 = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "input";
    }
    get checked() {
      return this._el.checked || false;
    }
    set checked(value) {
      this._el.checked = value;
    }
    get value() {
      return this._el.value;
    }
    set value(v) {
      this._el.value = v;
    }
    bindVariable(model, name) {
      if (this._el.type === "checkbox") {
        const invert = name.startsWith("!");
        const inv = (t) => invert ? !t : t;
        if (invert) name = name.slice(1);
        if (model[name] !== void 0) {
          this.checked = inv(model[name]);
        } else if (this.hasAttr("checked")) {
          model[name] = inv(this.checked);
        }
        this.on("change", () => model[name] = inv(this.checked));
        model.watch(() => this.checked = inv(model[name]));
        return;
      }
      if (this._el.type === "number") {
        const min = this.hasAttr("min") ? +this.attr("min") : -Infinity;
        const max = this.hasAttr("max") ? +this.attr("max") : Infinity;
        this.change((v) => {
          if (v) model[name] = clamp(+v, min, max);
        });
      } else {
        this.change((v) => model[name] = v);
      }
      if (model[name] !== void 0) {
        this.value = model[name];
      } else if (this.value) {
        model[name] = this.value;
      }
      this.on("blur", () => this.value = model[name]);
      model.watch(() => {
        if (document.activeElement !== this._el) this.value = model[name];
      });
    }
    /** Polyfill for type and inputmode attributes. */
    setInputPattern(value) {
      if (isNaN(+value)) return;
      const digitsOnly = value.match(/^[0-9]+$/);
      this.setAttr("inputmode", digitsOnly ? "numeric" : "decimal");
      if (digitsOnly) this.setAttr("pattern", "[0-9]*");
    }
    /** Binds a change event listener. */
    change(callback) {
      let value = this.value || "";
      this.on("focus", () => value = this.value);
      this.on("change keyup input paste", () => {
        if (this.value === value) return;
        value = this.value;
        callback(value);
      });
    }
    validate(callback) {
      this.change((value) => this.setValidity(callback(value)));
    }
    setValidity(str) {
      this._el.setCustomValidity(str);
    }
    get isValid() {
      return this._el.checkValidity();
    }
  };
  var CanvasView2 = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "canvas";
    }
    /** Returns the drawing context for a `<canvas>` element. */
    getContext(c2 = "2d", options = {}) {
      return this._el.getContext(c2, options);
    }
    /** Converts a Canvas element into a PNG or JPEG data URI. */
    image(type = "png") {
      return this._el.toDataURL(type === "png" ? "image/png" : "image/jpeg");
    }
    /** Returns the intrinsic pixel width of this `<canvas>` element. */
    get canvasWidth() {
      return this._el.width;
    }
    /** Returns the intrinsic pixel height of this `<canvas>` element. */
    get canvasHeight() {
      return this._el.height;
    }
    /** Cached reference to the 2D context for this `<canvas>` element. */
    get ctx() {
      if (!this._ctx) this._ctx = this.getContext();
      return this._ctx;
    }
    /** Draws a generic geometry object ont a `<canvas>` element. */
    draw(obj, options = {}) {
      this.ctx.save();
      drawCanvas(this.ctx, obj, options);
      this.ctx.restore();
    }
    /** Clears this canvas. */
    clear() {
      this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    }
    /** Clears this canvas. */
    fill(color) {
      this.ctx.save();
      this.ctx.fillStyle = color;
      this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
      this.ctx.restore();
    }
    /** Erase a specific circle of the canvas. */
    clearCircle(center, radius) {
      this.ctx.save();
      this.ctx.globalCompositeOperation = "destination-out";
      this.ctx.beginPath();
      this.ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
      this.ctx.fill();
      this.ctx.restore();
    }
    downloadImage(fileName) {
      const href = this.image(fileName.endsWith(".jpg") ? "jpg" : "png");
      const $a = $N("a", { download: fileName, href, target: "_blank" });
      $a._el.dispatchEvent(new MouseEvent(
        "click",
        { view: window, bubbles: false, cancelable: true }
      ));
    }
  };
  var MediaView = class extends HTMLBaseView {
    /** Starts playback on a media element. */
    play() {
      return this._el.play() || Promise.resolve();
    }
    /** Pauses playback on a media element. */
    pause() {
      return this._el.pause();
    }
  };
  var SVG_TAGS = [
    "path",
    "rect",
    "circle",
    "ellipse",
    "polygon",
    "polyline",
    "g",
    "defs",
    "marker",
    "line",
    "text",
    "tspan",
    "pattern",
    "mask",
    "svg",
    "foreignObject",
    "image",
    "use",
    "clipPath",
    "linearGradient",
    "radialGradient"
  ];
  function $(query, context) {
    if (!query) return void 0;
    const c2 = context ? context._el : document.documentElement;
    const el = typeof query === "string" ? c2.querySelector(query) : query;
    if (!el) return void 0;
    if (el._view) return el._view;
    const tagName = (el.tagName || "").toLowerCase();
    if (tagName === "svg") {
      return new SVGParentView2(el);
    } else if (tagName === "canvas") {
      return new CanvasView2(el);
    } else if (tagName === "form") {
      return new FormView(el);
    } else if (tagName === "input" || tagName === "select" || tagName === "textarea") {
      return new InputView2(el);
    } else if (tagName === "video" || tagName === "audio") {
      return new MediaView(el);
    } else if (SVG_TAGS.includes(tagName)) {
      return new SVGBaseView(el);
    } else {
      return new HTMLBaseView(el);
    }
  }
  function $$(selector, context) {
    const c2 = context ? context._el : document.documentElement;
    const els = selector ? c2.querySelectorAll(selector) : [];
    return Array.from(els, (el) => $(el));
  }
  function $N(tag, attributes = {}, parent) {
    const el = !SVG_TAGS.includes(tag) ? document.createElement(tag) : document.createElementNS("http://www.w3.org/2000/svg", tag);
    for (const [key, value] of Object.entries(attributes)) {
      if (value === void 0) continue;
      if (key === "id") {
        el.id = value;
      } else if (key === "html") {
        el.innerHTML = value;
      } else if (key === "text") {
        el.textContent = value;
      } else if (key === "path") {
        el.setAttribute("d", drawSVG(value));
      } else {
        el.setAttribute(key, value);
      }
    }
    const $el = $(el);
    if (parent) parent.append($el);
    return $el;
  }
  var $body = new WindowView(document.body);
  var $html = new WindowView(document.documentElement);
  function toQueryString(data) {
    const pairs = [];
    for (let key of Object.keys(data)) {
      let value = data[key];
      key = encodeURIComponent(key);
      if (value == void 0) {
        pairs.push(key);
        continue;
      }
      value = Array.isArray(value) ? value.join(",") : `${value}`;
      value = value.replace(/(\r)?\n/g, "\r\n");
      value = encodeURIComponent(value);
      value = value.replace(/%20/g, "+");
      pairs.push(`${key}=${value}`);
    }
    return pairs.join("&");
  }
  function post(url2, data) {
    return __async2(this, null, function* () {
      const isForm = data instanceof FormData;
      const options = {
        method: "POST",
        body: isForm ? data : data ? toQueryString(data) : void 0,
        headers: { "X-CSRF-Token": window.csrfToken || "" }
      };
      if (!isForm) options.headers["Content-Type"] = "application/x-www-form-urlencoded";
      const ext = url2.includes("?") ? "&xhr=1" : "?xhr=1";
      const response = yield fetch(url2 + ext, options);
      if (!response.ok) throw new Error(`Fetch error ${response.status}: ${url2}`);
      return response.text();
    });
  }
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      const el = document.createElement("script");
      el.src = src;
      el.onerror = reject;
      el.onload = resolve;
      document.head.appendChild(el);
    });
  }
  function loadImage(url2, credentials = false) {
    return new Promise((resolve) => {
      const img = new Image();
      if (!credentials) img.crossOrigin = "Anonymous";
      img.onload = () => resolve(img);
      img.src = url2;
    });
  }
  var loadImageDataURI = cache((url2) => __async2(void 0, null, function* () {
    const img = yield loadImage(url2);
    const $canvas = $N("canvas", { width: img.width, height: img.height });
    $canvas.ctx.drawImage(img, 0, 0, img.width, img.height);
    return $canvas.image("png");
  }));
  var POST_DATA = /* @__PURE__ */ new Map();
  function savePostData(url2, data) {
    if (POST_DATA.has(url2)) {
      deepExtend(POST_DATA.get(url2), data, (a2, b2) => unique(a2.concat(b2)));
    } else {
      POST_DATA.set(url2, data);
    }
  }
  function sendPostData() {
    if (!window.navigator.onLine) return;
    for (const [url2, data] of POST_DATA) {
      POST_DATA.delete(url2);
      post(url2, { data: JSON.stringify(data) }).catch((error) => {
        console.error("Failed to send POST request:", error);
        savePostData(url2, data);
      });
    }
  }
  var doDeferredPost = throttle(sendPostData, 5e3);
  window.addEventListener("online", doDeferredPost);
  window.onbeforeunload = sendPostData;
  var colours = loop(["#cd0e66", "#0f82f2", "#22ab24", "#fd8c00"]);
  var Draggable = class extends EventTarget {
    constructor($el, options = {}) {
      super();
      this.$el = $el;
      this.startPos = new Point(0, 0);
      this.position = new Point(0, 0);
      this.disabled = false;
      this.options = Object.assign({ moveX: true, moveY: true, withinBounds: true }, options);
      Browser.onResize(() => this.updateBounds());
      slide($el, {
        start: () => {
          if (this.disabled) return;
          this.startPos = this.position;
          this.trigger("start");
          $html.addClass("grabbing");
        },
        move: (posn, start) => {
          if (this.disabled) return;
          this.setPosition(this.startPos.x + posn.x - start.x, this.startPos.y + posn.y - start.y);
          this.trigger("drag", { posn: this.position, pointerPosn: posn });
          this.checkTarget(posn);
        },
        end: (last2, start) => {
          if (this.disabled) return;
          this.trigger(last2.equals(start) ? "click" : "end", { $target: this.$over });
          if (this.options.$targets && !this.$over && this.options.resetOnMiss) this.resetPosition();
          this.$over = void 0;
          $html.removeClass("grabbing");
        },
        click: () => this.trigger("click"),
        accessible: true
      });
    }
    // ---------------------------------------------------------------------------
    // Target drag-n-drop
    addTarget($target) {
      var _a2;
      if (!this.options.$targets) this.options.$targets = [];
      (_a2 = this.options.$targets) == null ? void 0 : _a2.push($target);
    }
    removeTarget($target) {
      var _a2, _b;
      this.options.$targets = (_a2 = this.options.$targets) == null ? void 0 : _a2.filter(($el) => $el !== $target);
      if (!((_b = this.options.$targets) == null ? void 0 : _b.length)) this.options.$targets = void 0;
    }
    checkTarget(posn) {
      if (!this.options.$targets) return;
      const $target = this.options.$targets.find(($t) => $t.boundsRect.contains(posn));
      if ($target === this.$over) return;
      if (this.$over) this.trigger("exit-target", { $target: this.$over });
      if ($target) this.trigger("enter-target", { $target });
      this.$over = $target;
    }
    // ---------------------------------------------------------------------------
    // Resizing and positioning
    updateBounds() {
      if (!this.options.withinBounds) return this.bounds = void 0;
      if (this.options.bounds) return this.bounds = this.options.bounds;
      const oldBounds = this.bounds;
      const $parent = this.options.$parent || this.$el.parent;
      const width = $parent.type === "svg" ? $parent.svgWidth : $parent.width;
      const height = $parent.type === "svg" ? $parent.svgHeight : $parent.height;
      this.bounds = new Bounds(0, width, 0, height);
      if (!width && !height) setTimeout(() => this.updateBounds());
      if (oldBounds) {
        this.setPosition(
          this.position.x * this.bounds.dx / oldBounds.dx || 0,
          this.position.y * this.bounds.dy / oldBounds.dy || 0
        );
      }
    }
    /** Sets the position of the element. */
    setPosition(x, y) {
      var _a2;
      let p = new Point(this.options.moveX ? x : 0, this.options.moveY ? y : 0);
      if (this.bounds) p = p.clamp(this.bounds, (_a2 = this.options.margin) != null ? _a2 : 0);
      p = p.round(this.options.snap || 1);
      if (this.options.round) p = this.options.round(p);
      if (p.equals(this.position)) return;
      this.position = p;
      if (this.options.useTransform) {
        this.$el.translate(p.x, p.y);
      } else {
        if (this.options.moveX) this.$el.css("left", `${p.x}px`);
        if (this.options.moveY) this.$el.css("top", `${p.y}px`);
      }
      this.trigger("move", { posn: p });
    }
    resetPosition(duration = 250) {
      return __async2(this, null, function* () {
        const initial = this.position;
        this.$el.css({ "pointer-events": "none" });
        yield animate((p) => {
          const currentPos = Point.interpolate(initial, this.startPos, p);
          this.setPosition(currentPos.x, currentPos.y);
        }, duration).promise;
        this.$el.css({ "pointer-events": "initial" });
      });
    }
  };
  var LOADING_STYLE = "position: fixed; top: 0; left: 0; width: 100%; height: 4px; background: #0f82f2; pointer-events: none; z-index: 9999; will-change: transform;";
  function getViewParams(url2, view) {
    const match = view.regex.exec(url2);
    if (match) {
      match.shift();
      const params = {};
      for (const [i, p] of view.params.entries()) params[p] = match[i];
      return params;
    } else {
      return void 0;
    }
  }
  function getTemplate(view, params, url2) {
    return __async2(this, null, function* () {
      if (view.template) {
        if (typeof view.template === "string") return view.template;
        return view.template(params);
      }
      const str = yield fetch(url2 + (url2.indexOf("?") >= 0 ? "&xhr=1" : "?xhr=1"));
      return str.text();
    });
  }
  var isReady2 = document.readyState === "complete";
  window.addEventListener("load", () => setTimeout(() => isReady2 = true));
  if ("scrollRestoration" in window.history) {
    window.history.scrollRestoration = "manual";
  }
  var Router = class extends EventTarget {
    constructor() {
      super(...arguments);
      this.$viewport = $body;
      this.views = [];
      this.active = { path: "", hash: "" };
      this.preloaded = false;
      this.transition = false;
      this.noLoad = false;
      this.initialise = () => void 0;
    }
    setup(options = {}) {
      if (options.$viewport) this.$viewport = options.$viewport;
      if (options.initialise) this.initialise = options.initialise;
      if (options.preloaded) this.preloaded = options.preloaded;
      if (options.transition) this.transition = options.transition;
      if (options.noLoad) this.noLoad = options.noLoad;
      if (options.click) {
        $body.on("click", (e2) => this.onLinkClick(e2));
      }
      if (options.history) {
        window.addEventListener("popstate", (e2) => __async2(this, null, function* () {
          var _a2;
          if (!isReady2 || !((_a2 = e2.state) == null ? void 0 : _a2.path)) return;
          const success = yield this.load(e2.state.path, e2.state.hash);
          if (!success) window.history.pushState(this.active, "", this.active.path + this.active.hash);
        }));
      }
    }
    view(url2, { enter: enter2, exit: exit2, template } = {}) {
      const params = (url2.match(/:\w+/g) || []).map((x) => x.substr(1));
      const regexStr = `${url2.replace(/:\w+/g, "([\\w-]+)").replace("/", "\\/")}\\/?`;
      const searchStr = url2.includes("?") ? "" : "(\\?.*)?";
      const regex = new RegExp(`^${regexStr}${searchStr}$`, "i");
      const thisView = { regex, params, enter: enter2, exit: exit2, template };
      this.views.push(thisView);
      const current = window.location.pathname + window.location.search;
      const viewParams = getViewParams(current, thisView);
      if (!viewParams) return;
      this.active = { path: current, hash: window.location.hash };
      window.history.replaceState(this.active, "", this.active.path + this.active.hash);
      Browser.ready(() => {
        setTimeout(() => {
          if (this.preloaded) {
            this.initialise(this.$viewport, viewParams);
            if (thisView.enter) thisView.enter(this.$viewport, viewParams);
          } else {
            this.loadView(thisView, viewParams);
          }
        });
      });
    }
    paths(...urls) {
      for (const url2 of urls) this.view(url2);
    }
    getView(path) {
      for (const view of this.views) {
        const params = getViewParams(path, view);
        if (params) return { view, params };
      }
    }
    // ---------------------------------------------------------------------------
    // Loading and Rendering
    load(path, hash) {
      return __async2(this, null, function* () {
        if (path === this.active.path && hash !== this.active.hash) {
          this.trigger("hashChange", hash.slice(1));
          this.trigger("change", path + hash);
          this.active = { path, hash };
          return true;
        }
        const go = this.getView(path);
        if (!go) return false;
        if (this.beforeChange && !(yield this.beforeChange())) return false;
        this.active = { path, hash };
        this.trigger("change", path + hash);
        if (window.ga) window.ga("send", "pageview", path + hash);
        if (this.noLoad) {
          if (go.view.enter) go.view.enter(this.$viewport, go.params);
        } else {
          this.loadView(go.view, go.params);
        }
        return true;
      });
    }
    loadView(_0) {
      return __async2(this, arguments, function* (view, params = {}) {
        this.showLoadingBar();
        const path = this.active.path;
        const template = yield getTemplate(view, params, path);
        if (this.active.path !== path) return;
        yield this.$viewport.animate({ opacity: 0 }, 200).promise;
        this.$viewport.removeChildren();
        $body.scrollTop = 0;
        this.$viewport.html = template;
        Browser.resize();
        replaceSvgImports();
        this.$viewport.animate({ "opacity": 1 }, 200);
        this.hideLoadingBar();
        const $title = this.$viewport.$("title");
        if ($title) document.title = $title.text;
        this.initialise(this.$viewport, params);
        if (view.enter) view.enter(this.$viewport, params);
        this.trigger("afterChange", { $viewport: this.$viewport });
      });
    }
    // ---------------------------------------------------------------------------
    // Navigation Functions
    onLinkClick(e2) {
      if (e2.metaKey || e2.ctrlKey || e2.shiftKey) return;
      if (e2.defaultPrevented) return;
      let el = e2.target;
      while (el && el.nodeName !== "A") el = el.parentNode;
      if (!el || el.nodeName !== "A") return;
      const anchor = el;
      if (anchor.target) return;
      if (anchor.origin !== window.location.origin) return;
      if (anchor.hasAttribute("download") || anchor.getAttribute("rel") === "external") return;
      const link = anchor.getAttribute("href");
      if (link && link.indexOf("mailto:") > -1) return;
      if (this.getView(anchor.pathname + anchor.search)) {
        e2.preventDefault();
        this.goTo(anchor.pathname + anchor.search, anchor.hash);
      }
    }
    goTo(path, hash = "") {
      return __async2(this, null, function* () {
        const current = this.active.path + this.active.hash;
        const success = yield this.load(path, hash);
        if (success && current !== this.active.path + this.active.hash) {
          window.history.pushState(this.active, "", path + hash);
        }
      });
    }
    replace(path, hash = "") {
      this.active = { path, hash };
      window.history.replaceState(this.active, "", path + hash);
    }
    back() {
      window.history.back();
    }
    forward() {
      window.history.forward();
    }
    showLoadingBar() {
      if (!this.$loadingBar) this.$loadingBar = $N("div", { style: LOADING_STYLE }, $body);
      this.$loadingBar.css({ transform: "translateX(-100%)", opacity: 1 });
      this.$loadingBar.show();
      this.animation = animate((p) => {
        this.$loadingBar.css("transform", `translateX(-${10 + 90 * Math.exp(-4 * p)}%)`);
      }, 3e3);
    }
    hideLoadingBar() {
      return __async2(this, null, function* () {
        var _a2, _b, _c;
        (_a2 = this.animation) == null ? void 0 : _a2.cancel();
        yield (_b = this.$loadingBar) == null ? void 0 : _b.animate({ transform: "none", opacity: 0 }).promise;
        (_c = this.$loadingBar) == null ? void 0 : _c.hide();
      });
    }
  };
  var RouterInstance = new Router();
  function applyTemplate(el, template) {
    const children = Array.from(el.childNodes);
    el.innerHTML = template;
    const slots = {};
    for (const s of Array.from(el.querySelectorAll("slot"))) {
      slots[s.getAttribute("name") || ""] = s;
    }
    for (const child of children) {
      const name = child.getAttribute ? child.getAttribute("slot") || "" : "";
      const slot = slots[name] || slots[""];
      if (slot) slot.parentNode.insertBefore(child, slot);
    }
    for (const slot of Object.values(slots)) slot.parentNode.removeChild(slot);
  }
  function* customElementChildren(el) {
    for (const c2 of Array.from(el.children)) {
      if (c2.tagName.includes("-")) {
        yield c2;
      } else {
        yield* __yieldStar(__yieldStar2(customElementChildren(c2)));
      }
    }
  }
  var customElementOptions = /* @__PURE__ */ new Map();
  var CustomHTMLElement = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.wasConnected = false;
      this.isReady = false;
    }
    connectedCallback() {
      return __async2(this, null, function* () {
        if (this.wasConnected) {
          this._view.trigger("connected");
          return;
        }
        this.wasConnected = true;
        this.isReady = false;
        this._view.created();
        const options = customElementOptions.get(this._view.tagName) || {};
        if (options.template) applyTemplate(this, options.template);
        const promises = [...customElementChildren(this)].filter((c2) => !c2.isReady).map((c2) => new Promise((res) => c2.addEventListener("ready", res)));
        setTimeout(() => {
          if (!this.isReady) console.error(`Children of custom element ${this.tagName} not ready after 1s.`);
        }, 1e3);
        yield Promise.all(promises);
        this._view.ready();
        this.dispatchEvent(new CustomEvent("ready"));
        this.isReady = true;
      });
    }
    disconnectedCallback() {
      this._view.trigger("disconnected");
    }
  };
  var CustomElementView = class extends HTMLBaseView {
    created() {
    }
    ready() {
    }
  };
  var CUSTOM_ELEMENTS = /* @__PURE__ */ new Map();
  function register(tagName, options = {}) {
    return function(ElementClass) {
      if (window.customElements.get(tagName)) {
        console.warn(`Trying to declare the custom element ${tagName} twice!`);
        return;
      }
      class Constructor extends CustomHTMLElement {
        constructor() {
          super();
          this._view = new ElementClass(this);
        }
      }
      CUSTOM_ELEMENTS.set(tagName, ElementClass);
      customElementOptions.set(tagName.toUpperCase(), options);
      window.customElements.define(tagName, Constructor);
    };
  }

  // content/solids/components/util.ts
  var DOTS = [
    [],
    // 0
    [[0, 0]],
    // 1
    [[-0.9, -0.9], [0.9, 0.9]],
    // 2
    [[-1, -1], [0, 0], [1, 1]],
    // 3
    [[-0.9, -0.9], [0.9, -0.9], [0.9, 0.9], [-0.9, 0.9]],
    // 4
    [[-1, -1], [1, -1], [1, 1], [-1, 1], [0, 0]],
    // 5
    [[-0.9, -1.1], [-0.9, 0], [-0.9, 1.1], [0.9, -1.1], [0.9, 0], [0.9, 1.1]]
    // 6
  ];
  function makeFaceContents(i) {
    const size = 100;
    const $rect = $N("rect", { width: `${size}%`, height: `${size}%`, fill: "white" });
    const halfSize = size / 2;
    const margin = 0.25;
    const marginSize = size * margin;
    const scale = (size - marginSize * 2) / size;
    const $dots = DOTS[i].map((p) => {
      const x = p[0] * halfSize + halfSize;
      const y = p[1] * halfSize + halfSize;
      return $N(
        "circle",
        {
          cx: `${x * scale + marginSize}%`,
          cy: `${y * scale + marginSize}%`,
          r: `${size / 9}%`,
          fill: "black"
        }
      );
    });
    return [$rect, $dots];
  }
  function makeFaceSVG(i) {
    const $contents = makeFaceContents(i);
    const $dieSVG = $N("svg", { viewbox: "0 0 100 100" });
    $dieSVG.append($contents[0]);
    for (const $dot of $contents[1]) $dieSVG.append($dot);
    return $dieSVG;
  }
  function placementsHave(p, v) {
    for (const k in p) {
      if (p[k] == v) return true;
    }
    return false;
  }
  function setupDieFacesPlacement($step, netPositions) {
    const placedCount = observe({ c: 0 });
    placedCount.watch((val) => {
      if (val.c == 6) $step.score("faces-placed");
    });
    const facesPlaced = {};
    const sideSize = 100;
    const $svg = $step.$("svg");
    const $rootGroup = $N("g", {}, $svg);
    const $targets = netPositions.map((netPosition, index) => {
      const [x, y] = netPosition.pos;
      const $sideGroup = $N("g", {}, $rootGroup);
      const shape = new Rectangle(new Point(0, 0), sideSize, sideSize);
      const $target = $N("path", {}, $sideGroup);
      $target.draw(shape);
      $target.addClass("target");
      $target.setAttr("side-index", index);
      $sideGroup.setAttr("transform", `translate(${x * sideSize} ${y * sideSize})`);
      return $target;
    });
    $rootGroup.setAttr("transform", "scale(0.8)");
    const $facesArea = $step.$("div.die-faces");
    const $faces = $facesArea.$$("div.face");
    for (const [index, $face] of $faces.entries()) {
      const $die = makeFaceSVG(index + 1);
      $face.append($die);
    }
    const faces = $faces.map(($face) => new Draggable($face, { $targets, useTransform: true, resetOnMiss: true, withinBounds: false }));
    for (const [index, face] of faces.entries()) {
      face.on("enter-target", ({ $target }) => {
        $target.addClass("over");
      });
      face.on("exit-target", ({ $target }) => {
        $target.removeClass("over");
      });
      const $f = face.$el.$("svg").copy(true);
      $f.setAttr("width", sideSize);
      $f.setAttr("height", sideSize);
      face.on("end", ({ $target }) => {
        var _a2;
        if ($target == void 0) return;
        $target.removeClass("over");
        const faceValue = index + 1;
        const targetIndex = parseInt($target.attr("side-index"));
        const oppositeIndex = netPositions[targetIndex].opposite;
        if (facesPlaced[oppositeIndex] == void 0 && !placementsHave(facesPlaced, 7 - faceValue) || facesPlaced[oppositeIndex] + faceValue == 7) {
          $target.addClass("placed");
          (_a2 = $target.parent) == null ? void 0 : _a2.prepend($f);
          facesPlaced[targetIndex] = faceValue;
          placedCount.c++;
          face.$el.remove();
          $step.addHint("correct");
          for (const f of faces) {
            f.removeTarget($target);
          }
        } else {
          $step.addHint("incorrect");
          face.resetPosition();
        }
      });
    }
  }

  // content/shared/components/webgl/webgl.ts
  var url = "/content/shared/vendor/three-91.min.js";
  var renderers = {};
  var threePromise;
  function loadTHREE() {
    if (!threePromise) threePromise = loadScript(url);
    return threePromise;
  }
  function getRenderer(width, height) {
    const id = [width, height].join(",");
    if (renderers[id]) return renderers[id];
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.localClippingEnabled = true;
    renderer.setClearColor(Browser.theme.isDark ? 2236718 : 16777215, 1);
    Browser.onThemeChange((t) => renderer.setClearColor(t.isDark ? 2236718 : 16777215, 1));
    renderer.setSize(width, height);
    return renderers[id] = renderer;
  }
  function create3D(_0, _1, _2) {
    return __async(this, arguments, function* ($el, fov, width, height = width, camera) {
      const $canvas = $N(
        "canvas",
        { width, height, style: "max-width: 100%" },
        $el
      );
      const context = $canvas.ctx;
      yield loadTHREE();
      const scene = new THREE.Scene();
      const renderer = getRenderer(width, height);
      if (!camera) camera = new THREE.PerspectiveCamera(fov, width / height, 0.1, 1e3);
      scene.add(camera);
      const callbacks = [];
      const onDraw = (fn) => callbacks.push(fn);
      const add = (obj) => scene.add(obj);
      const remove = (obj) => scene.remove(obj);
      const draw = () => {
        renderer.render(scene, camera);
        context.clearRect(0, 0, width, height);
        context.drawImage(renderer.domElement, 0, 0);
        for (const fn of callbacks) fn();
      };
      return { $canvas, camera, renderer, draw, onDraw, add, remove };
    });
  }

  // content/solids/components/voxel-painter.ts
  var TAU = Math.PI * 2;
  function snapToNearestValidCubeCenterPosition(p) {
    p.floor().addScalar(0.5);
  }
  var VoxelPainter = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.voxels = [];
      this.objectsOnWhichVoxelsCanBePlaced = [];
      this.mouseControlMode = "";
      this.placingHelpers = [];
    }
    ready() {
      return __async(this, null, function* () {
        var _a2;
        yield loadTHREE();
        class Voxel extends THREE.Mesh {
          constructor(voxelGeo, voxelMaterial, outlineGeometry, outlineMaterial, voxels2, objectsOnWhichVoxelsCanBePlaced2, scene) {
            super(voxelGeo.clone(), voxelMaterial);
            this.add(new THREE.LineSegments(outlineGeometry, outlineMaterial));
            voxels2.push(this);
            objectsOnWhichVoxelsCanBePlaced2.push(this);
            scene.add(this);
          }
        }
        this.newVoxel = (voxelGeo, voxelMaterial, outlineGeometry, outlineMaterial, voxels2, objectsOnWhichVoxelsCanBePlaced2, scene) => {
          return new Voxel(
            voxelGeo,
            voxelMaterial,
            outlineGeometry,
            outlineMaterial,
            voxels2,
            objectsOnWhichVoxelsCanBePlaced2,
            scene
          );
        };
        const width = +this.attr("width") || 400;
        const height = +this.attr("height") || width;
        this.css({ width: width + "px", height: height + "px" });
        const color = this.attr("color");
        this.v1 = new THREE.Vector3();
        this.explodeOnGrab = this.hasAttr("explodeOnGrab");
        this.rotateOnly = this.hasAttr("rotateOnly") || this.explodeOnGrab;
        this.targetVolume = +this.attr("targetVolume");
        this.targetSurface = +this.attr("targetSurface");
        const defaultGridDimension = 20;
        let gridDimension = +this.attr("playingFieldSize") || defaultGridDimension;
        if (gridDimension % 2 !== 0) {
          gridDimension = 2 * Math.ceil(gridDimension / 2);
        }
        this.playingFieldMin = new THREE.Vector3().setScalar(-gridDimension / 2 + 0.1);
        this.playingFieldMax = new THREE.Vector3().setScalar(gridDimension / 2 - 0.1);
        let customCamera = void 0;
        if (this.hasAttr("orthographic")) {
          const cameraW = 27 * gridDimension / defaultGridDimension;
          const cameraH = cameraW * height / width;
          customCamera = new THREE.OrthographicCamera(-cameraW, cameraW, cameraH, -cameraH, 1, 1e3);
        }
        this.scene = yield create3D(this, 45, 2 * width, 2 * height, customCamera);
        const camera = this.scene.camera;
        camera.rotation.order = "YXZ";
        camera.rotation.y = TAU / 8;
        camera.rotation.x = -TAU / 8;
        if (this.hasAttr("startingYRotation")) camera.rotation.y = +this.attr("startingYRotation") / 360 * TAU;
        if (this.hasAttr("startingXRotation")) camera.rotation.x = +this.attr("startingXRotation") / 360 * TAU;
        camera.position.x = 45;
        camera.position.setLength(camera.position.length() * gridDimension / defaultGridDimension);
        const $canvas = this.scene.$canvas;
        const objectsOnWhichVoxelsCanBePlaced = [];
        const voxels = this.voxels;
        const ambientLight = new THREE.AmbientLight(6316128);
        this.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(16777215);
        directionalLight.position.set(1, 0.75, 0.5).normalize();
        camera.updateMatrixWorld(false);
        camera.worldToLocal(directionalLight.position);
        camera.add(directionalLight);
        this.voxelGeo = new THREE.BoxGeometry(1, 1, 1);
        this.voxelMaterial = new THREE.MeshLambertMaterial({ color });
        const faceColours = [RED, BLUE, GREEN, YELLOW, ORANGE, PURPLE];
        const faceColorDirections = [
          new THREE.Vector3(1, 0, 0),
          new THREE.Vector3(-1, 0, 0),
          new THREE.Vector3(0, 1, 0),
          new THREE.Vector3(0, -1, 0),
          new THREE.Vector3(0, 0, 1),
          new THREE.Vector3(0, 0, -1)
        ];
        if (this.hasAttr("color-sides")) {
          this.sidesMaterial = new THREE.MeshLambertMaterial();
          for (let i = 0; i < 6; ++i) {
            const c2 = new THREE.Color(faceColours[i]);
            this.voxelGeo.faces[i * 2].color = this.voxelGeo.faces[i * 2 + 1].color = c2;
          }
          this.sidesMaterial.vertexColors = true;
          this.sidesMaterial.color.setRGB(1, 1, 1);
        }
        this.outlineGeometry = new THREE.Geometry();
        this.outlineMaterial = new THREE.LineBasicMaterial();
        const cubeEdges = [0, 1, 2, 3, 5, 4, 7, 6, 0, 2, 1, 3, 5, 7, 4, 6, 0, 5, 1, 4, 2, 7, 3, 6];
        for (let i = 0; i < cubeEdges.length; i++) {
          this.outlineGeometry.vertices[i] = this.voxelGeo.vertices[cubeEdges[i]].clone();
        }
        const placementMaterial = new THREE.MeshBasicMaterial({ color: 16711680, opacity: 0.4, transparent: true });
        this.placementVisualizer = new THREE.Mesh(this.voxelGeo, placementMaterial);
        this.scene.add(this.placementVisualizer);
        this.placementVisualizer.add(new THREE.LineSegments(this.outlineGeometry, this.outlineMaterial));
        {
          const isInShapeFunctions = {};
          const sphereRadius = 5;
          const sphereCenter = new THREE.Vector3(0, sphereRadius, 0);
          isInShapeFunctions.sphere = (p) => p.distanceTo(sphereCenter) < sphereRadius;
          const cuboidDimensions = new THREE.Vector3(4, 3, 5);
          const cuboidCenter = new THREE.Vector3(0, cuboidDimensions.y / 2 + 1, 0);
          isInShapeFunctions.cuboid = (p) => {
            return Math.abs(p.x - cuboidCenter.x) < cuboidDimensions.x / 2 && Math.abs(p.y - cuboidCenter.y) < cuboidDimensions.y / 2 && Math.abs(p.z - cuboidCenter.z) < cuboidDimensions.z / 2;
          };
          const cylinderRadius = 6;
          const cylinderHeight = 4;
          const cylinderCenter = new THREE.Vector3(0, cylinderHeight / 2 + 1, 0);
          isInShapeFunctions.cylinder = (p) => {
            this.v1.copy(p);
            this.v1.sub(cylinderCenter);
            return this.v1.x * this.v1.x + this.v1.z * this.v1.z < cylinderRadius * cylinderRadius && Math.abs(this.v1.y) < cylinderHeight / 2;
          };
          const shape = this.attr("shape");
          if (isInShapeFunctions[shape] !== void 0) {
            const isInShapeFunction = isInShapeFunctions[shape];
            const p = new THREE.Vector3();
            for (let i = -10; i < 10; i++) {
              for (let j = -10; j < 10; j++) {
                for (let k = -10; k < 10; k++) {
                  p.set(i, j, k).addScalar(0.5);
                  if (isInShapeFunction(p)) {
                    const voxel = new Voxel(
                      this.voxelGeo,
                      (_a2 = this.sidesMaterial) != null ? _a2 : this.voxelMaterial,
                      this.outlineGeometry,
                      this.outlineMaterial,
                      this.voxels,
                      this.objectsOnWhichVoxelsCanBePlaced,
                      this.scene
                    );
                    voxel.position.copy(p);
                  }
                }
              }
            }
          }
          const coords = shape.split(",");
          for (let i = 0, il = Math.floor(coords.length / 3); i < il; ++i) {
            this.addVoxelInternal(
              parseFloat(coords[i * 3]),
              parseFloat(coords[i * 3 + 1]),
              parseFloat(coords[i * 3 + 2])
            );
          }
          if (this.explodeOnGrab) {
            const p = new THREE.Vector3();
            for (let i = 0, il = this.voxels.length; i < il; ++i) {
              for (let k = 0; k < 6; k++) {
                let nothingInThisDirection = true;
                p.copy(this.voxels[i].position).add(faceColorDirections[k]);
                for (let j = 0; j < il; ++j) {
                  if (this.voxels[j].position.distanceToSquared(p) < 0.01) {
                    nothingInThisDirection = false;
                  }
                }
                if (!nothingInThisDirection) {
                  this.voxels[i].geometry.faces[k * 2 + 0].color.setRGB(0.4, 0.4, 0.4);
                  this.voxels[i].geometry.faces[k * 2 + 1].color.setRGB(0.4, 0.4, 0.4);
                }
              }
            }
          }
        }
        this.pointerRaycaster = new THREE.Raycaster();
        this.placingStart = new THREE.Vector3();
        this.placingEnd = new THREE.Vector3();
        const floorIntersectionPlaneGeometry = new THREE.PlaneBufferGeometry(gridDimension, gridDimension);
        floorIntersectionPlaneGeometry.rotateX(-Math.PI / 2);
        const floorIntersectionPlane = new THREE.Mesh(floorIntersectionPlaneGeometry, new THREE.MeshBasicMaterial({ visible: false }));
        const grid = new THREE.GridHelper(gridDimension, gridDimension);
        this.scene.add(floorIntersectionPlane);
        floorIntersectionPlane.add(grid);
        if (this.hasAttr("hideGrid")) {
          grid.visible = false;
        }
        objectsOnWhichVoxelsCanBePlaced.push(floorIntersectionPlane);
        floorIntersectionPlane.position.y -= gridDimension / 2;
        for (let i = 0; i < 3; i++) {
          const placingHelper = new THREE.Mesh(new THREE.PlaneBufferGeometry(999, 999), new THREE.MeshBasicMaterial({
            side: THREE.DoubleSide,
            // transparent:true,
            // opacity:.5,
            visible: false
          }));
          this.placingHelpers.push(placingHelper);
          this.scene.add(placingHelper);
        }
        this.placingHelpers[0].geometry.rotateX(TAU / 4);
        this.placingHelpers[1].geometry.rotateY(TAU / 4);
        this.asyncPointerNdc = new THREE.Vector3();
        this.pointerNdc = new THREE.Vector3();
        this.oldPointerNdc = new THREE.Vector3();
        $canvas.on("pointermove", (event) => {
          event.preventDefault();
          const p = canvasPointerPosition(event, $canvas);
          this.respondToPointerMovement(p);
        });
        this.pointToExplodeFrom = new THREE.Vector3();
        this.initialPositions = Array(voxels.length);
        for (let i = 0, il = voxels.length; i < il; ++i) {
          this.pointToExplodeFrom.add(voxels[i].position);
          this.initialPositions[i] = voxels[i].position.clone();
        }
        this.pointToExplodeFrom.multiplyScalar(1 / voxels.length);
        if (!this.hasAttr("noInteraction")) {
          slide($canvas, {
            down: () => {
              this.mouseControlMode = "rotating";
              const intersection = this.pointerRaycaster.intersectObjects(objectsOnWhichVoxelsCanBePlaced)[0];
              if (!this.rotateOnly && intersection !== void 0) {
                this.setFromVoxelIntersection(this.v1, intersection);
                if (this.pointInPlayingField(this.v1)) {
                  this.mouseControlMode = "placing";
                  this.placingStart.copy(this.v1);
                  this.placingEnd.copy(this.placingStart);
                  this.getCameraDirectionSnappedToGrid(this.v1);
                  this.v1.add(this.placingStart);
                  for (let i = 0; i < 3; i++) {
                    this.placingHelpers[i].position.copy(this.v1);
                    this.placingHelpers[i].updateMatrixWorld(false);
                  }
                }
              }
            },
            move: this.respondToPointerMovement,
            up: () => {
              var _a3;
              if (this.mouseControlMode === "placing") {
                this.mouseControlMode = "";
                let iComponent = 0;
                if (this.placingStart.x === this.placingEnd.x) iComponent = 1;
                if (this.placingStart.y === this.placingEnd.y) iComponent = 2;
                if (this.placingStart.z === this.placingEnd.z) iComponent = 0;
                const jComponent = (iComponent + 1) % 3;
                const kComponent = (jComponent + 1) % 3;
                const k = this.placingStart.getComponent(kComponent);
                const iStart = Math.min(this.placingStart.getComponent(iComponent), this.placingEnd.getComponent(iComponent));
                const iLimit = Math.max(this.placingStart.getComponent(iComponent), this.placingEnd.getComponent(iComponent));
                const jStart = Math.min(this.placingStart.getComponent(jComponent), this.placingEnd.getComponent(jComponent));
                const jLimit = Math.max(this.placingStart.getComponent(jComponent), this.placingEnd.getComponent(jComponent));
                const potentialNewPosition = new THREE.Vector3();
                for (let i = iStart; i <= iLimit; i += 1) {
                  for (let j = jStart; j <= jLimit; j += 1) {
                    potentialNewPosition.setComponent(kComponent, k);
                    potentialNewPosition.setComponent(iComponent, i);
                    potentialNewPosition.setComponent(jComponent, j);
                    snapToNearestValidCubeCenterPosition(potentialNewPosition);
                    let alreadyOccupied = false;
                    voxels.forEach((voxel) => {
                      if (voxel.position.equals(potentialNewPosition)) alreadyOccupied = true;
                    });
                    if (!alreadyOccupied) {
                      new Voxel(
                        this.voxelGeo,
                        (_a3 = this.sidesMaterial) != null ? _a3 : this.voxelMaterial,
                        this.outlineGeometry,
                        this.outlineMaterial,
                        this.voxels,
                        this.objectsOnWhichVoxelsCanBePlaced,
                        this.scene
                      ).position.copy(potentialNewPosition);
                      if (this.getVolume() == this.targetVolume && this.getSurfaceArea() == this.targetSurface) {
                        this.trigger("both-targets-met", this.voxelPositions);
                      } else {
                        if (this.getVolume() == this.targetVolume) {
                          this.trigger("volume-target-met", this.voxelPositions);
                        }
                        if (this.getSurfaceArea() == this.targetSurface) {
                          this.trigger("area-target-met", this.voxelPositions);
                        }
                      }
                    }
                  }
                }
              }
              if (this.mouseControlMode === "rotating") {
                this.mouseControlMode = "";
                animate((timeSinceStart, timeDifference, cancel) => {
                  const snapSpaceAngleX = camera.rotation.x / (TAU / 16);
                  const destination = Math.round(snapSpaceAngleX);
                  const stepX = getStepTowardDestination(snapSpaceAngleX, destination);
                  const newSnapSpaceAngleX = snapSpaceAngleX + stepX;
                  camera.rotation.x = newSnapSpaceAngleX * (TAU / 16);
                  const snapSpaceAngleY = camera.rotation.y / (TAU / 8);
                  const stepY = getStepTowardDestination(snapSpaceAngleY, Math.round(snapSpaceAngleY));
                  const newSnapSpaceAngleY = snapSpaceAngleY + stepY;
                  camera.rotation.y = newSnapSpaceAngleY * (TAU / 8);
                  if (stepX == 0 && stepY == 0) {
                    if (this.explodeOnGrab) {
                      this.setVoxelPositionsFromExplodedness(0);
                    }
                    this.updateApplet();
                    cancel();
                  } else {
                    if (this.explodeOnGrab) {
                      this.setVoxelPositionsFromExplodedness(0.8);
                    }
                    this.updateApplet();
                  }
                }).promise.catch(() => void 0).then(() => {
                  const [y, x, z] = camera.rotation.toArray().slice(0, 3).map((a2) => Angle.fromRadians(a2).deg);
                  let faceName = "none";
                  if (nearlyEquals(y, 0) && nearlyEquals(z, 0)) {
                    if (nearlyEquals(x, 90)) faceName = "front";
                    else if (nearlyEquals(x, 180)) faceName = "right";
                    else if (nearlyEquals(x, 270)) faceName = "back";
                    else if (nearlyEquals(x, 360) || nearlyEquals(x, 0)) faceName = "left";
                  } else if (nearlyEquals(x, 0) || nearlyEquals(x, 90) || nearlyEquals(x, 180) || nearlyEquals(x, 270) || nearlyEquals(x, 360)) {
                    if (nearlyEquals(y, 270)) faceName = "top";
                    else if (nearlyEquals(y, 90)) faceName = "bottom";
                  }
                  this.trigger("snap", [faceName, [y, x, z]]);
                });
              }
              this.updateApplet();
            }
          });
        }
        function getStepTowardDestination(currentValue, destination) {
          const distanceFromDestination = destination - currentValue;
          const sign = distanceFromDestination == 0 ? 0 : distanceFromDestination / Math.abs(distanceFromDestination);
          let speed = 0.01;
          if (speed > Math.abs(distanceFromDestination)) {
            speed = Math.abs(distanceFromDestination);
          }
          return sign * speed;
        }
        this.updateApplet();
      });
    }
    get voxelPositions() {
      return this.voxels.map((voxel) => {
        const pos = voxel.position;
        return [pos.x, pos.y, pos.z];
      });
    }
    setFromVoxelIntersection(target, intersection) {
      target.copy(intersection.face.normal).multiplyScalar(0.1);
      target.add(intersection.point);
      snapToNearestValidCubeCenterPosition(target);
    }
    /**
     * best done with a point already on grid
     */
    pointInPlayingField(p) {
      return this.playingFieldMin.x < p.x && p.x < this.playingFieldMax.x && this.playingFieldMin.y < p.y && p.y < this.playingFieldMax.y && this.playingFieldMin.z < p.z && p.z < this.playingFieldMax.z;
    }
    updateApplet() {
      if (this.scene != void 0) {
        this.oldPointerNdc.copy(this.pointerNdc);
        this.pointerNdc.copy(this.asyncPointerNdc);
        const camera = this.scene.camera;
        this.pointerRaycaster.setFromCamera(this.pointerNdc, camera);
        {
          if (this.mouseControlMode === "rotating") {
            camera.rotation.y -= this.pointerNdc.x - this.oldPointerNdc.x;
            camera.rotation.x += this.pointerNdc.y - this.oldPointerNdc.y;
            camera.rotation.x = clamp(camera.rotation.x, -TAU / 4, TAU / 4);
            if (this.explodeOnGrab) {
              this.setVoxelPositionsFromExplodedness(0.8);
            }
          }
          const currentDistFromCamera = camera.position.length();
          camera.updateMatrixWorld(false);
          this.v1.set(0, 0, -currentDistFromCamera);
          camera.localToWorld(this.v1);
          camera.position.sub(this.v1);
        }
        if (this.mouseControlMode === "placing") {
          const snapSpaceCameraRotationY = (camera.rotation.y - TAU / 8) / (TAU / 4);
          const distanceFromDiagonalViewpoint = Math.abs(snapSpaceCameraRotationY - Math.round(snapSpaceCameraRotationY));
          const distanceFromTopOrBottomViewpoint = TAU / 4 - Math.abs(camera.rotation.x);
          const placingHelpersArrayToUse = distanceFromDiagonalViewpoint < 0.1 && distanceFromTopOrBottomViewpoint > 0.1 ? this.placingHelpers : [this.placingHelpers[0]];
          const intersection = this.pointerRaycaster.intersectObjects(placingHelpersArrayToUse)[0];
          if (intersection !== void 0) {
            this.getCameraDirectionSnappedToGrid(this.placingEnd);
            this.placingEnd.negate().setLength(0.1);
            this.placingEnd.add(intersection.point);
            this.placingEnd.clamp(this.playingFieldMin, this.playingFieldMax);
            snapToNearestValidCubeCenterPosition(this.placingEnd);
            this.placementVisualizer.position.addVectors(this.placingEnd, this.placingStart).multiplyScalar(0.5);
            this.placementVisualizer.scale.x = 1 + 2 * Math.abs(this.placementVisualizer.position.x - this.placingEnd.x);
            this.placementVisualizer.scale.y = 1 + 2 * Math.abs(this.placementVisualizer.position.y - this.placingEnd.y);
            this.placementVisualizer.scale.z = 1 + 2 * Math.abs(this.placementVisualizer.position.z - this.placingEnd.z);
          }
        } else {
          this.placementVisualizer.scale.setScalar(1e-7);
          if (!this.rotateOnly && this.mouseControlMode === "") {
            const intersections2 = this.pointerRaycaster.intersectObjects(this.objectsOnWhichVoxelsCanBePlaced);
            if (intersections2.length !== 0) {
              this.setFromVoxelIntersection(this.placementVisualizer.position, intersections2[0]);
              if (this.pointInPlayingField(this.placementVisualizer.position)) {
                this.placementVisualizer.scale.setScalar(1);
              }
            }
          }
        }
        if (this.mouseControlMode === "erasing") {
          let voxelIntersectedByEraser = void 0;
          const intersections2 = this.pointerRaycaster.intersectObjects(this.voxels);
          if (intersections2.length > 0) voxelIntersectedByEraser = intersections2[0].object;
          if (this.lastVoxelIntersectedByEraser && this.voxels.indexOf(this.lastVoxelIntersectedByEraser) !== -1 && this.lastVoxelIntersectedByEraser !== voxelIntersectedByEraser) {
            this.scene.remove(this.lastVoxelIntersectedByEraser);
            this.objectsOnWhichVoxelsCanBePlaced.splice(this.objectsOnWhichVoxelsCanBePlaced.indexOf(this.lastVoxelIntersectedByEraser), 1);
            this.voxels.splice(this.voxels.indexOf(this.lastVoxelIntersectedByEraser), 1);
          }
          this.lastVoxelIntersectedByEraser = voxelIntersectedByEraser;
        }
        this.scene.draw();
      }
    }
    respondToPointerMovement(p) {
      if (this.scene != void 0) {
        this.scene.camera.updateMatrixWorld(false);
        const $canvas = this.scene.$canvas;
        this.asyncPointerNdc.set(
          p.x / $canvas.canvasWidth * 2 - 1,
          -(p.y / $canvas.canvasHeight) * 2 + 1,
          0
        );
        this.updateApplet();
      }
    }
    getCameraDirectionSnappedToGrid(target) {
      if (this.scene != void 0) {
        target.set(0, 0, -1).applyQuaternion(this.scene.camera.quaternion);
        target.x = target.x > 0 ? 0.5 : -0.5;
        target.y = target.y > 0 ? 0.5 : -0.5;
        target.z = target.z > 0 ? 0.5 : -0.5;
      }
    }
    setVoxelPositionsFromExplodedness(explodedness) {
      for (let i = 0, il = this.voxels.length; i < il; ++i) {
        this.voxels[i].position.copy(this.initialPositions[i]).sub(this.pointToExplodeFrom).multiplyScalar(1 + explodedness).add(this.pointToExplodeFrom);
      }
    }
    addVoxelBase(x, y, z, voxelMaterial) {
      const voxel = this.newVoxel(
        this.voxelGeo,
        voxelMaterial,
        this.outlineGeometry,
        this.outlineMaterial,
        this.voxels,
        this.objectsOnWhichVoxelsCanBePlaced,
        this.scene
      );
      voxel.position.set(x, z, y);
      snapToNearestValidCubeCenterPosition(voxel.position);
    }
    addVoxelInternal(x, y, z) {
      var _a2;
      this.addVoxelBase(x, y, z, (_a2 = this.sidesMaterial) != null ? _a2 : this.voxelMaterial);
    }
    /**
     * IMPORTANT: Do not use until ready() is done!
     */
    addVoxel(x, y, z, color) {
      var _a2;
      const voxelMat = color != void 0 ? new THREE.MeshLambertMaterial({ color }) : (_a2 = this.sidesMaterial) != null ? _a2 : this.voxelMaterial;
      this.addVoxelBase(x, y, z, voxelMat);
    }
    /**
     * IMPORTANT: Do not use until ready() is done!
     */
    addVoxels(positions, color) {
      for (const position of positions) {
        this.addVoxel(...position, color);
      }
      this.updateApplet();
    }
    clearVoxels() {
      if (this.scene != void 0) {
        for (const voxel of this.voxels) {
          this.scene.remove(voxel);
        }
        this.voxels = [];
        this.updateApplet();
      }
    }
    getSurfaceArea() {
      let surface = 6 * this.voxels.length;
      for (const v of this.voxels) {
        surface -= this.voxels.filter((w) => w !== v && w.position.distanceToSquared(v.position) < 1.1).length;
      }
      return surface;
    }
    getVolume() {
      return this.voxels.length;
    }
  };
  VoxelPainter = __decorateClass([
    register("x-voxel-painter")
  ], VoxelPainter);

  // content/shared/components/webgl/solid.ts
  var STROKE_COLOR = 6710886;
  var LINE_RADIUS = 0.012;
  var LINE_SEGMENTS = 4;
  var POINT_RADIUS = 0.08;
  function createEdges(geometry, material, maxAngle) {
    const obj = new THREE.Object3D();
    if (!maxAngle) return obj;
    const edges = new THREE.EdgesGeometry(geometry, maxAngle);
    const edgeData = edges.attributes.position.array;
    const points = chunk(chunk(edgeData, 3).map((p) => new THREE.Vector3(...p)), 2);
    for (const edge of points) {
      const curve = new THREE.LineCurve3(edge[0], edge[1]);
      const geometry2 = new THREE.TubeGeometry(curve, 1, LINE_RADIUS, LINE_SEGMENTS);
      obj.add(new THREE.Mesh(geometry2, material));
    }
    return obj;
  }
  var Solid = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.isReady = false;
    }
    ready() {
      return __async(this, null, function* () {
        const size = this.attr("size").split(",");
        const width = +size[0];
        const height = size.length > 1 ? +size[1] : width;
        this.css({ width: width + "px", height: height + "px" });
        this.scene = yield create3D(this, 35, 2 * width, 2 * height);
        this.scene.camera.position.set(0, 3, 6);
        this.scene.camera.up = new THREE.Vector3(0, 1, 0);
        this.scene.camera.lookAt(new THREE.Vector3(0, 0, 0));
        const light1 = new THREE.AmbientLight(5592405);
        this.scene.add(light1);
        const light2 = new THREE.PointLight(16777215);
        light2.position.set(3, 4.5, 6);
        this.scene.add(light2);
        this.object = new THREE.Object3D();
        this.scene.add(this.object);
        this.trigger("loaded");
        this.isReady = true;
      });
    }
    addMesh(fn) {
      if (this.isReady) {
        this.addMeshCallback(fn);
      } else {
        this.one("loaded", () => this.addMeshCallback(fn));
      }
    }
    addMeshCallback(fn) {
      const items = fn(this.scene) || [];
      for (const i of items) this.object.add(i);
      if (!this.hasAttr("static")) {
        const speed = +this.attr("rotate");
        this.setupRotation(this.hasAttr("rotate"), isNaN(speed) ? 1 : speed);
      }
      this.scene.draw();
    }
    rotate(q) {
      this.object.quaternion.set(q.x, q.y, q.z, q.w);
      this.scene.draw();
    }
    setupRotation(animate2 = true, speed = 1) {
      const autoRotate = animate2 && speed && Browser.isChrome && !Browser.isMobile;
      this.css("cursor", "grab");
      let dragging = false;
      let visible = false;
      const frame = () => {
        if (visible && autoRotate) requestAnimationFrame(frame);
        this.scene.draw();
        if (!dragging) this.object.rotation.y += speed * 0.012;
      };
      if (autoRotate) {
        this.scene.$canvas.on("enterViewport", () => {
          visible = true;
          frame();
        });
        this.scene.$canvas.on("exitViewport", () => visible = false);
      } else {
        setTimeout(frame);
      }
      const s = Math.PI / 2 / this.scene.$canvas.width * 1.1;
      slide(this.scene.$canvas, {
        start: () => {
          dragging = true;
          $html.addClass("grabbing");
        },
        move: (posn, start, last2) => {
          const d2 = posn.subtract(last2).scale(s);
          const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(d2.y, d2.x));
          this.object.quaternion.multiplyQuaternions(q, this.object.quaternion);
          this.trigger("rotate", { quaternion: this.object.quaternion });
          if (!autoRotate) frame();
        },
        end: () => {
          dragging = false;
          $html.removeClass("grabbing");
        }
      });
    }
    // ---------------------------------------------------------------------------
    // Element Creation Utilities
    addLabel(text, posn, color = STROKE_COLOR, margin) {
      const $label = $N("div", { text, class: "label3d" });
      $label.css("color", "#" + color.toString(16).padStart(6, "0"));
      if (margin) $label.css("margin", margin);
      let posn1 = new THREE.Vector3(...posn);
      this.scene.$canvas.insertAfter($label);
      this.scene.onDraw(() => {
        const p = posn1.clone().applyQuaternion(this.object.quaternion).add(this.object.position).project(this.scene.camera);
        $label.css("left", (1 + p.x) * this.scene.$canvas.width / 2 + "px");
        $label.css("top", (1 - p.y) * this.scene.$canvas.height / 2 + "px");
      });
      return {
        updatePosition(posn2) {
          posn1 = new THREE.Vector3(...posn2);
        }
      };
    }
    addLine(from, to, color = STROKE_COLOR, arrows = false) {
      const material = new THREE.MeshBasicMaterial({ color });
      const obj = new THREE.Object3D();
      const height = new THREE.Vector3(...from).distanceTo(new THREE.Vector3(...to));
      const line = new THREE.CylinderGeometry(0.02, 0.02, height - (arrows ? 0.3 : 0), 8, 1, arrows);
      obj.add(new THREE.Mesh(line, material));
      if (arrows) {
        const start = new THREE.ConeGeometry(0.1, 0.15, 16, 1);
        start.translate(0, height / 2 - 0.1, 0);
        obj.add(new THREE.Mesh(start, material));
        const end = new THREE.ConeGeometry(0.1, 0.15, 16, 1);
        end.rotateX(Math.PI);
        end.translate(0, -height / 2 + 0.1, 0);
        obj.add(new THREE.Mesh(end, material));
      }
      obj.updateEnds = function(f, t) {
        const q = new THREE.Quaternion();
        const v = new THREE.Vector3(t[0] - f[0], t[1] - f[1], t[2] - f[2]).normalize();
        q.setFromUnitVectors(new THREE.Vector3(0, 1, 0), v);
        obj.setRotationFromQuaternion(q);
        obj.position.set((f[0] + t[0]) / 2, (f[1] + t[1]) / 2, (f[2] + t[2]) / 2);
      };
      obj.updateEnds(from, to);
      this.object.add(obj);
      return obj;
    }
    addArrow(from, to, color = STROKE_COLOR) {
      return this.addLine(from, to, color, true);
    }
    addCircle(radius, color = STROKE_COLOR, segments = 64) {
      const path = new THREE.Curve();
      path.getPoint = function(t) {
        const a2 = 2 * Math.PI * t;
        return new THREE.Vector3(radius * Math.cos(a2), radius * Math.sin(a2), 0);
      };
      const material = new THREE.MeshBasicMaterial({ color });
      const geometry = new THREE.TubeGeometry(path, segments, LINE_RADIUS, LINE_SEGMENTS);
      const mesh = new THREE.Mesh(geometry, material);
      this.object.add(mesh);
      return mesh;
    }
    addPoint(position, color = STROKE_COLOR) {
      const material = new THREE.MeshBasicMaterial({ color });
      const geometry = new THREE.SphereGeometry(POINT_RADIUS, 16, 16);
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(...position);
      this.object.add(mesh);
    }
    addSolid(geo, color, maxAngle = 5, flatShading = false) {
      const edgeMaterial = new THREE.LineBasicMaterial({ color: 16777215 });
      const edges = new THREE.EdgesGeometry(geo, maxAngle);
      const obj = new THREE.Object3D();
      obj.add(new THREE.LineSegments(edges, edgeMaterial));
      obj.add(new THREE.Mesh(geo, Solid.solidMaterial(color, flatShading)));
      this.object.add(obj);
      return obj;
    }
    // TODO merge addOutlined() and addWireframe(), by looking at
    //      geometry.isConeGeometry etc.
    // A translucent material with a solid border.
    addOutlined(geo, color = 11184810, maxAngle = 5, opacity = 0.1, strokeColor) {
      const solidMaterial = Solid.translucentMaterial(color, opacity);
      const solid = new THREE.Mesh(geo, solidMaterial);
      const edgeMaterial = new THREE.MeshBasicMaterial({ color: strokeColor || STROKE_COLOR });
      let edges = createEdges(geo, edgeMaterial, maxAngle);
      const obj = new THREE.Object3D();
      obj.add(solid, edges);
      obj.setClipPlanes = function(planes) {
        solidMaterial.clippingPlanes = planes;
      };
      obj.updateGeometry = function(geo2) {
        solid.geometry.dispose();
        solid.geometry = geo2;
        obj.remove(edges);
        edges = createEdges(geo2, edgeMaterial, maxAngle);
        obj.add(edges);
      };
      this.object.add(obj);
      return obj;
    }
    // Like .addOutlined, but we also add outlines for curved edges (e.g. of
    // a sphere or cylinder).
    addWireframe(geometry, color = 11184810, maxAngle = 5, opacity = 0.1) {
      const solid = this.addOutlined(geometry, color, maxAngle, opacity);
      const outlineMaterial = new THREE.MeshBasicMaterial({
        color: STROKE_COLOR,
        side: THREE.BackSide
      });
      outlineMaterial.onBeforeCompile = function(shader) {
        const token = "#include <begin_vertex>";
        const customTransform = "\nvec3 transformed = position + vec3(normal) * 0.02;\n";
        shader.vertexShader = shader.vertexShader.replace(token, customTransform);
      };
      const outline = new THREE.Mesh(geometry, outlineMaterial);
      const knockoutMaterial = new THREE.MeshBasicMaterial({
        color: 16777215,
        side: THREE.BackSide
      });
      const knockout = new THREE.Mesh(geometry, knockoutMaterial);
      const obj = new THREE.Object3D();
      obj.add(solid, outline, knockout);
      obj.setClipPlanes = function(planes) {
        if (solid.setClipPlanes) solid.setClipPlanes(planes);
        for (const m of [outlineMaterial, knockoutMaterial]) {
          m.clippingPlanes = planes;
        }
      };
      obj.updateGeometry = function(geo) {
        if (solid.updateGeometry) solid.updateGeometry(geo);
        for (const mesh of [outline, knockout]) {
          mesh.geometry.dispose();
          mesh.geometry = geo;
        }
      };
      this.object.add(obj);
      return obj;
    }
    // ---------------------------------------------------------------------------
    // Materials
    static solidMaterial(color, flatShading = false) {
      return new THREE.MeshPhongMaterial({
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.9,
        specular: 2236962,
        // depthWrite: false,
        color,
        flatShading
      });
    }
    static translucentMaterial(color, opacity = 0.1) {
      return new THREE.MeshLambertMaterial({
        side: THREE.DoubleSide,
        transparent: true,
        depthWrite: false,
        opacity,
        color
      });
    }
  };
  Solid = __decorateClass([
    register("x-solid")
  ], Solid);

  // content/solids/components/net.ts
  var Net = class extends Solid {
    constructor() {
      super(...arguments);
      this.hingeBones = [];
      this.setFoldAmount = (amount) => {
        const hb = this.hingeBones.slice(1);
        for (const hingeBone of hb) {
          setHingeBendAmount(hingeBone, amount);
        }
      };
    }
    created() {
      this.one("loaded", () => this.loaded = true);
    }
    add(faces, hinges, scale) {
      const netPoints = mergePolys(faces).points;
      const geoInit = new THREE.Geometry();
      for (const netPoint of netPoints) {
        geoInit.vertices.push(new THREE.Vector3(netPoint.x, netPoint.y, 0));
      }
      const facesTris = faces.map(triangulateFace);
      for (const faceTris of facesTris) {
        for (const tri of faceTris) {
          const [a2, b2, c2] = tri.map((point) => netPoints.findIndex((p) => p.equals(point)));
          geoInit.faces.push(new THREE.Face3(a2, b2, c2));
        }
      }
      const baseCenter = faces[0].centroid;
      const rootBone = new THREE.Bone();
      rootBone.name = "root";
      rootBone.position.set(baseCenter.x, baseCenter.y, 0);
      const rootHingeBone = {
        bone: rootBone,
        verts: faces[0].points,
        axis: new THREE.Vector3(0, 0, 0),
        maxAngle: 0
      };
      const hingeBonesTail = boneHingesForFace(
        0,
        void 0,
        rootBone,
        faces,
        hinges
      );
      const hingeBones = [rootHingeBone, ...hingeBonesTail];
      this.hingeBones = hingeBones;
      const geometry = new THREE.BufferGeometry().fromGeometry(geoInit);
      const skinIndices = [];
      const skinWeights = [];
      const position = geometry.attributes.position;
      const vertex = new THREE.Vector3();
      for (let i = 0; i < position.count; i++) {
        vertex.fromBufferAttribute(position, i);
        const testPoint = new Point(vertex.x, vertex.y);
        const boneIndex = getBoneIndexFromPoint(testPoint, hingeBones);
        skinIndices.push(boneIndex, 0, 0, 0);
        skinWeights.push(1, 0, 0, 0);
      }
      geometry.addAttribute("skinIndex", new THREE.Uint16BufferAttribute(skinIndices, 4));
      geometry.addAttribute("skinWeight", new THREE.Float32BufferAttribute(skinWeights, 4));
      const mat = Solid.solidMaterial(2272036, true);
      mat.skinning = true;
      const mesh = new THREE.SkinnedMesh(geometry, mat);
      const skeleton = new THREE.Skeleton(hingeBones.map((hingeBone) => hingeBone.bone));
      mesh.add(skeleton.bones[0]);
      mesh.bind(skeleton);
      this.scene.add(mesh);
      this.scene.camera.lookAt(mesh.position);
      skeleton.bones[0].rotateX(Math.PI / 2);
      skeleton.bones[0].position.set(0, 0, 0);
      if (scale != void 0) skeleton.bones[0].scale.set(scale, scale, scale);
      return [mesh];
    }
    /**
      * Note: the item at `faces[0]` is used to determine the 'root' of the skeleton
      * and thus the net.
      */
    addNet(faces, hinges, scale) {
      this.addMesh(
        () => this.add(faces, hinges, scale)
      );
    }
    addCuboidNet(width, height, depth) {
      const p = ORIGIN;
      const faces = [
        new Rectangle(p, width, depth),
        // bottom (base)
        new Rectangle(p.shift(width, 0), height, depth),
        // 'right'
        new Rectangle(p.shift(-width, 0), height, depth),
        // 'left'
        new Rectangle(p.shift(-(width + height), 0), width, depth),
        // top
        new Rectangle(p.shift(0, depth), width, height),
        // front
        new Rectangle(p.shift(0, -depth), width, height)
        // back
      ].map((rect) => rect.polygon);
      const hinges = [
        [0, 1, 90],
        [0, 2, 90],
        [0, 4, 90],
        [0, 5, 90],
        [2, 3, 90]
        // [TODO]: 2 and 3 are not adjacent somehow, need to re-eval this
      ];
      this.addNet(faces, hinges);
    }
    /**
     * @param amount Ratio from 0 to 1
     */
    fold(amount) {
      if (this.loaded) {
        this.setFoldAmount(amount);
        this.scene.draw();
      } else {
        this.one("loaded", () => {
          this.setFoldAmount(amount);
          this.scene.draw();
        });
      }
    }
  };
  Net = __decorateClass([
    register("x-net")
  ], Net);
  function parentHinge(hinge, parentFaceIndex) {
    if (parentFaceIndex === void 0) return false;
    return hinge[0] == parentFaceIndex || hinge[1] == parentFaceIndex;
  }
  function boneHingesForFace(currentFaceIndex, previousFaceIndex, previousBone, faces, hinges) {
    const currentFace = faces[currentFaceIndex];
    const hingesToProcess = hingesForFace(currentFaceIndex, hinges).filter((hinge) => !parentHinge(hinge, previousFaceIndex));
    const nextFaces = hingesToProcess.map(
      (hinge) => otherFaceIndex(currentFaceIndex, hinge)
    );
    const boneHinges = nextFaces.reduce(
      (acc, faceIndex) => {
        const nextFace = faces[faceIndex];
        const hingeEdge = getCommonEdge(currentFace, nextFace);
        const midpoint = hingeEdge.midpoint;
        const angle = Angle.fromRadians(hingeEdge.angle);
        const angleCoords = new Point(1, 0).rotate(angle.rad, new Point(0, 0));
        const axis = new THREE.Vector3(round(angleCoords.x, 10), round(angleCoords.y, 10), 0);
        const bone = new THREE.Bone();
        bone.name = `${currentFaceIndex}-${faceIndex}`;
        const parentPos = new THREE.Vector3();
        previousBone.getWorldPosition(parentPos);
        const parentPosPoint = new Point(parentPos.x, parentPos.y);
        const diff = midpoint.subtract(parentPosPoint);
        bone.position.set(diff.x, diff.y, 0);
        previousBone.add(bone);
        const verts = nextFace.points.filter(
          (point) => !point.equals(hingeEdge.p1) && !point.equals(hingeEdge.p2)
        );
        const hinge = hingeForFaces(faceIndex, currentFaceIndex, hinges);
        const [_a2, _b, maxAngleDeg] = hinge;
        const maxAngle = Angle.fromDegrees(maxAngleDeg).rad;
        const boneHinge = {
          bone,
          verts,
          axis,
          maxAngle
        };
        const children = acc.concat(
          boneHingesForFace(
            faceIndex,
            currentFaceIndex,
            bone,
            faces,
            hinges
          )
        );
        return [boneHinge, ...children];
      },
      []
    );
    return boneHinges;
  }
  function getCommonEdge(a2, b2) {
    return a2.edges.find((aEdge) => b2.edges.some((bEdge) => aEdge.equals(bEdge, 1e-4)));
  }
  function getBoneIndexFromPoint(point, hingeBones) {
    return hingeBones.findIndex(
      (hingeBone) => hingeBone.verts.some(
        (vert) => vert.equals(point)
      )
    );
  }
  function hingesForFace(faceIndex, hinges) {
    return hinges.filter(
      (hinge) => hinge[0] == faceIndex || hinge[1] == faceIndex
    );
  }
  function hingeForFaces(a2, b2, hinges) {
    return hinges.find(
      (hinge) => hinge[0] == a2 && hinge[1] == b2 || hinge[1] == a2 && hinge[0] == b2
    );
  }
  function otherFaceIndex(currentFaceIndex, hinge) {
    if (currentFaceIndex == hinge[0]) return hinge[1];
    else return hinge[0];
  }
  function triangulateFace(face) {
    const verts = face.points;
    return verts.slice(1, verts.length - 1).map((vert, index) => {
      const a2 = new Point(verts[0].x, verts[0].y);
      const b2 = new Point(vert.x, vert.y);
      const c2 = new Point(verts[index + 2].x, verts[index + 2].y);
      return [a2, b2, c2];
    });
  }
  function mergePolys(polys) {
    const points = [];
    for (const poly of polys) {
      for (const point of poly.points) {
        if (points.every((p) => !p.equals(point))) points.push(point);
      }
    }
    return new Polygon(...points);
  }
  function setHingeBendAmount(hinge, amount) {
    const rotAngle = hinge.maxAngle * amount;
    hinge.bone.setRotationFromAxisAngle(hinge.axis, rotAngle);
  }

  // content/shared/components/binary-swipe/binary-swipe.pug
  var binary_swipe_default = '<div class="cards option"><h3></h3><div class="stack"></div></div><div class="cards main"><div class="stack"><slot></slot></div></div><div class="cards option"><h3></h3><div class="stack"></div></div>';

  // content/shared/components/binary-swipe/binary-swipe.ts
  var RESISTANCE = 18e4;
  var MIN_MOVE = 100;
  var colorClasses = [
    "c-red",
    "c-orange",
    "c-yellow",
    "c-lime",
    "c-green",
    "c-teal",
    "c-blue",
    "c-purple"
  ];
  function cardOffset(posn, start) {
    const change = posn.subtract(start);
    const angle = clamp(change.x * change.y / RESISTANCE, -0.4, 0.4);
    return [change.scale(1, 0.5), angle];
  }
  var BinarySwipe = class extends CustomElementView {
    ready() {
      const [$aStacks, $mainStack, $bStack] = this.$$(".stack");
      const [$aTitle, $bTitle] = this.$$("h3");
      $aTitle.text = this.attr("a-title");
      $bTitle.text = this.attr("b-title");
      const $cards = this.$$(".card").reverse().map(($c, index) => {
        if (colorClasses.every((color) => !$c.hasClass(color))) {
          $c.addClass(colorClasses[index % colorClasses.length]);
        }
        const $wrap = $N("div", { class: "card-wrap" }, $mainStack);
        $wrap.append($c);
        $wrap._data.solution = $c.attr("solution");
        $wrap._data.hint = $c.attr("hint") || "incorrect";
        $wrap._data.comment = $c.attr("comment") || "correct";
        $c.removeAttr("solution");
        $c.removeAttr("hint");
        $c.removeAttr("comment");
        return $wrap;
      });
      let $activeCard = $cards.pop();
      $activeCard.addClass("active");
      slide($mainStack, {
        start: () => {
          if (!$activeCard) return;
          $html.addClass("grabbing");
          $activeCard.addClass("dragging");
        },
        move: (currentPos, startPos) => {
          if (!$activeCard) return;
          $activeCard.setTransform(...cardOffset(currentPos, startPos));
          const dx = currentPos.subtract(startPos).x;
          if (Math.abs(dx) < MIN_MOVE) {
            $activeCard.removeClass("committed-left committed-right");
          } else {
            $activeCard.addClass(dx < 0 ? "committed-left" : "committed-right");
          }
        },
        end: (endPos, startPos) => __async(this, null, function* () {
          if (!$activeCard) return;
          $html.removeClass("grabbing");
          const solution = $activeCard._data.solution;
          const dx = endPos.subtract(startPos).x;
          const isCorrect = dx < 0 && solution === "a" || dx > 0 && solution === "b";
          const tooClose = Math.abs(dx) < MIN_MOVE;
          if (tooClose || !isCorrect) {
            if (!tooClose) this.trigger("incorrect", { hint: $activeCard._data.hint });
            $activeCard.removeClass("dragging committed-left committed-right");
            $activeCard.animate({ transform: "none" }, 300);
            return;
          }
          this.trigger("correct", $activeCard._data.comment);
          const $target = solution === "a" ? $aStacks : $bStack;
          let [posn, angle] = cardOffset(endPos, startPos);
          posn = posn.add($mainStack.topLeftPosition).subtract($target.topLeftPosition);
          $activeCard.setTransform(posn, angle);
          $target.append($activeCard);
          const deg = random_exports.uniform(-3, 3);
          $activeCard.animate({ transform: `rotate(${deg}deg)` }, 300).promise;
          $activeCard.removeClass("active dragging committed-left committed-right");
          $activeCard = $cards.pop();
          if ($activeCard) {
            $activeCard.addClass("active");
          } else {
            this.trigger("complete");
          }
        })
      });
    }
  };
  BinarySwipe = __decorateClass([
    register("x-binary-swipe", { template: binary_swipe_default })
  ], BinarySwipe);

  // content/polyhedra/components/polyhedron-data.ts
  var PolyhedronData = {
    // ---------------------------------------------------------------------------
    // Platonic Solids
    Tetrahedron: {
      vertex: [
        [0, 0, 1.732051],
        [1.632993, 0, -0.5773503],
        [-0.8164966, 1.414214, -0.5773503],
        [-0.8164966, -1.414214, -0.5773503]
      ],
      edge: [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]],
      face: [[0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]]
    },
    Cube: {
      vertex: [
        [0, 0, 1.224745],
        [1.154701, 0, 0.4082483],
        [-0.5773503, 1, 0.4082483],
        [-0.5773503, -1, 0.4082483],
        [0.5773503, 1, -0.4082483],
        [0.5773503, -1, -0.4082483],
        [-1.154701, 0, -0.4082483],
        [0, 0, -1.224745]
      ],
      edge: [
        [0, 1],
        [0, 2],
        [0, 3],
        [1, 4],
        [1, 5],
        [2, 4],
        [2, 6],
        [3, 5],
        [3, 6],
        [4, 7],
        [5, 7],
        [6, 7]
      ],
      face: [
        [0, 1, 4, 2],
        [0, 2, 6, 3],
        [0, 3, 5, 1],
        [1, 5, 7, 4],
        [2, 4, 7, 6],
        [3, 6, 7, 5]
      ]
    },
    Octahedron: {
      vertex: [
        [0, 0, 1.414214],
        [1.414214, 0, 0],
        [0, 1.414214, 0],
        [-1.414214, 0, 0],
        [0, -1.414214, 0],
        [0, 0, -1.414214]
      ],
      edge: [
        [0, 1],
        [0, 2],
        [0, 3],
        [0, 4],
        [1, 2],
        [1, 4],
        [1, 5],
        [2, 3],
        [2, 5],
        [3, 4],
        [3, 5],
        [4, 5]
      ],
      face: [
        [0, 1, 2],
        [0, 2, 3],
        [0, 3, 4],
        [0, 4, 1],
        [1, 4, 5],
        [1, 5, 2],
        [2, 5, 3],
        [3, 5, 4]
      ]
    },
    Dodecahedron: {
      vertex: [
        [0, 0, 1.070466],
        [0.7136442, 0, 0.7978784],
        [-0.3568221, 0.618034, 0.7978784],
        [-0.3568221, -0.618034, 0.7978784],
        [0.7978784, 0.618034, 0.3568221],
        [0.7978784, -0.618034, 0.3568221],
        [-0.9341724, 0.381966, 0.3568221],
        [0.1362939, 1, 0.3568221],
        [0.1362939, -1, 0.3568221],
        [-0.9341724, -0.381966, 0.3568221],
        [0.9341724, 0.381966, -0.3568221],
        [0.9341724, -0.381966, -0.3568221],
        [-0.7978784, 0.618034, -0.3568221],
        [-0.1362939, 1, -0.3568221],
        [-0.1362939, -1, -0.3568221],
        [-0.7978784, -0.618034, -0.3568221],
        [0.3568221, 0.618034, -0.7978784],
        [0.3568221, -0.618034, -0.7978784],
        [-0.7136442, 0, -0.7978784],
        [0, 0, -1.070466]
      ],
      edge: [
        [0, 1],
        [0, 2],
        [0, 3],
        [1, 4],
        [1, 5],
        [2, 6],
        [2, 7],
        [3, 8],
        [3, 9],
        [4, 7],
        [4, 10],
        [5, 8],
        [5, 11],
        [6, 9],
        [6, 12],
        [7, 13],
        [8, 14],
        [9, 15],
        [10, 11],
        [10, 16],
        [11, 17],
        [12, 13],
        [12, 18],
        [13, 16],
        [14, 15],
        [14, 17],
        [15, 18],
        [16, 19],
        [17, 19],
        [18, 19]
      ],
      face: [
        [0, 1, 4, 7, 2],
        [0, 2, 6, 9, 3],
        [0, 3, 8, 5, 1],
        [1, 5, 11, 10, 4],
        [2, 7, 13, 12, 6],
        [3, 9, 15, 14, 8],
        [4, 10, 16, 13, 7],
        [5, 8, 14, 17, 11],
        [6, 12, 18, 15, 9],
        [10, 11, 17, 19, 16],
        [12, 13, 16, 19, 18],
        [14, 15, 18, 19, 17]
      ]
    },
    Icosahedron: {
      vertex: [
        [0, 0, 1.175571],
        [1.051462, 0, 0.5257311],
        [0.3249197, 1, 0.5257311],
        [-0.8506508, 0.618034, 0.5257311],
        [-0.8506508, -0.618034, 0.5257311],
        [0.3249197, -1, 0.5257311],
        [0.8506508, 0.618034, -0.5257311],
        [0.8506508, -0.618034, -0.5257311],
        [-0.3249197, 1, -0.5257311],
        [-1.051462, 0, -0.5257311],
        [-0.3249197, -1, -0.5257311],
        [0, 0, -1.175571]
      ],
      edge: [
        [0, 1],
        [0, 2],
        [0, 3],
        [0, 4],
        [0, 5],
        [1, 2],
        [1, 5],
        [1, 6],
        [1, 7],
        [2, 3],
        [2, 6],
        [2, 8],
        [3, 4],
        [3, 8],
        [3, 9],
        [4, 5],
        [4, 9],
        [4, 10],
        [5, 7],
        [5, 10],
        [6, 7],
        [6, 8],
        [6, 11],
        [7, 10],
        [7, 11],
        [8, 9],
        [8, 11],
        [9, 10],
        [9, 11],
        [10, 11]
      ],
      face: [
        [0, 1, 2],
        [0, 2, 3],
        [0, 3, 4],
        [0, 4, 5],
        [0, 5, 1],
        [1, 5, 7],
        [1, 7, 6],
        [1, 6, 2],
        [2, 6, 8],
        [2, 8, 3],
        [3, 8, 9],
        [3, 9, 4],
        [4, 9, 10],
        [4, 10, 5],
        [5, 10, 7],
        [6, 7, 11],
        [6, 11, 8],
        [7, 10, 11],
        [8, 11, 9],
        [9, 11, 10]
      ]
    },
    // ---------------------------------------------------------------------------
    // Archimedean Solids
    TruncatedTetrahedron: {
      vertex: [
        [0, 0, 1.105542],
        [0.8528029, 0, 0.7035265],
        [-0.7106691, 0.4714045, 0.7035265],
        [0.3316456, -0.7856742, 0.7035265],
        [0.9949367, 0.4714045, -0.1005038],
        [-1.089693, 0.1571348, -0.1005038],
        [-0.5685352, 0.942809, -0.1005038],
        [-0.04737794, -1.099944, -0.1005038],
        [0.6159132, 0.1571348, -0.904534],
        [0.2842676, 0.942809, -0.5025189],
        [-0.758047, -0.6285394, -0.5025189],
        [0.09475587, -0.6285394, -0.904534]
      ],
      edge: [
        [0, 3],
        [3, 1],
        [1, 0],
        [2, 6],
        [6, 5],
        [5, 2],
        [4, 8],
        [8, 9],
        [9, 4],
        [7, 10],
        [10, 11],
        [11, 7],
        [1, 4],
        [9, 6],
        [2, 0],
        [5, 10],
        [7, 3],
        [11, 8]
      ],
      face: [
        [0, 3, 1],
        [2, 6, 5],
        [4, 8, 9],
        [7, 10, 11],
        [0, 1, 4, 9, 6, 2],
        [0, 2, 5, 10, 7, 3],
        [1, 3, 7, 11, 8, 4],
        [5, 6, 9, 8, 11, 10]
      ]
    },
    TruncatedCube: {
      vertex: [
        [0, 0, 1.042011],
        [0.5621693, 0, 0.8773552],
        [-0.4798415, 0.2928932, 0.8773552],
        [0.2569714, -0.5, 0.8773552],
        [0.8773552, 0.2928932, 0.4798415],
        [-0.9014684, 0.2071068, 0.4798415],
        [-0.5962706, 0.7071068, 0.4798415],
        [0.1405423, -0.9142136, 0.4798415],
        [1.017898, 0.2071068, -0.08232778],
        [0.7609261, 0.7071068, 0.08232778],
        [-1.017898, -0.2071068, 0.08232778],
        [-0.2810846, 1, 0.08232778],
        [-0.2810846, -1, 0.08232778],
        [0.2810846, -1, -0.08232778],
        [0.9014684, -0.2071068, -0.4798415],
        [0.2810846, 1, -0.08232778],
        [-0.7609261, -0.7071068, -0.08232778],
        [-0.8773552, -0.2928932, -0.4798415],
        [-0.1405423, 0.9142136, -0.4798415],
        [0.5962706, -0.7071068, -0.4798415],
        [0.4798415, -0.2928932, -0.8773552],
        [-0.5621693, 0, -0.8773552],
        [-0.2569714, 0.5, -0.8773552],
        [0, 0, -1.042011]
      ],
      edge: [
        [0, 3],
        [3, 1],
        [1, 0],
        [2, 6],
        [6, 5],
        [5, 2],
        [4, 8],
        [8, 9],
        [9, 4],
        [7, 12],
        [12, 13],
        [13, 7],
        [10, 17],
        [17, 16],
        [16, 10],
        [11, 15],
        [15, 18],
        [18, 11],
        [14, 19],
        [19, 20],
        [20, 14],
        [21, 22],
        [22, 23],
        [23, 21],
        [1, 4],
        [9, 15],
        [11, 6],
        [2, 0],
        [5, 10],
        [16, 12],
        [7, 3],
        [13, 19],
        [14, 8],
        [18, 22],
        [21, 17],
        [20, 23]
      ],
      face: [
        [0, 3, 1],
        [2, 6, 5],
        [4, 8, 9],
        [7, 12, 13],
        [10, 17, 16],
        [11, 15, 18],
        [14, 19, 20],
        [21, 22, 23],
        [0, 1, 4, 9, 15, 11, 6, 2],
        [0, 2, 5, 10, 16, 12, 7, 3],
        [1, 3, 7, 13, 19, 14, 8, 4],
        [5, 6, 11, 18, 22, 21, 17, 10],
        [8, 14, 20, 23, 22, 18, 15, 9],
        [12, 16, 17, 21, 23, 20, 19, 13]
      ]
    },
    TruncatedOctahedron: {
      vertex: [
        [0, 0, 1.054093],
        [0.6324555, 0, 0.843274],
        [-0.421637, 0.4714045, 0.843274],
        [-0.07027284, -0.6285394, 0.843274],
        [0.843274, 0.4714045, 0.421637],
        [0.5621827, -0.6285394, 0.6324555],
        [-0.9135469, 0.3142697, 0.421637],
        [-0.2108185, 0.942809, 0.421637],
        [-0.5621827, -0.7856742, 0.421637],
        [0.9838197, 0.3142697, -0.2108185],
        [0.421637, 0.942809, 0.2108185],
        [0.7027284, -0.7856742, 0],
        [-0.7027284, 0.7856742, 0],
        [-0.9838197, -0.3142697, 0.2108185],
        [-0.421637, -0.942809, -0.2108185],
        [0.5621827, 0.7856742, -0.421637],
        [0.9135469, -0.3142697, -0.421637],
        [0.2108185, -0.942809, -0.421637],
        [-0.5621827, 0.6285394, -0.6324555],
        [-0.843274, -0.4714045, -0.421637],
        [0.07027284, 0.6285394, -0.843274],
        [0.421637, -0.4714045, -0.843274],
        [-0.6324555, 0, -0.843274],
        [0, 0, -1.054093]
      ],
      edge: [
        [0, 3],
        [3, 5],
        [5, 1],
        [1, 0],
        [2, 7],
        [7, 12],
        [12, 6],
        [6, 2],
        [4, 9],
        [9, 15],
        [15, 10],
        [10, 4],
        [8, 13],
        [13, 19],
        [19, 14],
        [14, 8],
        [11, 17],
        [17, 21],
        [21, 16],
        [16, 11],
        [18, 20],
        [20, 23],
        [23, 22],
        [22, 18],
        [1, 4],
        [10, 7],
        [2, 0],
        [6, 13],
        [8, 3],
        [5, 11],
        [16, 9],
        [14, 17],
        [12, 18],
        [22, 19],
        [15, 20],
        [21, 23]
      ],
      face: [
        [0, 3, 5, 1],
        [2, 7, 12, 6],
        [4, 9, 15, 10],
        [8, 13, 19, 14],
        [11, 17, 21, 16],
        [18, 20, 23, 22],
        [0, 1, 4, 10, 7, 2],
        [0, 2, 6, 13, 8, 3],
        [1, 5, 11, 16, 9, 4],
        [3, 8, 14, 17, 11, 5],
        [6, 12, 18, 22, 19, 13],
        [7, 10, 15, 20, 18, 12],
        [9, 16, 21, 23, 20, 15],
        [14, 19, 22, 23, 21, 17]
      ]
    },
    TruncatedDodecahedron: {
      vertex: [
        [0, 0, 1.014485],
        [0.3367628, 0, 0.9569589],
        [-0.2902233, 0.1708204, 0.9569589],
        [0.1634681, -0.2944272, 0.9569589],
        [0.5914332, 0.1708204, 0.806354],
        [-0.5963465, 0.1527864, 0.806354],
        [-0.4230517, 0.4472136, 0.806354],
        [0.1377417, -0.6, 0.806354],
        [0.8302037, 0.1527864, 0.5626702],
        [0.6667356, 0.4472136, 0.6201961],
        [-0.8014407, -0.0472136, 0.6201961],
        [-0.3477493, 0.7236068, 0.6201961],
        [-0.06735256, -0.8, 0.6201961],
        [0.2694102, -0.8, 0.5626702],
        [0.9618722, -0.0472136, 0.3189863],
        [0.5339072, 0.7236068, 0.4695912],
        [-0.8271671, -0.3527864, 0.4695912],
        [-0.9599955, -0.0763932, 0.3189863],
        [-0.3992021, 0.8763932, 0.3189863],
        [-0.09307895, 0.8944272, 0.4695912],
        [-0.3734757, -0.818034, 0.4695912],
        [0.5081808, -0.818034, 0.3189863],
        [0.9361459, -0.3527864, 0.1683814],
        [1.011448, -0.0763932, -0.0177765],
        [0.4824544, 0.8763932, 0.1683814],
        [0.2436839, 0.8944272, 0.4120653],
        [-0.663699, -0.6472136, 0.4120653],
        [-1.011448, 0.0763932, 0.0177765],
        [-0.5577569, 0.8472136, 0.0177765],
        [-0.5320305, -0.8472136, 0.1683814],
        [0.5577569, -0.8472136, -0.0177765],
        [0.7628511, -0.6472136, 0.1683814],
        [0.9599955, 0.0763932, -0.3189863],
        [0.5320305, 0.8472136, -0.1683814],
        [-0.9618722, 0.0472136, -0.3189863],
        [-0.9361459, 0.3527864, -0.1683814],
        [-0.7628511, 0.6472136, -0.1683814],
        [-0.5081808, 0.818034, -0.3189863],
        [-0.4824544, -0.8763932, -0.1683814],
        [0.3992021, -0.8763932, -0.3189863],
        [0.8014407, 0.0472136, -0.6201961],
        [0.8271671, 0.3527864, -0.4695912],
        [0.663699, 0.6472136, -0.4120653],
        [0.3734757, 0.818034, -0.4695912],
        [-0.8302037, -0.1527864, -0.5626702],
        [-0.2694102, 0.8, -0.5626702],
        [-0.5339072, -0.7236068, -0.4695912],
        [-0.2436839, -0.8944272, -0.4120653],
        [0.09307895, -0.8944272, -0.4695912],
        [0.3477493, -0.7236068, -0.6201961],
        [0.5963465, -0.1527864, -0.806354],
        [0.06735256, 0.8, -0.6201961],
        [-0.6667356, -0.4472136, -0.6201961],
        [-0.5914332, -0.1708204, -0.806354],
        [-0.1377417, 0.6, -0.806354],
        [0.4230517, -0.4472136, -0.806354],
        [0.2902233, -0.1708204, -0.9569589],
        [-0.3367628, 0, -0.9569589],
        [-0.1634681, 0.2944272, -0.9569589],
        [0, 0, -1.014485]
      ],
      edge: [
        [0, 3],
        [3, 1],
        [1, 0],
        [2, 6],
        [6, 5],
        [5, 2],
        [4, 8],
        [8, 9],
        [9, 4],
        [7, 12],
        [12, 13],
        [13, 7],
        [10, 17],
        [17, 16],
        [16, 10],
        [11, 19],
        [19, 18],
        [18, 11],
        [14, 22],
        [22, 23],
        [23, 14],
        [15, 24],
        [24, 25],
        [25, 15],
        [20, 26],
        [26, 29],
        [29, 20],
        [21, 30],
        [30, 31],
        [31, 21],
        [27, 35],
        [35, 34],
        [34, 27],
        [28, 37],
        [37, 36],
        [36, 28],
        [32, 40],
        [40, 41],
        [41, 32],
        [33, 42],
        [42, 43],
        [43, 33],
        [38, 46],
        [46, 47],
        [47, 38],
        [39, 48],
        [48, 49],
        [49, 39],
        [44, 53],
        [53, 52],
        [52, 44],
        [45, 51],
        [51, 54],
        [54, 45],
        [50, 55],
        [55, 56],
        [56, 50],
        [57, 58],
        [58, 59],
        [59, 57],
        [1, 4],
        [9, 15],
        [25, 19],
        [11, 6],
        [2, 0],
        [5, 10],
        [16, 26],
        [20, 12],
        [7, 3],
        [13, 21],
        [31, 22],
        [14, 8],
        [18, 28],
        [36, 35],
        [27, 17],
        [23, 32],
        [41, 42],
        [33, 24],
        [29, 38],
        [47, 48],
        [39, 30],
        [34, 44],
        [52, 46],
        [43, 51],
        [45, 37],
        [49, 55],
        [50, 40],
        [54, 58],
        [57, 53],
        [56, 59]
      ],
      face: [
        [0, 3, 1],
        [2, 6, 5],
        [4, 8, 9],
        [7, 12, 13],
        [10, 17, 16],
        [11, 19, 18],
        [14, 22, 23],
        [15, 24, 25],
        [20, 26, 29],
        [21, 30, 31],
        [27, 35, 34],
        [28, 37, 36],
        [32, 40, 41],
        [33, 42, 43],
        [38, 46, 47],
        [39, 48, 49],
        [44, 53, 52],
        [45, 51, 54],
        [50, 55, 56],
        [57, 58, 59],
        [0, 1, 4, 9, 15, 25, 19, 11, 6, 2],
        [0, 2, 5, 10, 16, 26, 20, 12, 7, 3],
        [1, 3, 7, 13, 21, 31, 22, 14, 8, 4],
        [5, 6, 11, 18, 28, 36, 35, 27, 17, 10],
        [8, 14, 23, 32, 41, 42, 33, 24, 15, 9],
        [12, 20, 29, 38, 47, 48, 39, 30, 21, 13],
        [16, 17, 27, 34, 44, 52, 46, 38, 29, 26],
        [18, 19, 25, 24, 33, 43, 51, 45, 37, 28],
        [22, 31, 30, 39, 49, 55, 50, 40, 32, 23],
        [34, 35, 36, 37, 45, 54, 58, 57, 53, 44],
        [40, 50, 56, 59, 58, 54, 51, 43, 42, 41],
        [46, 52, 53, 57, 59, 56, 55, 49, 48, 47]
      ]
    },
    TruncatedIcosahedron: {
      vertex: [
        [0, 0, 1.021],
        [0.4035482, 0, 0.9378643],
        [-0.2274644, 0.3333333, 0.9378643],
        [-0.1471226, -0.375774, 0.9378643],
        [0.579632, 0.3333333, 0.7715933],
        [0.5058321, -0.375774, 0.8033483],
        [-0.6020514, 0.2908927, 0.7715933],
        [-0.05138057, 0.6666667, 0.7715933],
        [0.1654988, -0.6080151, 0.8033483],
        [-0.5217096, -0.4182147, 0.7715933],
        [0.8579998, 0.2908927, 0.4708062],
        [0.3521676, 0.6666667, 0.6884578],
        [0.7841999, -0.4182147, 0.5025612],
        [-0.657475, 0.5979962, 0.5025612],
        [-0.749174, -0.08488134, 0.6884578],
        [-0.3171418, 0.8302373, 0.5025612],
        [0.1035333, -0.8826969, 0.5025612],
        [-0.5836751, -0.6928964, 0.4708062],
        [0.8025761, 0.5979962, 0.2017741],
        [0.9602837, -0.08488134, 0.3362902],
        [0.4899547, 0.8302373, 0.3362902],
        [0.7222343, -0.6928964, 0.2017741],
        [-0.8600213, 0.5293258, 0.1503935],
        [-0.9517203, -0.1535518, 0.3362902],
        [-0.1793548, 0.993808, 0.1503935],
        [0.381901, -0.9251375, 0.2017741],
        [-0.2710537, -0.9251375, 0.3362902],
        [-0.8494363, -0.5293258, 0.2017741],
        [0.8494363, 0.5293258, -0.2017741],
        [1.007144, -0.1535518, -0.06725804],
        [0.2241935, 0.993808, 0.06725804],
        [0.8600213, -0.5293258, -0.1503935],
        [-0.7222343, 0.6928964, -0.2017741],
        [-1.007144, 0.1535518, 0.06725804],
        [-0.381901, 0.9251375, -0.2017741],
        [0.1793548, -0.993808, -0.1503935],
        [-0.2241935, -0.993808, -0.06725804],
        [-0.8025761, -0.5979962, -0.2017741],
        [0.5836751, 0.6928964, -0.4708062],
        [0.9517203, 0.1535518, -0.3362902],
        [0.2710537, 0.9251375, -0.3362902],
        [0.657475, -0.5979962, -0.5025612],
        [-0.7841999, 0.4182147, -0.5025612],
        [-0.9602837, 0.08488134, -0.3362902],
        [-0.1035333, 0.8826969, -0.5025612],
        [0.3171418, -0.8302373, -0.5025612],
        [-0.4899547, -0.8302373, -0.3362902],
        [-0.8579998, -0.2908927, -0.4708062],
        [0.5217096, 0.4182147, -0.7715933],
        [0.749174, 0.08488134, -0.6884578],
        [0.6020514, -0.2908927, -0.7715933],
        [-0.5058321, 0.375774, -0.8033483],
        [-0.1654988, 0.6080151, -0.8033483],
        [0.05138057, -0.6666667, -0.7715933],
        [-0.3521676, -0.6666667, -0.6884578],
        [-0.579632, -0.3333333, -0.7715933],
        [0.1471226, 0.375774, -0.9378643],
        [0.2274644, -0.3333333, -0.9378643],
        [-0.4035482, 0, -0.9378643],
        [0, 0, -1.021]
      ],
      edge: [
        [0, 3],
        [3, 8],
        [8, 5],
        [5, 1],
        [1, 0],
        [2, 7],
        [7, 15],
        [15, 13],
        [13, 6],
        [6, 2],
        [4, 10],
        [10, 18],
        [18, 20],
        [20, 11],
        [11, 4],
        [9, 14],
        [14, 23],
        [23, 27],
        [27, 17],
        [17, 9],
        [12, 21],
        [21, 31],
        [31, 29],
        [29, 19],
        [19, 12],
        [16, 26],
        [26, 36],
        [36, 35],
        [35, 25],
        [25, 16],
        [22, 32],
        [32, 42],
        [42, 43],
        [43, 33],
        [33, 22],
        [24, 30],
        [30, 40],
        [40, 44],
        [44, 34],
        [34, 24],
        [28, 39],
        [39, 49],
        [49, 48],
        [48, 38],
        [38, 28],
        [37, 47],
        [47, 55],
        [55, 54],
        [54, 46],
        [46, 37],
        [41, 45],
        [45, 53],
        [53, 57],
        [57, 50],
        [50, 41],
        [51, 52],
        [52, 56],
        [56, 59],
        [59, 58],
        [58, 51],
        [1, 4],
        [11, 7],
        [2, 0],
        [6, 14],
        [9, 3],
        [5, 12],
        [19, 10],
        [17, 26],
        [16, 8],
        [25, 21],
        [13, 22],
        [33, 23],
        [20, 30],
        [24, 15],
        [29, 39],
        [28, 18],
        [34, 32],
        [27, 37],
        [46, 36],
        [38, 40],
        [35, 45],
        [41, 31],
        [43, 47],
        [50, 49],
        [44, 52],
        [51, 42],
        [54, 53],
        [48, 56],
        [58, 55],
        [57, 59]
      ],
      face: [
        [0, 3, 8, 5, 1],
        [2, 7, 15, 13, 6],
        [4, 10, 18, 20, 11],
        [9, 14, 23, 27, 17],
        [12, 21, 31, 29, 19],
        [16, 26, 36, 35, 25],
        [22, 32, 42, 43, 33],
        [24, 30, 40, 44, 34],
        [28, 39, 49, 48, 38],
        [37, 47, 55, 54, 46],
        [41, 45, 53, 57, 50],
        [51, 52, 56, 59, 58],
        [0, 1, 4, 11, 7, 2],
        [0, 2, 6, 14, 9, 3],
        [1, 5, 12, 19, 10, 4],
        [3, 9, 17, 26, 16, 8],
        [5, 8, 16, 25, 21, 12],
        [6, 13, 22, 33, 23, 14],
        [7, 11, 20, 30, 24, 15],
        [10, 19, 29, 39, 28, 18],
        [13, 15, 24, 34, 32, 22],
        [17, 27, 37, 46, 36, 26],
        [18, 28, 38, 40, 30, 20],
        [21, 25, 35, 45, 41, 31],
        [23, 33, 43, 47, 37, 27],
        [29, 31, 41, 50, 49, 39],
        [32, 34, 44, 52, 51, 42],
        [35, 36, 46, 54, 53, 45],
        [38, 48, 56, 52, 44, 40],
        [42, 51, 58, 55, 47, 43],
        [48, 49, 50, 57, 59, 56],
        [53, 54, 55, 58, 59, 57]
      ]
    },
    Cuboctahedron: {
      vertex: [
        [0, 0, 1.154701],
        [1, 0, 0.5773503],
        [0.3333333, 0.942809, 0.5773503],
        [-1, 0, 0.5773503],
        [-0.3333333, -0.942809, 0.5773503],
        [1, 0, -0.5773503],
        [0.6666667, -0.942809, 0],
        [-0.6666667, 0.942809, 0],
        [0.3333333, 0.942809, -0.5773503],
        [-1, 0, -0.5773503],
        [-0.3333333, -0.942809, -0.5773503],
        [0, 0, -1.154701]
      ],
      edge: [
        [0, 1],
        [1, 2],
        [2, 0],
        [0, 3],
        [3, 4],
        [4, 0],
        [1, 6],
        [6, 5],
        [5, 1],
        [2, 8],
        [8, 7],
        [7, 2],
        [3, 7],
        [7, 9],
        [9, 3],
        [4, 10],
        [10, 6],
        [6, 4],
        [5, 11],
        [11, 8],
        [8, 5],
        [9, 11],
        [11, 10],
        [10, 9]
      ],
      face: [
        [0, 1, 2],
        [0, 3, 4],
        [1, 6, 5],
        [2, 8, 7],
        [3, 7, 9],
        [4, 10, 6],
        [5, 11, 8],
        [9, 11, 10],
        [0, 2, 7, 3],
        [0, 4, 6, 1],
        [1, 5, 8, 2],
        [3, 9, 10, 4],
        [5, 6, 10, 11],
        [7, 8, 11, 9]
      ]
    },
    TruncatedCuboctahedron: {
      vertex: [
        [0, 0, 1.024117],
        [0.4314788, 0, 0.928785],
        [-0.02106287, 0.4309644, 0.928785],
        [-0.3410582, -0.2642977, 0.928785],
        [0.4104159, 0.4309644, 0.833453],
        [0.7006238, -0.2642977, 0.6986333],
        [-0.3831839, 0.5976311, 0.7381211],
        [-0.3919084, -0.6380712, 0.6986333],
        [-0.7031792, -0.09763107, 0.7381211],
        [0.6584981, 0.5976311, 0.5079694],
        [0.6497736, -0.6380712, 0.4684816],
        [0.948706, -0.09763107, 0.3731496],
        [-0.4638216, 0.8333333, 0.3731496],
        [-0.7242421, 0.3333333, 0.6427891],
        [-0.7540295, -0.4714045, 0.5079694],
        [-0.1227634, -0.9023689, 0.4684816],
        [0.5778604, 0.8333333, 0.1429979],
        [0.9276431, 0.3333333, 0.2778177],
        [0.8978557, -0.4714045, 0.1429979],
        [0.3087154, -0.9023689, 0.3731496],
        [-0.8048797, 0.5690356, 0.2778177],
        [-0.2157394, 1, 0.04766598],
        [-0.8470055, -0.5690356, 0.08715377],
        [-0.2157394, -1, 0.04766598],
        [0.8470055, 0.5690356, -0.08715377],
        [0.2157394, 1, -0.04766598],
        [0.8048797, -0.5690356, -0.2778177],
        [0.2157394, -1, -0.04766598],
        [-0.8978557, 0.4714045, -0.1429979],
        [-0.3087154, 0.9023689, -0.3731496],
        [-0.9276431, -0.3333333, -0.2778177],
        [-0.5778604, -0.8333333, -0.1429979],
        [0.7540295, 0.4714045, -0.5079694],
        [0.1227634, 0.9023689, -0.4684816],
        [0.7242421, -0.3333333, -0.6427891],
        [0.4638216, -0.8333333, -0.3731496],
        [-0.948706, 0.09763107, -0.3731496],
        [-0.6497736, 0.6380712, -0.4684816],
        [-0.6584981, -0.5976311, -0.5079694],
        [0.7031792, 0.09763107, -0.7381211],
        [0.3919084, 0.6380712, -0.6986333],
        [0.3831839, -0.5976311, -0.7381211],
        [-0.7006238, 0.2642977, -0.6986333],
        [-0.4104159, -0.4309644, -0.833453],
        [0.3410582, 0.2642977, -0.928785],
        [0.02106287, -0.4309644, -0.928785],
        [-0.4314788, 0, -0.928785],
        [0, 0, -1.024117]
      ],
      edge: [
        [0, 1],
        [1, 4],
        [4, 2],
        [2, 0],
        [3, 8],
        [8, 14],
        [14, 7],
        [7, 3],
        [5, 10],
        [10, 18],
        [18, 11],
        [11, 5],
        [6, 12],
        [12, 20],
        [20, 13],
        [13, 6],
        [9, 17],
        [17, 24],
        [24, 16],
        [16, 9],
        [15, 23],
        [23, 27],
        [27, 19],
        [19, 15],
        [21, 25],
        [25, 33],
        [33, 29],
        [29, 21],
        [22, 30],
        [30, 38],
        [38, 31],
        [31, 22],
        [26, 35],
        [35, 41],
        [41, 34],
        [34, 26],
        [28, 37],
        [37, 42],
        [42, 36],
        [36, 28],
        [32, 39],
        [39, 44],
        [44, 40],
        [40, 32],
        [43, 46],
        [46, 47],
        [47, 45],
        [45, 43],
        [2, 6],
        [13, 8],
        [3, 0],
        [1, 5],
        [11, 17],
        [9, 4],
        [14, 22],
        [31, 23],
        [15, 7],
        [10, 19],
        [27, 35],
        [26, 18],
        [12, 21],
        [29, 37],
        [28, 20],
        [24, 32],
        [40, 33],
        [25, 16],
        [30, 36],
        [42, 46],
        [43, 38],
        [41, 45],
        [47, 44],
        [39, 34]
      ],
      face: [
        [0, 1, 4, 2],
        [3, 8, 14, 7],
        [5, 10, 18, 11],
        [6, 12, 20, 13],
        [9, 17, 24, 16],
        [15, 23, 27, 19],
        [21, 25, 33, 29],
        [22, 30, 38, 31],
        [26, 35, 41, 34],
        [28, 37, 42, 36],
        [32, 39, 44, 40],
        [43, 46, 47, 45],
        [0, 2, 6, 13, 8, 3],
        [1, 5, 11, 17, 9, 4],
        [7, 14, 22, 31, 23, 15],
        [10, 19, 27, 35, 26, 18],
        [12, 21, 29, 37, 28, 20],
        [16, 24, 32, 40, 33, 25],
        [30, 36, 42, 46, 43, 38],
        [34, 41, 45, 47, 44, 39],
        [0, 3, 7, 15, 19, 10, 5, 1],
        [2, 4, 9, 16, 25, 21, 12, 6],
        [8, 13, 20, 28, 36, 30, 22, 14],
        [11, 18, 26, 34, 39, 32, 24, 17],
        [23, 31, 38, 43, 45, 41, 35, 27],
        [29, 33, 40, 44, 47, 46, 42, 37]
      ]
    },
    Rhombicuboctahedron: {
      vertex: [
        [0, 0, 1.070722],
        [0.7148135, 0, 0.7971752],
        [-0.104682, 0.7071068, 0.7971752],
        [-0.6841528, 0.2071068, 0.7971752],
        [-0.104682, -0.7071068, 0.7971752],
        [0.6101315, 0.7071068, 0.5236279],
        [1.04156, 0.2071068, 0.1367736],
        [0.6101315, -0.7071068, 0.5236279],
        [-0.3574067, 1, 0.1367736],
        [-0.7888348, -0.5, 0.5236279],
        [-0.9368776, 0.5, 0.1367736],
        [-0.3574067, -1, 0.1367736],
        [0.3574067, 1, -0.1367736],
        [0.9368776, -0.5, -0.1367736],
        [0.7888348, 0.5, -0.5236279],
        [0.3574067, -1, -0.1367736],
        [-0.6101315, 0.7071068, -0.5236279],
        [-1.04156, -0.2071068, -0.1367736],
        [-0.6101315, -0.7071068, -0.5236279],
        [0.104682, 0.7071068, -0.7971752],
        [0.6841528, -0.2071068, -0.7971752],
        [0.104682, -0.7071068, -0.7971752],
        [-0.7148135, 0, -0.7971752],
        [0, 0, -1.070722]
      ],
      edge: [
        [0, 2],
        [2, 3],
        [3, 0],
        [1, 6],
        [6, 5],
        [5, 1],
        [4, 9],
        [9, 11],
        [11, 4],
        [7, 15],
        [15, 13],
        [13, 7],
        [8, 16],
        [16, 10],
        [10, 8],
        [12, 14],
        [14, 19],
        [19, 12],
        [17, 22],
        [22, 18],
        [18, 17],
        [20, 21],
        [21, 23],
        [23, 20],
        [0, 1],
        [5, 2],
        [3, 9],
        [4, 0],
        [4, 7],
        [7, 1],
        [13, 6],
        [5, 12],
        [12, 8],
        [8, 2],
        [10, 3],
        [10, 17],
        [17, 9],
        [11, 15],
        [6, 14],
        [13, 20],
        [20, 14],
        [19, 16],
        [18, 11],
        [16, 22],
        [18, 21],
        [21, 15],
        [23, 19],
        [23, 22]
      ],
      face: [
        [0, 2, 3],
        [1, 6, 5],
        [4, 9, 11],
        [7, 15, 13],
        [8, 16, 10],
        [12, 14, 19],
        [17, 22, 18],
        [20, 21, 23],
        [0, 1, 5, 2],
        [0, 3, 9, 4],
        [0, 4, 7, 1],
        [1, 7, 13, 6],
        [2, 5, 12, 8],
        [2, 8, 10, 3],
        [3, 10, 17, 9],
        [4, 11, 15, 7],
        [5, 6, 14, 12],
        [6, 13, 20, 14],
        [8, 12, 19, 16],
        [9, 17, 18, 11],
        [10, 16, 22, 17],
        [11, 18, 21, 15],
        [13, 15, 21, 20],
        [14, 20, 23, 19],
        [16, 19, 23, 22],
        [18, 22, 23, 21]
      ]
    },
    SnubCube: {
      vertex: [
        [0, 0, 1.077364],
        [0.7442063, 0, 0.7790187],
        [0.3123013, 0.6755079, 0.7790187],
        [-0.482096, 0.5669449, 0.7790187],
        [-0.7169181, -0.1996786, 0.7790187],
        [-0.1196038, -0.7345325, 0.7790187],
        [0.6246025, -0.7345325, 0.4806734],
        [1.056508, -0.1996786, 0.06806912],
        [0.8867128, 0.5669449, 0.2302762],
        [0.2621103, 1.042774, 0.06806912],
        [-0.532287, 0.9342111, 0.06806912],
        [-1.006317, 0.3082417, 0.2302762],
        [-0.7020817, -0.784071, 0.2302762],
        [0.02728827, -1.074865, 0.06806912],
        [0.6667271, -0.784071, -0.3184664],
        [0.8216855, -0.09111555, -0.6908285],
        [0.6518908, 0.6755079, -0.5286215],
        [-0.1196038, 0.8751866, -0.6168117],
        [-0.8092336, 0.4758293, -0.5286215],
        [-0.9914803, -0.2761507, -0.3184664],
        [-0.4467414, -0.825648, -0.5286215],
        [0.1926974, -0.5348539, -0.915157],
        [0.1846311, 0.2587032, -1.029416],
        [-0.5049987, -0.1406541, -0.9412258]
      ],
      edge: [
        [0, 1],
        [1, 2],
        [2, 0],
        [2, 3],
        [3, 0],
        [3, 4],
        [4, 0],
        [4, 5],
        [5, 0],
        [1, 6],
        [6, 7],
        [7, 1],
        [7, 8],
        [8, 1],
        [8, 2],
        [8, 9],
        [9, 2],
        [3, 10],
        [10, 11],
        [11, 3],
        [11, 4],
        [4, 12],
        [12, 5],
        [12, 13],
        [13, 5],
        [13, 6],
        [6, 5],
        [13, 14],
        [14, 6],
        [14, 7],
        [14, 15],
        [15, 7],
        [8, 16],
        [16, 9],
        [16, 17],
        [17, 9],
        [17, 10],
        [10, 9],
        [17, 18],
        [18, 10],
        [18, 11],
        [18, 19],
        [19, 11],
        [12, 19],
        [19, 20],
        [20, 12],
        [20, 13],
        [14, 21],
        [21, 15],
        [21, 22],
        [22, 15],
        [22, 16],
        [16, 15],
        [22, 17],
        [18, 23],
        [23, 19],
        [23, 20],
        [23, 21],
        [21, 20],
        [23, 22]
      ],
      face: [
        [0, 1, 2],
        [0, 2, 3],
        [0, 3, 4],
        [0, 4, 5],
        [1, 6, 7],
        [1, 7, 8],
        [1, 8, 2],
        [2, 8, 9],
        [3, 10, 11],
        [3, 11, 4],
        [4, 12, 5],
        [5, 12, 13],
        [5, 13, 6],
        [6, 13, 14],
        [6, 14, 7],
        [7, 14, 15],
        [8, 16, 9],
        [9, 16, 17],
        [9, 17, 10],
        [10, 17, 18],
        [10, 18, 11],
        [11, 18, 19],
        [12, 19, 20],
        [12, 20, 13],
        [14, 21, 15],
        [15, 21, 22],
        [15, 22, 16],
        [16, 22, 17],
        [18, 23, 19],
        [19, 23, 20],
        [20, 23, 21],
        [21, 23, 22],
        [0, 5, 6, 1],
        [2, 9, 10, 3],
        [4, 11, 19, 12],
        [7, 15, 16, 8],
        [13, 20, 21, 14],
        [17, 22, 23, 18]
      ]
    },
    Icosidodecahedron: {
      vertex: [
        [0, 0, 1.051462],
        [0.618034, 0, 0.8506508],
        [0.2763932, 0.5527864, 0.8506508],
        [-0.618034, 0, 0.8506508],
        [-0.2763932, -0.5527864, 0.8506508],
        [1, 0, 0.3249197],
        [0.7236068, -0.5527864, 0.5257311],
        [-0.1708204, 0.8944272, 0.5257311],
        [0.4472136, 0.8944272, 0.3249197],
        [-1, 0, 0.3249197],
        [-0.7236068, 0.5527864, 0.5257311],
        [0.1708204, -0.8944272, 0.5257311],
        [-0.4472136, -0.8944272, 0.3249197],
        [1, 0, -0.3249197],
        [0.8944272, 0.5527864, 0],
        [0.5527864, -0.8944272, 0],
        [-0.5527864, 0.8944272, 0],
        [0.4472136, 0.8944272, -0.3249197],
        [-1, 0, -0.3249197],
        [-0.8944272, -0.5527864, 0],
        [-0.4472136, -0.8944272, -0.3249197],
        [0.618034, 0, -0.8506508],
        [0.7236068, -0.5527864, -0.5257311],
        [0.1708204, -0.8944272, -0.5257311],
        [-0.7236068, 0.5527864, -0.5257311],
        [-0.1708204, 0.8944272, -0.5257311],
        [0.2763932, 0.5527864, -0.8506508],
        [-0.618034, 0, -0.8506508],
        [-0.2763932, -0.5527864, -0.8506508],
        [0, 0, -1.051462]
      ],
      edge: [
        [0, 1],
        [1, 2],
        [2, 0],
        [0, 3],
        [3, 4],
        [4, 0],
        [1, 6],
        [6, 5],
        [5, 1],
        [2, 8],
        [8, 7],
        [7, 2],
        [3, 10],
        [10, 9],
        [9, 3],
        [4, 12],
        [12, 11],
        [11, 4],
        [5, 13],
        [13, 14],
        [14, 5],
        [6, 11],
        [11, 15],
        [15, 6],
        [7, 16],
        [16, 10],
        [10, 7],
        [8, 14],
        [14, 17],
        [17, 8],
        [9, 18],
        [18, 19],
        [19, 9],
        [12, 19],
        [19, 20],
        [20, 12],
        [13, 22],
        [22, 21],
        [21, 13],
        [15, 23],
        [23, 22],
        [22, 15],
        [16, 25],
        [25, 24],
        [24, 16],
        [17, 26],
        [26, 25],
        [25, 17],
        [18, 24],
        [24, 27],
        [27, 18],
        [20, 28],
        [28, 23],
        [23, 20],
        [21, 29],
        [29, 26],
        [26, 21],
        [27, 29],
        [29, 28],
        [28, 27]
      ],
      face: [
        [0, 1, 2],
        [0, 3, 4],
        [1, 6, 5],
        [2, 8, 7],
        [3, 10, 9],
        [4, 12, 11],
        [5, 13, 14],
        [6, 11, 15],
        [7, 16, 10],
        [8, 14, 17],
        [9, 18, 19],
        [12, 19, 20],
        [13, 22, 21],
        [15, 23, 22],
        [16, 25, 24],
        [17, 26, 25],
        [18, 24, 27],
        [20, 28, 23],
        [21, 29, 26],
        [27, 29, 28],
        [0, 2, 7, 10, 3],
        [0, 4, 11, 6, 1],
        [1, 5, 14, 8, 2],
        [3, 9, 19, 12, 4],
        [5, 6, 15, 22, 13],
        [7, 8, 17, 25, 16],
        [9, 10, 16, 24, 18],
        [11, 12, 20, 23, 15],
        [13, 21, 26, 17, 14],
        [18, 27, 28, 20, 19],
        [21, 22, 23, 28, 29],
        [24, 25, 26, 29, 27]
      ]
    },
    TruncatedIcosidodecahedron: {
      vertex: [
        [0, 0, 1.008759],
        [0.2629922, 0, 0.973874],
        [-462747e-8, 0.2629515, 0.973874],
        [-0.2211363, -0.1423503, 0.973874],
        [0.2583647, 0.2629515, 0.9389886],
        [0.4673861, -0.1423503, 0.8825429],
        [-0.2303913, 0.3835526, 0.9041033],
        [-0.3159502, -0.372678, 0.8825429],
        [-0.4469001, -0.02174919, 0.9041033],
        [0.4581312, 0.3835526, 0.8127722],
        [0.5351104, -0.372678, 0.7696515],
        [0.6671526, -0.02174919, 0.7563265],
        [-0.3326926, 0.5786893, 0.7563265],
        [-0.4515276, 0.2412023, 0.8692179],
        [-0.541714, -0.2520769, 0.8127722],
        [-0.248226, -0.6030057, 0.7696515],
        [0.518368, 0.5786893, 0.6434351],
        [0.6625252, 0.2412023, 0.7214412],
        [0.7348768, -0.2520769, 0.6434351],
        [0.4402965, -0.6030057, 0.6783205],
        [-0.5538289, 0.436339, 0.7214412],
        [-0.2724557, 0.7738261, 0.5869894],
        [-0.6997536, -0.3618034, 0.6301101],
        [-0.04383203, -0.745356, 0.6783205],
        [-0.4062656, -0.7127322, 0.5869894],
        [0.722762, 0.436339, 0.552104],
        [0.4160667, 0.7738261, 0.4956583],
        [0.8398294, -0.3618034, 0.4258876],
        [0.2191601, -0.745356, 0.6434351],
        [0.5452491, -0.7127322, 0.460773],
        [-0.7147284, 0.4891254, 0.5172187],
        [-0.07268925, 0.8944272, 0.460773],
        [-0.4333553, 0.8266125, 0.3827669],
        [-0.8606531, -0.309017, 0.4258876],
        [-0.6320294, -0.5921311, 0.5172187],
        [-0.2018716, -0.8550825, 0.4956583],
        [0.8248546, 0.4891254, 0.3129962],
        [0.1903029, 0.8944272, 0.4258876],
        [0.5181594, 0.8266125, 0.2565505],
        [0.9419221, -0.309017, 0.1867798],
        [0.7450156, -0.5921311, 0.3345566],
        [0.3241127, -0.8550825, 0.4258876],
        [-0.8727679, 0.3793989, 0.3345566],
        [-0.6544916, 0.6842621, 0.3478816],
        [-0.2335888, 0.9472136, 0.2565505],
        [-0.7929289, -0.5393447, 0.3129962],
        [-0.9629544, -0.1138803, 0.2781109],
        [-0.096919, -0.9648091, 0.2781109],
        [0.9298072, 0.3793989, 0.09544872],
        [0.7225533, 0.6842621, 0.1652194],
        [0.2923956, 0.9472136, 0.1867798],
        [0.8471082, -0.5393447, 0.09544872],
        [1.002159, -0.1138803, 0.01744268],
        [0.1660732, -0.9648091, 0.2432255],
        [-0.8125311, 0.5745356, 0.1652194],
        [-0.9675818, 0.1490712, 0.2432255],
        [-0.1314961, 1, 0.01744268],
        [-0.8275059, -0.5745356, 0.05232804],
        [-0.9975315, -0.1490712, 0.01744268],
        [-0.1314961, -1, 0.01744268],
        [0.8275059, 0.5745356, -0.05232804],
        [0.9975315, 0.1490712, -0.01744268],
        [0.1314961, 1, -0.01744268],
        [0.8125311, -0.5745356, -0.1652194],
        [0.9675818, -0.1490712, -0.2432255],
        [0.1314961, -1, -0.01744268],
        [-0.8471082, 0.5393447, -0.09544872],
        [-1.002159, 0.1138803, -0.01744268],
        [-0.1660732, 0.9648091, -0.2432255],
        [-0.7225533, -0.6842621, -0.1652194],
        [-0.9298072, -0.3793989, -0.09544872],
        [-0.2923956, -0.9472136, -0.1867798],
        [0.7929289, 0.5393447, -0.3129962],
        [0.9629544, 0.1138803, -0.2781109],
        [0.096919, 0.9648091, -0.2781109],
        [0.6544916, -0.6842621, -0.3478816],
        [0.8727679, -0.3793989, -0.3345566],
        [0.2335888, -0.9472136, -0.2565505],
        [-0.7450156, 0.5921311, -0.3345566],
        [-0.9419221, 0.309017, -0.1867798],
        [-0.3241127, 0.8550825, -0.4258876],
        [-0.8248546, -0.4891254, -0.3129962],
        [-0.5181594, -0.8266125, -0.2565505],
        [-0.1903029, -0.8944272, -0.4258876],
        [0.6320294, 0.5921311, -0.5172187],
        [0.8606531, 0.309017, -0.4258876],
        [0.2018716, 0.8550825, -0.4956583],
        [0.7147284, -0.4891254, -0.5172187],
        [0.4333553, -0.8266125, -0.3827669],
        [0.07268925, -0.8944272, -0.460773],
        [-0.8398294, 0.3618034, -0.4258876],
        [-0.5452491, 0.7127322, -0.460773],
        [-0.2191601, 0.745356, -0.6434351],
        [-0.722762, -0.436339, -0.552104],
        [-0.4160667, -0.7738261, -0.4956583],
        [0.6997536, 0.3618034, -0.6301101],
        [0.4062656, 0.7127322, -0.5869894],
        [0.04383203, 0.745356, -0.6783205],
        [0.5538289, -0.436339, -0.7214412],
        [0.2724557, -0.7738261, -0.5869894],
        [-0.7348768, 0.2520769, -0.6434351],
        [-0.4402965, 0.6030057, -0.6783205],
        [-0.6625252, -0.2412023, -0.7214412],
        [-0.518368, -0.5786893, -0.6434351],
        [0.541714, 0.2520769, -0.8127722],
        [0.248226, 0.6030057, -0.7696515],
        [0.4515276, -0.2412023, -0.8692179],
        [0.3326926, -0.5786893, -0.7563265],
        [-0.6671526, 0.02174919, -0.7563265],
        [-0.5351104, 0.372678, -0.7696515],
        [-0.4581312, -0.3835526, -0.8127722],
        [0.4469001, 0.02174919, -0.9041033],
        [0.3159502, 0.372678, -0.8825429],
        [0.2303913, -0.3835526, -0.9041033],
        [-0.4673861, 0.1423503, -0.8825429],
        [-0.2583647, -0.2629515, -0.9389886],
        [0.2211363, 0.1423503, -0.973874],
        [462747e-8, -0.2629515, -0.973874],
        [-0.2629922, 0, -0.973874],
        [0, 0, -1.008759]
      ],
      edge: [
        [0, 1],
        [1, 4],
        [4, 2],
        [2, 0],
        [3, 8],
        [8, 14],
        [14, 7],
        [7, 3],
        [5, 10],
        [10, 18],
        [18, 11],
        [11, 5],
        [6, 12],
        [12, 20],
        [20, 13],
        [13, 6],
        [9, 17],
        [17, 25],
        [25, 16],
        [16, 9],
        [15, 24],
        [24, 35],
        [35, 23],
        [23, 15],
        [19, 28],
        [28, 41],
        [41, 29],
        [29, 19],
        [21, 31],
        [31, 44],
        [44, 32],
        [32, 21],
        [22, 33],
        [33, 45],
        [45, 34],
        [34, 22],
        [26, 38],
        [38, 50],
        [50, 37],
        [37, 26],
        [27, 40],
        [40, 51],
        [51, 39],
        [39, 27],
        [30, 43],
        [43, 54],
        [54, 42],
        [42, 30],
        [36, 48],
        [48, 60],
        [60, 49],
        [49, 36],
        [46, 55],
        [55, 67],
        [67, 58],
        [58, 46],
        [47, 59],
        [59, 65],
        [65, 53],
        [53, 47],
        [52, 64],
        [64, 73],
        [73, 61],
        [61, 52],
        [56, 62],
        [62, 74],
        [74, 68],
        [68, 56],
        [57, 70],
        [70, 81],
        [81, 69],
        [69, 57],
        [63, 75],
        [75, 87],
        [87, 76],
        [76, 63],
        [66, 78],
        [78, 90],
        [90, 79],
        [79, 66],
        [71, 82],
        [82, 94],
        [94, 83],
        [83, 71],
        [72, 85],
        [85, 95],
        [95, 84],
        [84, 72],
        [77, 89],
        [89, 99],
        [99, 88],
        [88, 77],
        [80, 92],
        [92, 101],
        [101, 91],
        [91, 80],
        [86, 96],
        [96, 105],
        [105, 97],
        [97, 86],
        [93, 102],
        [102, 110],
        [110, 103],
        [103, 93],
        [98, 107],
        [107, 113],
        [113, 106],
        [106, 98],
        [100, 109],
        [109, 114],
        [114, 108],
        [108, 100],
        [104, 111],
        [111, 116],
        [116, 112],
        [112, 104],
        [115, 118],
        [118, 119],
        [119, 117],
        [117, 115],
        [2, 6],
        [13, 8],
        [3, 0],
        [1, 5],
        [11, 17],
        [9, 4],
        [14, 22],
        [34, 24],
        [15, 7],
        [10, 19],
        [29, 40],
        [27, 18],
        [12, 21],
        [32, 43],
        [30, 20],
        [25, 36],
        [49, 38],
        [26, 16],
        [35, 47],
        [53, 41],
        [28, 23],
        [31, 37],
        [50, 62],
        [56, 44],
        [33, 46],
        [58, 70],
        [57, 45],
        [51, 63],
        [76, 64],
        [52, 39],
        [54, 66],
        [79, 67],
        [55, 42],
        [48, 61],
        [73, 85],
        [72, 60],
        [59, 71],
        [83, 89],
        [77, 65],
        [74, 86],
        [97, 92],
        [80, 68],
        [81, 93],
        [103, 94],
        [82, 69],
        [75, 88],
        [99, 107],
        [98, 87],
        [78, 91],
        [101, 109],
        [100, 90],
        [95, 104],
        [112, 105],
        [96, 84],
        [102, 108],
        [114, 118],
        [115, 110],
        [113, 117],
        [119, 116],
        [111, 106]
      ],
      face: [
        [0, 1, 4, 2],
        [3, 8, 14, 7],
        [5, 10, 18, 11],
        [6, 12, 20, 13],
        [9, 17, 25, 16],
        [15, 24, 35, 23],
        [19, 28, 41, 29],
        [21, 31, 44, 32],
        [22, 33, 45, 34],
        [26, 38, 50, 37],
        [27, 40, 51, 39],
        [30, 43, 54, 42],
        [36, 48, 60, 49],
        [46, 55, 67, 58],
        [47, 59, 65, 53],
        [52, 64, 73, 61],
        [56, 62, 74, 68],
        [57, 70, 81, 69],
        [63, 75, 87, 76],
        [66, 78, 90, 79],
        [71, 82, 94, 83],
        [72, 85, 95, 84],
        [77, 89, 99, 88],
        [80, 92, 101, 91],
        [86, 96, 105, 97],
        [93, 102, 110, 103],
        [98, 107, 113, 106],
        [100, 109, 114, 108],
        [104, 111, 116, 112],
        [115, 118, 119, 117],
        [0, 2, 6, 13, 8, 3],
        [1, 5, 11, 17, 9, 4],
        [7, 14, 22, 34, 24, 15],
        [10, 19, 29, 40, 27, 18],
        [12, 21, 32, 43, 30, 20],
        [16, 25, 36, 49, 38, 26],
        [23, 35, 47, 53, 41, 28],
        [31, 37, 50, 62, 56, 44],
        [33, 46, 58, 70, 57, 45],
        [39, 51, 63, 76, 64, 52],
        [42, 54, 66, 79, 67, 55],
        [48, 61, 73, 85, 72, 60],
        [59, 71, 83, 89, 77, 65],
        [68, 74, 86, 97, 92, 80],
        [69, 81, 93, 103, 94, 82],
        [75, 88, 99, 107, 98, 87],
        [78, 91, 101, 109, 100, 90],
        [84, 95, 104, 112, 105, 96],
        [102, 108, 114, 118, 115, 110],
        [106, 113, 117, 119, 116, 111],
        [0, 3, 7, 15, 23, 28, 19, 10, 5, 1],
        [2, 4, 9, 16, 26, 37, 31, 21, 12, 6],
        [8, 13, 20, 30, 42, 55, 46, 33, 22, 14],
        [11, 18, 27, 39, 52, 61, 48, 36, 25, 17],
        [24, 34, 45, 57, 69, 82, 71, 59, 47, 35],
        [29, 41, 53, 65, 77, 88, 75, 63, 51, 40],
        [32, 44, 56, 68, 80, 91, 78, 66, 54, 43],
        [38, 49, 60, 72, 84, 96, 86, 74, 62, 50],
        [58, 67, 79, 90, 100, 108, 102, 93, 81, 70],
        [64, 76, 87, 98, 106, 111, 104, 95, 85, 73],
        [83, 94, 103, 110, 115, 117, 113, 107, 99, 89],
        [92, 97, 105, 112, 116, 119, 118, 114, 109, 101]
      ]
    },
    Rhombicosidodecahedron: {
      vertex: [
        [0, 0, 1.026054],
        [0.447838, 0, 0.9231617],
        [-0.02363976, 0.4472136, 0.9231617],
        [-0.4050732, 0.190983, 0.9231617],
        [-0.1693344, -0.4145898, 0.9231617],
        [0.4241982, 0.4472136, 0.8202696],
        [0.7673818, 0.190983, 0.6537868],
        [0.5552827, -0.4145898, 0.7566788],
        [-0.2312241, 0.7562306, 0.6537868],
        [-0.5744076, -0.2236068, 0.8202696],
        [-0.6126576, 0.5, 0.6537868],
        [0.1738492, -0.6708204, 0.7566788],
        [-0.4669629, -0.6381966, 0.6537868],
        [0.493393, 0.7562306, 0.4873039],
        [0.8748265, -0.2236068, 0.4873039],
        [0.8365765, 0.5, 0.320821],
        [0.7054921, -0.6381966, 0.3844118],
        [0.08831973, 0.9472136, 0.3844118],
        [-0.5434628, 0.809017, 0.320821],
        [-0.8866463, -0.1708204, 0.4873039],
        [-0.9102861, 0.2763932, 0.3844118],
        [-0.1237794, -0.8944272, 0.4873039],
        [0.3240586, -0.8944272, 0.3844118],
        [-0.7792016, -0.5854102, 0.320821],
        [0.6289922, 0.809017, 0.05144604],
        [1.010426, -0.1708204, 0.05144604],
        [0.9867859, 0.2763932, -0.05144604],
        [0.8410913, -0.5854102, -0.05144604],
        [-0.223919, 1, 0.05144604],
        [0.223919, 1, -0.05144604],
        [-0.8410913, 0.5854102, 0.05144604],
        [-0.9867859, -0.2763932, 0.05144604],
        [-1.010426, 0.1708204, -0.05144604],
        [-0.223919, -1, 0.05144604],
        [0.223919, -1, -0.05144604],
        [-0.6289922, -0.809017, -0.05144604],
        [0.7792016, 0.5854102, -0.320821],
        [0.9102861, -0.2763932, -0.3844118],
        [0.8866463, 0.1708204, -0.4873039],
        [0.5434628, -0.809017, -0.320821],
        [-0.3240586, 0.8944272, -0.3844118],
        [0.1237794, 0.8944272, -0.4873039],
        [-0.7054921, 0.6381966, -0.3844118],
        [-0.8365765, -0.5, -0.320821],
        [-0.8748265, 0.2236068, -0.4873039],
        [-0.08831973, -0.9472136, -0.3844118],
        [-0.493393, -0.7562306, -0.4873039],
        [0.4669629, 0.6381966, -0.6537868],
        [0.6126576, -0.5, -0.6537868],
        [0.5744076, 0.2236068, -0.8202696],
        [0.2312241, -0.7562306, -0.6537868],
        [-0.1738492, 0.6708204, -0.7566788],
        [-0.5552827, 0.4145898, -0.7566788],
        [-0.7673818, -0.190983, -0.6537868],
        [-0.4241982, -0.4472136, -0.8202696],
        [0.1693344, 0.4145898, -0.9231617],
        [0.4050732, -0.190983, -0.9231617],
        [0.02363976, -0.4472136, -0.9231617],
        [-0.447838, 0, -0.9231617],
        [0, 0, -1.026054]
      ],
      edge: [
        [0, 2],
        [2, 3],
        [3, 0],
        [1, 6],
        [6, 5],
        [5, 1],
        [4, 9],
        [9, 12],
        [12, 4],
        [7, 16],
        [16, 14],
        [14, 7],
        [8, 18],
        [18, 10],
        [10, 8],
        [11, 21],
        [21, 22],
        [22, 11],
        [13, 15],
        [15, 24],
        [24, 13],
        [17, 29],
        [29, 28],
        [28, 17],
        [19, 31],
        [31, 23],
        [23, 19],
        [20, 30],
        [30, 32],
        [32, 20],
        [25, 27],
        [27, 37],
        [37, 25],
        [26, 38],
        [38, 36],
        [36, 26],
        [33, 45],
        [45, 34],
        [34, 33],
        [35, 43],
        [43, 46],
        [46, 35],
        [39, 50],
        [50, 48],
        [48, 39],
        [40, 41],
        [41, 51],
        [51, 40],
        [42, 52],
        [52, 44],
        [44, 42],
        [47, 49],
        [49, 55],
        [55, 47],
        [53, 58],
        [58, 54],
        [54, 53],
        [56, 57],
        [57, 59],
        [59, 56],
        [0, 1],
        [5, 2],
        [3, 9],
        [4, 0],
        [1, 7],
        [14, 6],
        [2, 8],
        [10, 3],
        [12, 21],
        [11, 4],
        [6, 15],
        [13, 5],
        [7, 11],
        [22, 16],
        [8, 17],
        [28, 18],
        [9, 19],
        [23, 12],
        [18, 30],
        [20, 10],
        [24, 29],
        [17, 13],
        [16, 27],
        [25, 14],
        [15, 26],
        [36, 24],
        [19, 20],
        [32, 31],
        [21, 33],
        [34, 22],
        [31, 43],
        [35, 23],
        [37, 38],
        [26, 25],
        [27, 39],
        [48, 37],
        [29, 41],
        [40, 28],
        [30, 42],
        [44, 32],
        [33, 35],
        [46, 45],
        [45, 50],
        [39, 34],
        [38, 49],
        [47, 36],
        [51, 52],
        [42, 40],
        [41, 47],
        [55, 51],
        [43, 53],
        [54, 46],
        [52, 58],
        [53, 44],
        [50, 57],
        [56, 48],
        [49, 56],
        [59, 55],
        [58, 59],
        [57, 54]
      ],
      face: [
        [0, 2, 3],
        [1, 6, 5],
        [4, 9, 12],
        [7, 16, 14],
        [8, 18, 10],
        [11, 21, 22],
        [13, 15, 24],
        [17, 29, 28],
        [19, 31, 23],
        [20, 30, 32],
        [25, 27, 37],
        [26, 38, 36],
        [33, 45, 34],
        [35, 43, 46],
        [39, 50, 48],
        [40, 41, 51],
        [42, 52, 44],
        [47, 49, 55],
        [53, 58, 54],
        [56, 57, 59],
        [0, 1, 5, 2],
        [0, 3, 9, 4],
        [1, 7, 14, 6],
        [2, 8, 10, 3],
        [4, 12, 21, 11],
        [5, 6, 15, 13],
        [7, 11, 22, 16],
        [8, 17, 28, 18],
        [9, 19, 23, 12],
        [10, 18, 30, 20],
        [13, 24, 29, 17],
        [14, 16, 27, 25],
        [15, 26, 36, 24],
        [19, 20, 32, 31],
        [21, 33, 34, 22],
        [23, 31, 43, 35],
        [25, 37, 38, 26],
        [27, 39, 48, 37],
        [28, 29, 41, 40],
        [30, 42, 44, 32],
        [33, 35, 46, 45],
        [34, 45, 50, 39],
        [36, 38, 49, 47],
        [40, 51, 52, 42],
        [41, 47, 55, 51],
        [43, 53, 54, 46],
        [44, 52, 58, 53],
        [48, 50, 57, 56],
        [49, 56, 59, 55],
        [54, 58, 59, 57],
        [0, 4, 11, 7, 1],
        [2, 5, 13, 17, 8],
        [3, 10, 20, 19, 9],
        [6, 14, 25, 26, 15],
        [12, 23, 35, 33, 21],
        [16, 22, 34, 39, 27],
        [18, 28, 40, 42, 30],
        [24, 36, 47, 41, 29],
        [31, 32, 44, 53, 43],
        [37, 48, 56, 49, 38],
        [45, 46, 54, 57, 50],
        [51, 55, 59, 58, 52]
      ]
    },
    SnubDodecahedron: {
      vertex: [
        [0, 0, 1.028031],
        [0.4638569, 0, 0.9174342],
        [0.2187436, 0.4090409, 0.9174342],
        [-0.2575486, 0.3857874, 0.9174342],
        [-0.4616509, -0.04518499, 0.9174342],
        [-0.177858, -0.4284037, 0.9174342],
        [0.5726782, -0.4284037, 0.7384841],
        [0.8259401, -0.04518499, 0.6104342],
        [0.6437955, 0.3857874, 0.702527],
        [0.349648, 0.7496433, 0.6104342],
        [-0.421009, 0.7120184, 0.6104342],
        [-0.6783139, 0.3212396, 0.702527],
        [-0.6031536, -0.4466658, 0.702527],
        [-0.2749612, -0.7801379, 0.6104342],
        [0.1760766, -0.6931717, 0.7384841],
        [0.5208138, -0.7801379, 0.4206978],
        [0.8552518, -0.4466658, 0.3547998],
        [1.01294, -0.03548596, 0.1718776],
        [0.7182239, 0.661842, 0.3208868],
        [0.3633691, 0.9454568, 0.1758496],
        [-0.04574087, 0.9368937, 0.4206978],
        [-0.4537394, 0.905564, 0.1758496],
        [-0.7792791, 0.5887312, 0.3208868],
        [-0.9537217, 0.1462217, 0.3547998],
        [-0.9072701, -0.3283699, 0.3547998],
        [-0.6503371, -0.7286577, 0.3208868],
        [0.08459482, -0.9611501, 0.3547998],
        [0.3949153, -0.9491262, -7072558e-9],
        [0.9360473, -0.409557, -0.1136978],
        [0.9829382, 0.02692292, -0.2999274],
        [0.9463677, 0.4014808, -7072558e-9],
        [0.6704578, 0.7662826, -0.1419366],
        [-0.05007646, 1.025698, -0.04779978],
        [-0.4294337, 0.8845784, -0.2999274],
        [-0.9561681, 0.3719321, -0.06525234],
        [-1.022036, -0.1000338, -0.04779978],
        [-0.8659056, -0.5502712, -0.06525234],
        [-0.5227761, -0.8778535, -0.1136978],
        [-0.06856319, -1.021542, -0.09273844],
        [0.2232046, -0.8974878, -0.4489366],
        [0.6515438, -0.7200947, -0.3373472],
        [0.7969535, -0.3253959, -0.5619888],
        [0.8066872, 0.4395354, -0.461425],
        [0.4468035, 0.735788, -0.5619888],
        [1488801e-9, 0.8961155, -0.503809],
        [-0.3535403, 0.6537658, -0.7102452],
        [-0.7399517, 0.5547758, -0.4489366],
        [-0.9120238, 0.1102196, -0.461425],
        [-0.6593998, -0.6182798, -0.4896639],
        [-0.2490651, -0.8608088, -0.503809],
        [0.4301047, -0.5764987, -0.734512],
        [0.5057577, -0.1305283, -0.8854492],
        [0.5117735, 0.3422252, -0.8232973],
        [0.09739587, 0.5771941, -0.8451093],
        [-0.6018946, 0.2552591, -0.7933564],
        [-0.6879024, -0.2100741, -0.734512],
        [-0.3340437, -0.5171509, -0.8232973],
        [0.08570633, -0.3414376, -0.9658797],
        [0.1277354, 0.1313635, -1.011571],
        [-0.3044499, -0.06760332, -0.979586]
      ],
      edge: [
        [0, 1],
        [1, 2],
        [2, 0],
        [2, 3],
        [3, 0],
        [3, 4],
        [4, 0],
        [4, 5],
        [5, 0],
        [1, 6],
        [6, 7],
        [7, 1],
        [7, 8],
        [8, 1],
        [8, 2],
        [8, 9],
        [9, 2],
        [3, 10],
        [10, 11],
        [11, 3],
        [11, 4],
        [4, 12],
        [12, 5],
        [12, 13],
        [13, 5],
        [13, 14],
        [14, 5],
        [6, 14],
        [14, 15],
        [15, 6],
        [15, 16],
        [16, 6],
        [16, 7],
        [16, 17],
        [17, 7],
        [8, 18],
        [18, 9],
        [18, 19],
        [19, 9],
        [19, 20],
        [20, 9],
        [10, 20],
        [20, 21],
        [21, 10],
        [21, 22],
        [22, 10],
        [22, 11],
        [22, 23],
        [23, 11],
        [12, 24],
        [24, 25],
        [25, 12],
        [25, 13],
        [13, 26],
        [26, 14],
        [26, 15],
        [26, 27],
        [27, 15],
        [16, 28],
        [28, 17],
        [28, 29],
        [29, 17],
        [29, 30],
        [30, 17],
        [18, 30],
        [30, 31],
        [31, 18],
        [31, 19],
        [19, 32],
        [32, 20],
        [32, 21],
        [32, 33],
        [33, 21],
        [22, 34],
        [34, 23],
        [34, 35],
        [35, 23],
        [35, 24],
        [24, 23],
        [35, 36],
        [36, 24],
        [36, 25],
        [36, 37],
        [37, 25],
        [26, 38],
        [38, 27],
        [38, 39],
        [39, 27],
        [39, 40],
        [40, 27],
        [28, 40],
        [40, 41],
        [41, 28],
        [41, 29],
        [29, 42],
        [42, 30],
        [42, 31],
        [42, 43],
        [43, 31],
        [32, 44],
        [44, 33],
        [44, 45],
        [45, 33],
        [45, 46],
        [46, 33],
        [34, 46],
        [46, 47],
        [47, 34],
        [47, 35],
        [36, 48],
        [48, 37],
        [48, 49],
        [49, 37],
        [49, 38],
        [38, 37],
        [49, 39],
        [39, 50],
        [50, 40],
        [50, 41],
        [50, 51],
        [51, 41],
        [42, 52],
        [52, 43],
        [52, 53],
        [53, 43],
        [53, 44],
        [44, 43],
        [53, 45],
        [45, 54],
        [54, 46],
        [54, 47],
        [54, 55],
        [55, 47],
        [48, 55],
        [55, 56],
        [56, 48],
        [56, 49],
        [50, 57],
        [57, 51],
        [57, 58],
        [58, 51],
        [58, 52],
        [52, 51],
        [58, 53],
        [54, 59],
        [59, 55],
        [59, 56],
        [59, 57],
        [57, 56],
        [59, 58]
      ],
      face: [
        [0, 1, 2],
        [0, 2, 3],
        [0, 3, 4],
        [0, 4, 5],
        [1, 6, 7],
        [1, 7, 8],
        [1, 8, 2],
        [2, 8, 9],
        [3, 10, 11],
        [3, 11, 4],
        [4, 12, 5],
        [5, 12, 13],
        [5, 13, 14],
        [6, 14, 15],
        [6, 15, 16],
        [6, 16, 7],
        [7, 16, 17],
        [8, 18, 9],
        [9, 18, 19],
        [9, 19, 20],
        [10, 20, 21],
        [10, 21, 22],
        [10, 22, 11],
        [11, 22, 23],
        [12, 24, 25],
        [12, 25, 13],
        [13, 26, 14],
        [14, 26, 15],
        [15, 26, 27],
        [16, 28, 17],
        [17, 28, 29],
        [17, 29, 30],
        [18, 30, 31],
        [18, 31, 19],
        [19, 32, 20],
        [20, 32, 21],
        [21, 32, 33],
        [22, 34, 23],
        [23, 34, 35],
        [23, 35, 24],
        [24, 35, 36],
        [24, 36, 25],
        [25, 36, 37],
        [26, 38, 27],
        [27, 38, 39],
        [27, 39, 40],
        [28, 40, 41],
        [28, 41, 29],
        [29, 42, 30],
        [30, 42, 31],
        [31, 42, 43],
        [32, 44, 33],
        [33, 44, 45],
        [33, 45, 46],
        [34, 46, 47],
        [34, 47, 35],
        [36, 48, 37],
        [37, 48, 49],
        [37, 49, 38],
        [38, 49, 39],
        [39, 50, 40],
        [40, 50, 41],
        [41, 50, 51],
        [42, 52, 43],
        [43, 52, 53],
        [43, 53, 44],
        [44, 53, 45],
        [45, 54, 46],
        [46, 54, 47],
        [47, 54, 55],
        [48, 55, 56],
        [48, 56, 49],
        [50, 57, 51],
        [51, 57, 58],
        [51, 58, 52],
        [52, 58, 53],
        [54, 59, 55],
        [55, 59, 56],
        [56, 59, 57],
        [57, 59, 58],
        [0, 5, 14, 6, 1],
        [2, 9, 20, 10, 3],
        [4, 11, 23, 24, 12],
        [7, 17, 30, 18, 8],
        [13, 25, 37, 38, 26],
        [15, 27, 40, 28, 16],
        [19, 31, 43, 44, 32],
        [21, 33, 46, 34, 22],
        [29, 41, 51, 52, 42],
        [35, 47, 55, 48, 36],
        [39, 49, 56, 57, 50],
        [45, 53, 58, 59, 54]
      ]
    },
    /* Other */
    TriangularPrism: {
      vertex: [
        [0, 0.75, 0.9375],
        [-0.8119, 0.75, -0.46875],
        [0.8119, 0.75, -0.46875],
        [0, -0.75, 0.9375],
        [-0.8119, -0.75, -0.46875],
        [0.8119, -0.75, -0.46875]
      ],
      edge: [
        [0, 1],
        [1, 2],
        [2, 0],
        [0, 3],
        [1, 4],
        [2, 5],
        [3, 4],
        [4, 5],
        [5, 3]
      ],
      face: [
        [3, 2, 5],
        [0, 2, 3],
        [0, 4, 1],
        [1, 2, 0],
        [4, 0, 3],
        [4, 3, 5],
        [1, 5, 2],
        [5, 1, 4]
      ]
    },
    PentagonalPrism: {
      vertex: [
        [0, 0, 1.159953],
        [1.013464, 0, 0.5642542],
        [-0.3501431, 0.9510565, 0.5642542],
        [-0.7715208, -0.6571639, 0.5642542],
        [0.6633206, 0.9510565, -0.03144481],
        [0.8682979, -0.6571639, -0.3996071],
        [-1.121664, 0.2938926, -0.03144481],
        [-0.2348831, -1.063314, -0.3996071],
        [0.5181548, 0.2938926, -0.9953061],
        [-0.5850262, -0.112257, -0.9953061]
      ],
      edge: [
        [0, 1],
        [1, 4],
        [4, 2],
        [2, 0],
        [2, 6],
        [6, 3],
        [3, 0],
        [1, 5],
        [5, 8],
        [8, 4],
        [6, 9],
        [9, 7],
        [7, 3],
        [5, 7],
        [9, 8]
      ],
      face: [
        [0, 1, 4, 2],
        [0, 2, 6, 3],
        [1, 5, 8, 4],
        [3, 6, 9, 7],
        [5, 7, 9, 8],
        [0, 3, 7, 5, 1],
        [2, 4, 8, 9, 6]
      ]
    },
    HexagonalPrism: {
      vertex: [
        [1, -0.56, 0],
        [0.5, -0.56, -0.86603],
        [-0.5, -0.56, -0.86603],
        [-1, -0.56, 0],
        [-0.5, -0.56, 0.86603],
        [0.5, -0.56, 0.86603],
        [0.5, 0.56, 0.86603],
        [-0.5, 0.56, 0.86603],
        [-1, 0.56, 0],
        [-0.5, 0.56, -0.86603],
        [0.5, 0.56, -0.86603],
        [1, 0.56, 0]
      ],
      edge: [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 4],
        [4, 5],
        [5, 0],
        [0, 11],
        [1, 10],
        [2, 9],
        [3, 8],
        [4, 7],
        [5, 6],
        [6, 7],
        [7, 8],
        [8, 9],
        [9, 10],
        [10, 11],
        [11, 6]
      ],
      face: [
        [11, 5, 6],
        [2, 1, 5],
        [0, 1, 10],
        [10, 11, 0],
        [8, 9, 2],
        [1, 2, 9],
        [4, 7, 6],
        [7, 3, 8],
        [4, 3, 7],
        [0, 5, 1],
        [5, 4, 2],
        [3, 2, 4],
        [11, 6, 10],
        [8, 9, 7],
        [6, 7, 9],
        [9, 10, 6],
        [6, 5, 4],
        [9, 1, 10],
        [0, 11, 5],
        [2, 3, 8]
      ]
    },
    Hebesphenorotunda: {
      vertex: [
        [-0.748928, 0.557858, -0.030371],
        [-0.638635, 0.125804, -0.670329],
        [-0.593696, 0.259282, 0.67329],
        [-0.427424, 0.876636, -0.665507],
        [-0.373109, -0.604827, -0.606627],
        [-0.32817, -0.471348, 0.736992],
        [-0.217876, -0.903403, 0.097033],
        [-0.141658, 1.042101, 0.041134],
        [-0.021021, 0.094954, 1.176701],
        [0.013575, 0.743525, 0.744795],
        [0.036802, 0.343022, -0.994341],
        [0.267732, -1.036179, -0.498733],
        [0.302328, -0.387609, -0.93064],
        [0.443205, -0.438661, 0.847867],
        [0.499183, 0.610749, 0.149029],
        [0.553499, -0.870715, 0.207908],
        [0.609478, 0.178694, -0.490931],
        [0.76471, -0.119883, 0.212731]
      ],
      edge: [
        [11, 12],
        [12, 16],
        [16, 17],
        [17, 15],
        [15, 11],
        [11, 4],
        [4, 12],
        [11, 6],
        [6, 4],
        [15, 6],
        [15, 13],
        [13, 5],
        [5, 6],
        [17, 13],
        [8, 13],
        [17, 14],
        [14, 9],
        [9, 8],
        [8, 5],
        [2, 5],
        [8, 2],
        [9, 2],
        [7, 9],
        [14, 7],
        [7, 0],
        [0, 2],
        [16, 14],
        [16, 10],
        [10, 3],
        [3, 7],
        [3, 0],
        [3, 1],
        [1, 0],
        [10, 1],
        [4, 1],
        [10, 12]
      ],
      face: [
        [12, 11, 4],
        [11, 6, 4],
        [6, 11, 15],
        [13, 15, 17],
        [5, 13, 8],
        [2, 5, 8],
        [2, 8, 9],
        [7, 9, 14],
        [16, 14, 17],
        [3, 0, 7],
        [3, 1, 0],
        [1, 3, 10],
        [12, 10, 16],
        [6, 15, 13, 5],
        [2, 9, 7, 0],
        [12, 4, 1, 10],
        [11, 12, 16, 17, 15],
        [8, 13, 17, 14, 9],
        [16, 10, 3, 7, 14],
        [1, 4, 6, 5, 2, 0]
      ]
    },
    StellatedDodecahedron: {
      vertex: [
        [0.8944, 0.4472, 0],
        [0.2764, 0.4472, 0.8506],
        [0.2764, 0.4472, -0.8506],
        [-0.7236, 0.4472, 0.5257],
        [-0.7236, 0.4472, -0.5257],
        [-0.3416, 0.4472, 0],
        [-0.1056, 0.4472, 0.3249],
        [-0.1056, 0.4472, -0.3249],
        [0.2764, 0.4472, 0.2008],
        [0.2764, 0.4472, -0.2008],
        [-0.8944, -0.4472, 0],
        [-0.2764, -0.4472, 0.8506],
        [-0.2764, -0.4472, -0.8506],
        [0.7236, -0.4472, 0.5257],
        [0.7236, -0.4472, -0.5257],
        [0.3416, -0.4472, 0],
        [0.1056, -0.4472, 0.3249],
        [0.1056, -0.4472, -0.3249],
        [-0.2764, -0.4472, 0.2008],
        [-0.2764, -0.4472, -0.2008],
        [-0.5527, 0.1058, 0],
        [-0.1708, 0.1058, 0.5527],
        [-0.1708, 0.1058, -0.5527],
        [0.4471, 0.1058, 0.3249],
        [0.4471, 0.1058, -0.3249],
        [0.5527, -0.1058, 0],
        [0.1708, -0.1058, 0.5527],
        [0.1708, -0.1058, -0.5527],
        [-0.4471, -0.1058, 0.3249],
        [-0.4471, -0.1058, -0.3249],
        [0, 1, 0],
        [0, -1, 0]
      ],
      edge: [
        [0, 8],
        [8, 9],
        [0, 9],
        [2, 7],
        [7, 9],
        [2, 9],
        [4, 5],
        [5, 7],
        [4, 7],
        [3, 5],
        [5, 6],
        [3, 6],
        [1, 6],
        [6, 8],
        [1, 8],
        [0, 23],
        [23, 8],
        [30, 6],
        [30, 8],
        [21, 3],
        [21, 6],
        [11, 21],
        [21, 26],
        [11, 26],
        [13, 23],
        [23, 26],
        [13, 26],
        [2, 24],
        [24, 9],
        [30, 9],
        [1, 23],
        [23, 25],
        [13, 25],
        [14, 24],
        [24, 25],
        [14, 25],
        [22, 4],
        [22, 7],
        [30, 7],
        [0, 24],
        [24, 27],
        [14, 27],
        [12, 22],
        [22, 27],
        [12, 27],
        [20, 3],
        [20, 5],
        [30, 5],
        [2, 22],
        [22, 29],
        [12, 29],
        [10, 20],
        [20, 29],
        [10, 29],
        [1, 21],
        [20, 4],
        [20, 28],
        [10, 28],
        [21, 28],
        [11, 28],
        [10, 18],
        [18, 19],
        [10, 19],
        [12, 17],
        [17, 19],
        [12, 19],
        [14, 15],
        [15, 17],
        [14, 17],
        [13, 15],
        [15, 16],
        [13, 16],
        [11, 16],
        [16, 18],
        [11, 18],
        [19, 31],
        [17, 31],
        [17, 27],
        [2, 27],
        [29, 4],
        [19, 29],
        [18, 31],
        [28, 3],
        [18, 28],
        [16, 31],
        [1, 26],
        [16, 26],
        [15, 31],
        [0, 25],
        [15, 25]
      ],
      face: [
        [0, 9, 8],
        [2, 7, 9],
        [4, 5, 7],
        [3, 6, 5],
        [1, 8, 6],
        [0, 8, 23],
        [30, 6, 8],
        [3, 21, 6],
        [11, 26, 21],
        [13, 23, 26],
        [2, 9, 24],
        [30, 8, 9],
        [1, 23, 8],
        [13, 25, 23],
        [14, 24, 25],
        [4, 7, 22],
        [30, 9, 7],
        [0, 24, 9],
        [14, 27, 24],
        [12, 22, 27],
        [3, 5, 20],
        [30, 7, 5],
        [2, 22, 7],
        [12, 29, 22],
        [10, 20, 29],
        [1, 6, 21],
        [30, 5, 6],
        [4, 20, 5],
        [10, 28, 20],
        [11, 21, 28],
        [10, 19, 18],
        [12, 17, 19],
        [14, 15, 17],
        [13, 16, 15],
        [11, 18, 16],
        [31, 19, 17],
        [14, 17, 27],
        [2, 27, 22],
        [4, 22, 29],
        [10, 29, 19],
        [31, 18, 19],
        [12, 19, 29],
        [4, 29, 20],
        [3, 20, 28],
        [11, 28, 18],
        [31, 16, 18],
        [10, 18, 28],
        [3, 28, 21],
        [1, 21, 26],
        [13, 26, 16],
        [31, 15, 16],
        [11, 16, 26],
        [1, 26, 23],
        [0, 23, 25],
        [14, 25, 15],
        [31, 17, 15],
        [13, 15, 25],
        [0, 25, 24],
        [2, 24, 27],
        [12, 27, 17]
      ]
    },
    Stair: {
      vertex: [
        [-0.75, -0.5125, 0.6125],
        [0.75, -0.5125, 0.6125],
        [0.75, -0.1375, 0.2375],
        [-0.75, -0.1375, 0.2375],
        [-0.75, -0.1375, 0.6125],
        [0.75, -0.1375, 0.6125],
        [-0.75, 0.2375, -0.1375],
        [0.75, 0.2375, -0.1375],
        [-0.75, 0.2375, 0.2375],
        [0.75, 0.2375, 0.2375],
        [-0.75, 0.6125, -0.1375],
        [0.75, 0.6125, -0.1375],
        [0.75, 0.6125, -0.5125],
        [-0.75, 0.6125, -0.5125],
        [-0.75, -0.5125, -0.5125],
        [0.75, -0.5125, -0.5125]
      ],
      edge: [
        [0, 1],
        [0, 4],
        [2, 3],
        [3, 4],
        [3, 8],
        [2, 9],
        [8, 9],
        [7, 9],
        [6, 8],
        [6, 7],
        [6, 10],
        [7, 11],
        [10, 11],
        [10, 13],
        [11, 12],
        [4, 5],
        [1, 5],
        [2, 5],
        [0, 14],
        [1, 15],
        [14, 15],
        [13, 14],
        [12, 15],
        [12, 13]
      ],
      face: [
        [10, 11, 7],
        [11, 10, 13],
        [7, 6, 10],
        [7, 9, 6],
        [8, 6, 9],
        [9, 2, 8],
        [2, 3, 8],
        [12, 13, 15],
        [14, 15, 13],
        [12, 11, 13],
        [10, 6, 13],
        [13, 6, 14],
        [8, 3, 6],
        [6, 3, 14],
        [4, 0, 3],
        [14, 3, 0],
        [2, 5, 3],
        [4, 3, 5],
        [5, 1, 4],
        [4, 1, 0],
        [1, 15, 0],
        [15, 14, 0],
        [11, 12, 7],
        [9, 7, 2],
        [5, 2, 1],
        [1, 2, 15],
        [2, 7, 15],
        [15, 7, 12]
      ]
    },
    AngularCylinder: {
      vertex: [
        [0, -0.35, 1],
        [-0.86603, -0.35, 0.5],
        [-0.86603, -0.35, -0.5],
        [0, -0.35, -1],
        [0.86603, -0.35, -0.5],
        [0.86603, -0.35, 0.5],
        [0.5, 0.35, 0.86603],
        [-0.5, 0.35, 0.86603],
        [-1, 0.35, 0],
        [-0.5, 0.35, -0.86603],
        [0.5, 0.35, -0.86603],
        [1, 0.35, 0]
      ],
      edge: [
        [0, 1],
        [0, 5],
        [0, 6],
        [0, 7],
        [6, 7],
        [1, 2],
        [1, 7],
        [1, 8],
        [7, 8],
        [2, 3],
        [2, 8],
        [2, 9],
        [8, 9],
        [3, 4],
        [3, 9],
        [3, 10],
        [9, 10],
        [4, 5],
        [4, 10],
        [4, 11],
        [10, 11],
        [5, 11],
        [5, 6]
      ],
      face: [
        [4, 10, 3],
        [9, 3, 10],
        [3, 9, 2],
        [9, 8, 2],
        [2, 8, 1],
        [8, 7, 1],
        [1, 7, 0],
        [7, 6, 0],
        [0, 6, 5],
        [6, 11, 5],
        [5, 11, 4],
        [11, 10, 4],
        [11, 6, 10],
        [8, 9, 7],
        [6, 7, 9],
        [9, 10, 6],
        [0, 5, 1],
        [3, 2, 4],
        [4, 2, 5],
        [2, 1, 5]
      ]
    },
    OpenBox: {
      vertex: [
        [-0.75, -0.5, -0.75],
        [-0.75, 0.5, -0.75],
        [-0.75, -0.5, 0.75],
        [-0.75, 0.5, 0.75],
        [0.75, -0.5, -0.75],
        [0.75, 0.5, -0.75],
        [0.75, -0.5, 0.75],
        [0.75, 0.5, 0.75]
      ],
      edge: [
        [0, 1],
        [0, 4],
        [0, 2],
        [1, 3],
        [1, 5],
        [2, 3],
        [2, 6],
        [3, 7],
        [4, 5],
        [4, 6],
        [5, 7],
        [6, 7]
      ],
      face: [
        [6, 7, 5],
        [1, 3, 0],
        [6, 2, 7],
        [2, 3, 7],
        [2, 0, 3],
        [4, 6, 5],
        [4, 5, 1],
        [1, 0, 4],
        [2, 6, 0],
        [4, 0, 6]
      ]
    }
  };

  // content/polyhedra/components/polyhedron.ts
  var colours2 = {
    3: 16616448,
    // yellow
    4: 1016562,
    // blue
    5: 2272036,
    // green
    6: 13438566,
    // red
    8: 7158719,
    // violet
    10: 40614
    // teal
  };
  var scales = {
    StellatedDodecahedron: 2,
    Octahedron: 1.3,
    Tetrahedron: 1.1
  };
  var Polyhedron = class extends Solid {
    created() {
      const shape = this.attr("shape");
      const data = PolyhedronData[shape];
      if (!data) return console.error("Unknown polyhedron:", shape);
      const scale = scales[shape] || 1.65;
      if (!this.hasAttr("rotate")) this.setAttr("rotate", "1");
      this.addMesh(() => {
        const polyhedron = new THREE.Object3D();
        const vertices = data.vertex.map((v) => new THREE.Vector3(v[0], v[1], v[2]).multiplyScalar(scale));
        const faceGeometry = new THREE.Geometry();
        faceGeometry.vertices = vertices;
        for (const f of data.face) {
          for (let i = 1; i < f.length - 1; i++) {
            const face = new THREE.Face3(f[0], f[i], f[i + 1]);
            face.color = new THREE.Color(colours2[f.length]);
            faceGeometry.faces.push(face);
          }
        }
        faceGeometry.computeFaceNormals();
        faceGeometry.computeVertexNormals();
        const faceMaterial = new THREE.MeshPhongMaterial({
          vertexColors: THREE.FaceColors,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.9,
          specular: 2236962,
          flatShading: true
        });
        polyhedron.add(new THREE.Mesh(faceGeometry, faceMaterial));
        for (const e2 of data.edge) {
          const edgeGeometry = new THREE.Geometry();
          edgeGeometry.vertices = [vertices[e2[0]], vertices[e2[1]]];
          const edgeMaterial = new THREE.LineBasicMaterial({ color: 16777215 });
          const edge = new THREE.Line(edgeGeometry, edgeMaterial);
          polyhedron.add(edge);
        }
        return [polyhedron];
      });
    }
    getVertexCoords(index) {
      const obj = this.object.children[0];
      const mesh = obj.children.find((obj3D) => obj3D.type == "Mesh");
      return mesh.geometry.vertices[index];
    }
  };
  Polyhedron = __decorateClass([
    register("x-polyhedron")
  ], Polyhedron);

  // content/solids/functions.ts
  function polyParts($step) {
    const $p = $step.$("x-polyhedron");
    $p.addMesh(() => {
      const vertices = [0, 1, 2].map((i) => $p.getVertexCoords(i));
      $p.addLabel("Vertex", vertices[2].toArray(), 1016562, "5px");
      $p.addPoint(vertices[2].toArray(), 1016562);
      $p.addLine(vertices[0].toArray(), vertices[2].toArray(), 13438566);
      $p.addLabel("Edge", vertices[0].lerp(vertices[2], 0.5).toArray(), 13438566, "5px");
      $p.addLabel("Face", vertices[1].lerp(vertices[2], 0.5).toArray(), 2272036, "5px");
    });
  }
  function polyIdent($step) {
    const $cylinder = $step.$("x-solid.cylinder");
    const $sphere = $step.$("x-solid.sphere");
    const $cone = $step.$("x-solid.cone");
    $cylinder.addMesh(() => {
      const geo = new THREE.CylinderGeometry(1.2, 1.2, 2.6, 32, 1);
      $cylinder.addSolid(geo, 16616448, 20);
    });
    $sphere.addMesh(() => {
      const geo = new THREE.SphereGeometry(1.3, 128, 128);
      $sphere.addSolid(geo, 16616448);
    });
    $cone.addMesh(() => {
      const geo = new THREE.ConeGeometry(1.3, 2.6, 128, 1);
      $cone.addSolid(geo, 16616448);
    });
  }
  function cuboidParts($step) {
    const $p = $step.$("x-polyhedron");
    $p.addMesh(() => {
      const vertices = [0, 1, 2, 3].map((i) => $p.getVertexCoords(i));
      $p.addLabel("Vertex", vertices[2].toArray(), 1016562, "5px");
      $p.addPoint(vertices[2].toArray(), 1016562);
      $p.addLine(vertices[0].toArray(), vertices[2].toArray(), 13438566);
      $p.addLabel("Edge", vertices[0].lerp(vertices[2], 0.5).toArray(), 13438566, "5px");
      $p.addLabel("Face", vertices[0].lerp(vertices[3], 0.5).toArray(), 2272036, "5px");
    });
  }
  function templeFilling($step) {
    return __async(this, null, function* () {
      const $voxelPainter = $step.$("x-voxel-painter");
      handleLayers($voxelPainter, 0);
    });
  }
  function handleLayers($vp, currentLayer) {
    if (currentLayer > 0) {
      $vp.addVoxels(layers[currentLayer].locs, layers[currentLayer].color);
    } else {
      $vp.clearVoxels();
    }
    setTimeout(() => handleLayers($vp, (currentLayer + 1) % layers.length), 1e3);
  }
  function templeDisplay($vp) {
    for (const part of templeParts) {
      $vp.addVoxels(part.locs, part.color);
    }
  }
  function templeDisplay1($step) {
    return __async(this, null, function* () {
      const $voxelPainter = $step.$("x-voxel-painter");
      templeDisplay($voxelPainter);
    });
  }
  function templeDisplay2($step) {
    return __async(this, null, function* () {
      const $voxelPainter = $step.$("x-voxel-painter");
      templeDisplay($voxelPainter);
    });
  }
  function painting1($step) {
    const $voxelPainter = $step.$("x-voxel-painter");
    $voxelPainter.on("volume-target-met", (positions) => {
      if (isCuboid(positions)) {
        console.log("correct");
        $step.score("vol");
        $step.addHint("correct");
      } else {
        $step.addHint("incorrect");
      }
    });
  }
  function isCuboid(positions) {
    const sortedPositions = positions.sort((a2, b2) => {
      if (a2[0] != b2[0]) {
        return a2[0] - b2[0];
      } else if (a2[1] != b2[1]) {
        return a2[1] - b2[1];
      } else {
        return a2[2] - b2[2];
      }
    });
    const [minX, minY, minZ] = sortedPositions[0];
    const [maxX, maxY, maxZ] = sortedPositions[sortedPositions.length - 1];
    const xRange = list(minX, maxX, 1);
    const yRange = list(minY, maxY, 1);
    const zRange = list(minZ, maxZ, 1);
    const xy = cartesian2D(xRange, yRange);
    const xyz = cartesian3D(xy, zRange);
    if (xyz.length == sortedPositions.length) {
      const eq = xyz.every(
        ([x, y, z], index) => x == sortedPositions[index][0] && y == sortedPositions[index][1] && z == sortedPositions[index][2]
      );
      if (eq) return true;
      else return false;
    } else {
      return false;
    }
  }
  function cartesian2D(a2, b2) {
    const mat = [];
    for (const aItem of a2) {
      for (const bItem of b2) {
        mat.push([aItem, bItem]);
      }
    }
    return mat;
  }
  function cartesian3D(a2, b2) {
    const mat = [];
    for (const aRow of a2) {
      for (const bItem of b2) {
        mat.push(aRow.concat(bItem));
      }
    }
    return mat;
  }
  function sidesRotation($step) {
    const $v = $step.$("x-voxel-painter");
    const $faceDisplay = $step.$("x-polypad");
    $v.on("snap", ([color, _angles]) => {
      if (color == "none") $step.addHint("incorrect");
      else $step.score(color);
    });
    $step.onScore("front", () => {
      const $t = $faceDisplay.newTile("number-tile", "2:6");
      $t.setTransform(new Point(50, 50));
      $t.setColour(RED);
      $t.locked = true;
      $step.addHint("correct");
    });
    $step.onScore("right", () => {
      const $t = $faceDisplay.newTile("number-tile", "2:6");
      $t.setTransform(new Point(150, 50));
      $t.setColour(PURPLE);
      $t.locked = true;
      $step.addHint("correct");
    });
    $step.onScore("back", () => {
      const $t = $faceDisplay.newTile("number-tile", "2:6");
      $t.setTransform(new Point(250, 50));
      $t.setColour(BLUE);
      $t.locked = true;
      $step.addHint("correct");
    });
    $step.onScore("left", () => {
      const $t = $faceDisplay.newTile("number-tile", "2:6");
      $t.setTransform(new Point(350, 50));
      $t.setColour(ORANGE);
      $t.locked = true;
      $step.addHint("correct");
    });
    $step.onScore("top", () => {
      const $t = $faceDisplay.newTile("number-tile", "2:4");
      $t.setTransform(new Point(450, 62.5));
      $t.setColour(GREEN);
      $t.locked = true;
      $step.addHint("correct");
    });
    $step.onScore("bottom", () => {
      const $t = $faceDisplay.newTile("number-tile", "2:4");
      $t.setTransform(new Point(550, 62.5));
      $t.setColour(YELLOW);
      $t.locked = true;
      $step.addHint("correct");
    });
  }
  function voxelSurface($step) {
    const $voxelPainter = $step.$("x-voxel-painter");
    $voxelPainter.on("both-targets-met", (positions) => {
      if (isContiguous(positions)) {
        console.log("correct");
        $step.score("area");
        $step.addHint("correct");
      } else {
        $step.addHint("incorrect");
      }
    });
  }
  function isContiguous(_positions) {
    return true;
  }
  function cubeTable($step) {
    for (const size of [1, 2, 3, 6, 10, 20]) {
      const $vp = $step.$("x-voxel-painter.c" + size.toString());
      $vp.addVoxels(voxCube(size), YELLOW);
    }
  }
  function voxCube(size) {
    const locs = [];
    for (let x = 0; x < size; x++) {
      for (let y = 0; y < size; y++) {
        for (let z = 0; z < size; z++) {
          if (x == 0 || x == size - 1 || y == 0 || y == size - 1 || z == 0 || z == size - 1) locs.push([x - size / 2, y - size / 2, z - size / 2]);
        }
      }
    }
    return locs;
  }
  function cubeDraw($step) {
    const $p = $step.$("x-polypad");
    $p.setActiveTool("pen");
    $p.tools.pen.brush = "straight";
  }
  function net1($step) {
    const $net1 = $step.$(".s1 x-net");
    const $slider = $step.$("x-slider");
    $net1.addCuboidNet(1, 1, 1);
    const $net2 = $step.$(".s2 x-net");
    $net2.addNet(pyramid1.faces, pyramid1.hinges);
    const $net3 = $step.$(".s3 x-net");
    $net3.addNet(triangularPrism.faces, triangularPrism.hinges, 0.4);
    $slider.on("move", (n) => {
      const progress = n / 1e3;
      $net1.fold(progress);
      $net2.fold(progress);
      $net3.fold(progress);
    });
  }
  function cubeNetDraw($step) {
    const $p = $step.$("x-polypad");
    $p.setActiveTool("pen");
    $p.tools.pen.brush = "straight";
  }
  function dieFaces1($step) {
    const netPositions = [
      { pos: [0, 0], opposite: 5 },
      { pos: [0, 1], opposite: 3 },
      { pos: [1, 1], opposite: 4 },
      { pos: [2, 1], opposite: 1 },
      { pos: [3, 1], opposite: 2 },
      { pos: [1, 2], opposite: 0 }
    ];
    setupDieFacesPlacement($step, netPositions);
  }
  function dieFaces2($step) {
    const netPositions = [
      { pos: [1, 0], opposite: 5 },
      { pos: [0, 1], opposite: 3 },
      { pos: [1, 1], opposite: 4 },
      { pos: [2, 1], opposite: 1 },
      { pos: [3, 1], opposite: 2 },
      { pos: [2, 2], opposite: 0 }
    ];
    setupDieFacesPlacement($step, netPositions);
  }
  function soccerNet($step) {
    const $n = $step.$("x-net");
    const $slider = $step.$("x-slider");
    $n.addNet(truncatedIcosahedron.faces, truncatedIcosahedron.hinges, 0.25);
    $slider.on("move", (n) => {
      const progress = n / 1e3;
      $n.fold(progress);
    });
  }
  function honeycombIntro($step) {
    const $p = $step.$("x-polyhedron");
    $p.addMesh(() => {
      $p.addLabel("Hexagonal Base", [0, 0.56, 0]);
    });
  }
  function netsProperties($step) {
    const $swipe = $step.$("x-binary-swipe");
    $swipe.on("complete", () => $step.score("all-swiped"));
  }
  function voxelBuilderQuestion($step) {
    return __async(this, null, function* () {
      const $voxel = $step.$("x-voxel-painter");
      const $button = $voxel.$(".icon-btn");
      const $targetVolume = parseInt($button.attr("volume"));
      const $targetSurface = parseInt($button.attr("surfaceArea"));
      $button.on("click", () => {
        const surface = $voxel.getSurfaceArea();
        const volume = $voxel.getVolume();
        if (surface === $targetSurface && volume === $targetVolume) {
          $step.score("problem");
          $step.addHint("correct");
        } else if (surface === $targetSurface) {
          $step.addHint("voxel-volume", { variables: { a: "" + volume, b: "" + $targetVolume } });
        } else if (volume === $targetVolume) {
          $step.addHint("voxel-surface", { variables: { a: "" + surface, b: "" + $targetSurface } });
        } else {
          $step.addHint("voxel-error", { variables: { a: "" + $targetVolume, b: "" + $targetSurface } });
        }
      });
    });
  }
  return __toCommonJS(functions_exports);
})();