/* (c) Mathigon, generated by Mathigon Studio */
"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp(target, key, result);
    return result;
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var __await = function(promise, isYieldStar) {
    this[0] = promise;
    this[1] = isYieldStar;
  };
  var __yieldStar = (value) => {
    var obj = value[__knownSymbol("asyncIterator")], isAwait = false, method, it = {};
    if (obj == null) {
      obj = value[__knownSymbol("iterator")]();
      method = (k) => it[k] = (x) => obj[k](x);
    } else {
      obj = obj.call(value);
      method = (k) => it[k] = (v) => {
        if (isAwait) {
          isAwait = false;
          if (k === "throw") throw v;
          return v;
        }
        isAwait = true;
        return {
          done: false,
          value: new __await(new Promise((resolve) => {
            var x = obj[k](v);
            if (!(x instanceof Object)) __typeError("Object expected");
            resolve(x);
          }), 1)
        };
      };
    }
    return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
      throw x;
    }, "return" in obj && method("return"), it;
  };

  // node_modules/@mathigon/core/dist/index.esm.js
  function uid(n = 10) {
    return Math.random().toString(36).substr(2, n);
  }
  function isOneOf(x, ...values) {
    return values.includes(x);
  }
  var defaultMerge = (a2, b2) => a2.concat(b2);
  function deepExtend(obj1, obj2, arrayMergeFn = defaultMerge) {
    for (const i of Object.keys(obj2)) {
      if (i in obj1 && Array.isArray(obj1[i]) && Array.isArray(obj2[i])) {
        obj1[i] = arrayMergeFn(obj1[i], obj2[i]);
      } else if (i in obj1 && obj1[i] instanceof Object && obj2[i] instanceof Object) {
        deepExtend(obj1[i], obj2[i]);
      } else {
        obj1[i] = obj2[i];
      }
    }
  }
  function delay(fn, t = 0) {
    if (t) {
      return +setTimeout(fn, t);
    } else {
      fn();
      return 0;
    }
  }
  function wait(t) {
    return new Promise((resolve) => setTimeout(resolve, t));
  }
  function defer() {
    let resolve = () => void 0;
    let reject = () => void 0;
    const promise = new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    });
    promise.catch((error) => error);
    return { promise, resolve, reject };
  }
  var CacheError = class extends Error {
    constructor(data) {
      super("[Cache Error]");
      this.data = data;
    }
  };
  function cache(fn) {
    const cached = /* @__PURE__ */ new Map();
    return function(...args) {
      const argString = args.join("--");
      if (!cached.has(argString)) {
        try {
          cached.set(argString, fn(...args));
        } catch (e) {
          cached.set(argString, new CacheError(e));
        }
      }
      const value = cached.get(argString);
      if (value instanceof CacheError) throw value.data;
      return value;
    };
  }
  function throttle(fn, t = 0, forceDelay = false) {
    let delay2 = false;
    let repeat2 = false;
    return (...args) => {
      if (delay2) {
        repeat2 = true;
      } else {
        if (forceDelay) {
          repeat2 = true;
        } else {
          fn(...args);
        }
        delay2 = true;
        setTimeout(() => {
          if (repeat2) fn(...args);
          delay2 = repeat2 = false;
        }, t);
      }
    };
  }
  function reviver(allowed) {
    return function(key, value) {
      if (!key || Array.isArray(this) || allowed.includes(key)) return value;
    };
  }
  function safeToJSON(str, fallback, allowedKeys) {
    if (!str) return fallback;
    try {
      return JSON.parse(str, allowedKeys ? reviver(allowedKeys) : void 0) || fallback;
    } catch (e) {
      return fallback;
    }
  }
  function repeat(value, n) {
    return new Array(n).fill(value);
  }
  function repeat2D(value, x, y) {
    const result = [];
    for (let i = 0; i < x; ++i) {
      result.push(repeat(value, y));
    }
    return result;
  }
  function tabulate(fn, n) {
    const result = [];
    for (let i = 0; i < n; ++i) {
      result.push(fn(i));
    }
    return result;
  }
  function tabulate2D(fn, x, y) {
    const result = [];
    for (let i = 0; i < x; ++i) {
      const row = [];
      for (let j = 0; j < y; ++j) {
        row.push(fn(i, j));
      }
      result.push(row);
    }
    return result;
  }
  function list(a2, b2, step = 1) {
    const arr = [];
    if (b2 === void 0 && a2 >= 0) {
      for (let i = 0; i < a2; i += step) arr.push(i);
    } else if (b2 === void 0) {
      for (let i = 0; i > a2; i -= step) arr.push(i);
    } else if (a2 <= b2) {
      for (let i = a2; i <= b2; i += step) arr.push(i);
    } else {
      for (let i = a2; i >= b2; i -= step) arr.push(i);
    }
    return arr;
  }
  function last(array, i = 0) {
    return array[array.length - 1 - i];
  }
  function total(array) {
    return array.reduce((t, v) => t + v, 0);
  }
  function sortBy(array, fn, reverse = false) {
    return array.slice(0).sort((a2, b2) => {
      const x = fn(a2);
      const y = fn(b2);
      return x < y ? reverse ? 1 : -1 : x > y ? reverse ? -1 : 1 : 0;
    });
  }
  function loop(array) {
    let i = 0;
    return () => array[i++ % array.length];
  }
  function unique(array) {
    return array.filter((a2, i) => array.indexOf(a2) === i);
  }
  function flatten(array) {
    return array.reduce((a2, b2) => a2.concat(Array.isArray(b2) ? flatten(b2) : b2), []);
  }
  function cumulative(array) {
    let total2 = 0;
    return array.map((a2) => total2 += a2);
  }
  function chunk(array, n) {
    const chunks = [];
    for (let i = 0; i < array.length; i += n) {
      chunks.push(array.slice(i, i + n));
    }
    return chunks;
  }
  function join(...arrays) {
    return arrays.reduce((a2, x) => a2.concat(x), []);
  }
  function words(str, divider = /\s+/) {
    if (!str) return [];
    return str.trim().split(divider);
  }
  function toCamelCase(str) {
    return str.toLowerCase().replace(/^-/, "").replace(/-(.)/g, (_, g) => g.toUpperCase());
  }
  var EventTarget = class {
    constructor() {
      this.events = /* @__PURE__ */ new Map();
    }
    /** Adds an event listener for one or more events. */
    on(events, fn) {
      for (const e of words(events)) {
        if (!this.events.has(e)) this.events.set(e, []);
        this.events.get(e).push(fn);
      }
    }
    /** Adds a one-time event listener to one or more events. */
    one(events, fn) {
      const callback = (e) => {
        this.off(events, callback);
        fn(e);
      };
      this.on(events, callback);
    }
    /** Removes an event listener from one or more events. */
    off(events, fn) {
      for (const e of words(events)) {
        if (this.events.has(e)) {
          this.events.set(e, this.events.get(e).filter((x) => x !== fn));
        }
      }
    }
    /** Triggers one or more events, and executes all bound event listeners. */
    trigger(events, arg) {
      for (const e of words(events)) {
        if (this.events.has(e)) {
          for (const callback of this.events.get(e)) {
            callback(arg);
          }
        }
      }
    }
  };

  // node_modules/@mathigon/fermat/dist/index.esm.js
  var __defProp2 = Object.defineProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var PRECISION = 1e-6;
  function nearlyEquals(a2, b2, t = PRECISION) {
    if (isNaN(a2) || isNaN(b2)) return false;
    return Math.abs(a2 - b2) < t;
  }
  function isBetween(value, a2, b2, t = PRECISION) {
    if (a2 > b2) [a2, b2] = [b2, a2];
    return value > a2 + t && value < b2 - t;
  }
  var SPECIAL_DECIMAL = /^-?0,[0-9]+$/;
  var POINT_DECIMAL = /^-?([0-9]+(,[0-9]{3})*)?\.?[0-9]*$/;
  var COMMA_DECIMAL = /^-?[0-9]+(\.[0-9]{3})*,?[0-9]*$/;
  function parseNumber(str) {
    str = str.replace(/^â€“/, "-").trim();
    if (!str || str.match(/[^0-9.,-]/)) return NaN;
    if (SPECIAL_DECIMAL.test(str)) {
      return parseFloat(str.replace(/,/, "."));
    }
    if (POINT_DECIMAL.test(str)) {
      return parseFloat(str.replace(/,/g, ""));
    }
    if (COMMA_DECIMAL.test(str)) {
      return parseFloat(str.replace(/\./g, "").replace(/,/, "."));
    }
    return NaN;
  }
  var ONES = [
    "",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "ten",
    "eleven",
    "twelve",
    "thirteen",
    "fourteen",
    "fifteen",
    "sixteen",
    "seventeen",
    "eighteen",
    "nineteen"
  ];
  var TENS = [
    "",
    "",
    "twenty",
    "thirty",
    "forty",
    "fifty",
    "sixty",
    "seventy",
    "eighty",
    "ninety"
  ];
  var MULTIPLIERS = [
    "",
    " thousand",
    " million",
    " billion",
    " trillion",
    " quadrillion",
    " quintillion",
    " sextillion"
  ];
  function toWordSingle(number) {
    const [h, t, o] = number.split("");
    const hundreds = h === "0" ? "" : ` ${ONES[+h]} hundred`;
    if (t + o === "00") return hundreds;
    if (+t < 2) return `${hundreds} ${ONES[+(t + o)]}`;
    if (o === "0") return `${hundreds} ${TENS[+t]}`;
    return `${hundreds} ${TENS[+t]}-${ONES[+o]}`;
  }
  function toWord(n) {
    if (n === 0) return "zero";
    const str = Math.round(Math.abs(n)).toString();
    const chunks = Math.ceil(str.length / 3);
    const padded = str.padStart(3 * chunks, "0");
    let result = "";
    for (let i = 0; i < chunks; i += 1) {
      const chunk2 = padded.substr(i * 3, 3);
      if (chunk2 === "000") continue;
      result += toWordSingle(chunk2) + MULTIPLIERS[chunks - 1 - i];
    }
    return result.trim();
  }
  function round(n, precision = 0) {
    const factor = Math.pow(10, precision);
    return Math.round(n * factor) / factor;
  }
  function roundTo(n, increment = 1) {
    return Math.round(n / increment) * increment;
  }
  function clamp(x, min = -Infinity, max = Infinity) {
    return Math.min(max, Math.max(min, x));
  }
  function lerp(a2, b2, t = 0.5) {
    return a2 + (b2 - a2) * t;
  }
  function square(x) {
    return x * x;
  }
  function mod(a2, m) {
    return (a2 % m + m) % m;
  }
  function subsets(array, length = 0) {
    const copy = array.slice(0);
    const results = subsetsHelper(copy);
    return length ? results.filter((x) => x.length === length) : results;
  }
  function subsetsHelper(array) {
    if (array.length === 1) return [[], array];
    const last2 = array.pop();
    const subsets2 = subsetsHelper(array);
    const result = [];
    for (const s of subsets2) {
      result.push(s, [...s, last2]);
    }
    return result;
  }
  function gcd(...numbers) {
    const [first, ...rest] = numbers;
    if (rest.length > 1) return gcd(first, gcd(...rest));
    let a2 = Math.abs(first);
    let b2 = Math.abs(rest[0]);
    while (b2) [a2, b2] = [b2, a2 % b2];
    return a2;
  }
  function lcm(...numbers) {
    const [first, ...rest] = numbers;
    if (rest.length > 1) return lcm(first, lcm(...rest));
    return Math.abs(first * rest[0]) / gcd(first, rest[0]);
  }
  var matrix_exports = {};
  __export(matrix_exports, {
    determinant: () => determinant,
    fill: () => fill,
    identity: () => identity,
    inverse: () => inverse,
    product: () => product,
    reflection: () => reflection,
    rotation: () => rotation,
    scalarProduct: () => scalarProduct,
    shear: () => shear,
    sum: () => sum,
    transpose: () => transpose
  });
  function fill(value, x, y) {
    return repeat2D(value, x, y);
  }
  function identity(n = 2) {
    const x = fill(0, n, n);
    for (let i = 0; i < n; ++i) x[i][i] = 1;
    return x;
  }
  function rotation(angle) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);
    return [[cos, -sin], [sin, cos]];
  }
  function shear(lambda) {
    return [[1, lambda], [0, 1]];
  }
  function reflection(angle) {
    const sin = Math.sin(2 * angle);
    const cos = Math.cos(2 * angle);
    return [[cos, sin], [sin, -cos]];
  }
  function sum(...matrices) {
    const [M1, ...rest] = matrices;
    const M2 = rest.length > 1 ? sum(...rest) : rest[0];
    if (M1.length !== M2.length || M1[0].length !== M2[0].length) {
      throw new Error("Matrix sizes don\u2019t match");
    }
    const S = [];
    for (let i = 0; i < M1.length; ++i) {
      const row = [];
      for (let j = 0; j < M1[i].length; ++j) {
        row.push(M1[i][j] + M2[i][j]);
      }
      S.push(row);
    }
    return S;
  }
  function scalarProduct(M, v) {
    return M.map((row) => row.map((x) => x * v));
  }
  function product(...matrices) {
    const [M1, ...rest] = matrices;
    const M2 = rest.length > 1 ? product(...rest) : rest[0];
    if (M1[0].length !== M2.length) {
      throw new Error("Matrix sizes don\u2019t match.");
    }
    const P2 = [];
    for (let i = 0; i < M1.length; ++i) {
      const row = [];
      for (let j = 0; j < M2[0].length; ++j) {
        let value = 0;
        for (let k = 0; k < M2.length; ++k) {
          value += M1[i][k] * M2[k][j];
        }
        row.push(value);
      }
      P2.push(row);
    }
    return P2;
  }
  function transpose(M) {
    const T = [];
    for (let j = 0; j < M[0].length; ++j) {
      const row = [];
      for (let i = 0; i < M.length; ++i) {
        row.push(M[i][j]);
      }
      T.push(row);
    }
    return T;
  }
  function determinant(M) {
    if (M.length !== M[0].length) throw new Error("Not a square matrix.");
    const n = M.length;
    if (n === 1) return M[0][0];
    if (n === 2) return M[0][0] * M[1][1] - M[0][1] * M[1][0];
    let det = 0;
    for (let j = 0; j < n; ++j) {
      let diagLeft = M[0][j];
      let diagRight = M[0][j];
      for (let i = 1; i < n; ++i) {
        diagRight *= M[i][(j + i) % n];
        diagLeft *= M[i][(j - i + n) % n];
      }
      det += diagRight - diagLeft;
    }
    return det;
  }
  function inverse(M) {
    const n = M.length;
    if (n !== M[0].length) throw new Error("Not a square matrix.");
    const I = identity(n);
    const C = tabulate2D((x, y) => M[x][y], n, n);
    for (let i = 0; i < n; ++i) {
      let e = C[i][i];
      if (nearlyEquals(e, 0)) {
        for (let ii = i + 1; ii < n; ++ii) {
          if (C[ii][i] !== 0) {
            for (let j = 0; j < n; ++j) {
              [C[ii][j], C[i][j]] = [C[i][j], C[ii][j]];
              [I[ii][j], I[i][j]] = [I[i][j], I[ii][j]];
            }
            break;
          }
        }
        e = C[i][i];
        if (nearlyEquals(e, 0)) throw new Error("Matrix not invertible.");
      }
      for (let j = 0; j < n; ++j) {
        C[i][j] = C[i][j] / e;
        I[i][j] = I[i][j] / e;
      }
      for (let ii = 0; ii < n; ++ii) {
        if (ii === i) continue;
        const f = C[ii][i];
        for (let j = 0; j < n; ++j) {
          C[ii][j] -= f * C[i][j];
          I[ii][j] -= f * I[i][j];
        }
      }
    }
    return I;
  }
  var random_exports = {};
  __export(random_exports, {
    bernoulli: () => bernoulli,
    binomial: () => binomial2,
    cauchy: () => cauchy,
    chiCDF: () => chiCDF,
    exponential: () => exponential,
    find: () => find,
    geometric: () => geometric,
    integer: () => integer,
    integrate: () => integrate,
    normal: () => normal,
    normalPDF: () => normalPDF,
    poisson: () => poisson,
    shuffle: () => shuffle,
    smart: () => smart,
    uniform: () => uniform,
    weighted: () => weighted
  });
  function shuffle(a2) {
    a2 = a2.slice(0);
    for (let i = a2.length - 1; i > 0; --i) {
      const j = Math.floor(Math.random() * (i + 1));
      [a2[i], a2[j]] = [a2[j], a2[i]];
    }
    return a2;
  }
  function integer(a2, b2) {
    const start = b2 === void 0 ? 0 : a2;
    const length = b2 === void 0 ? a2 : b2 - a2 + 1;
    return start + Math.floor(length * Math.random());
  }
  function weighted(weights) {
    const x = Math.random() * total(weights);
    let cum = 0;
    return weights.findIndex((w) => (cum += w) >= x);
  }
  function find(items) {
    return items[Math.floor(items.length * Math.random())];
  }
  var SMART_RANDOM_CACHE = /* @__PURE__ */ new Map();
  function smart(n, id) {
    if (!id) id = uid();
    if (!SMART_RANDOM_CACHE.has(id)) SMART_RANDOM_CACHE.set(id, repeat(1, n));
    const cache2 = SMART_RANDOM_CACHE.get(id);
    const x = weighted(cache2.map((x2) => x2 * x2));
    cache2[x] -= 1;
    if (cache2[x] <= 0) SMART_RANDOM_CACHE.set(id, cache2.map((x2) => x2 + 1));
    return x;
  }
  function bernoulli(p = 0.5) {
    return Math.random() < p ? 1 : 0;
  }
  function binomial2(n = 1, p = 0.5) {
    let t = 0;
    for (let i = 0; i < n; ++i) t += bernoulli(p);
    return t;
  }
  function poisson(l = 1) {
    if (l <= 0) return 0;
    const L = Math.exp(-l);
    let p = 1;
    let k = 0;
    for (; p > L; ++k) p *= Math.random();
    return k - 1;
  }
  function uniform(a2 = 0, b2 = 1) {
    return a2 + (b2 - a2) * Math.random();
  }
  function normal(m = 0, v = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const rand = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return rand * Math.sqrt(v) + m;
  }
  function exponential(l = 1) {
    return l <= 0 ? 0 : -Math.log(Math.random()) / l;
  }
  function geometric(p = 0.5) {
    if (p <= 0 || p > 1) return void 0;
    return Math.floor(Math.log(Math.random()) / Math.log(1 - p));
  }
  function cauchy() {
    let rr;
    let v1;
    let v2;
    do {
      v1 = 2 * Math.random() - 1;
      v2 = 2 * Math.random() - 1;
      rr = v1 * v1 + v2 * v2;
    } while (rr >= 1);
    return v1 / v2;
  }
  function normalPDF(x, m = 1, v = 0) {
    return Math.exp(-((x - m) ** 2) / (2 * v)) / Math.sqrt(2 * Math.PI * v);
  }
  var G = 7;
  var P = [
    0.9999999999998099,
    676.5203681218851,
    -1259.1392167224028,
    771.3234287776531,
    -176.6150291621406,
    12.507343278686905,
    -0.13857109526572012,
    9984369578019572e-21,
    15056327351493116e-23
  ];
  function gamma(z) {
    if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    z -= 1;
    let x = P[0];
    for (let i = 1; i < G + 2; i++) x += P[i] / (z + i);
    const t = z + G + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
  }
  function integrate(fn, xMin, xMax, dx = 1) {
    let result = 0;
    for (let x = xMin; x < xMax; x += dx) {
      result += fn(x) * dx || 0;
    }
    return result;
  }
  function chiCDF(chi, deg) {
    const int2 = integrate((t) => Math.pow(t, (deg - 2) / 2) * Math.exp(-t / 2), 0, chi);
    return 1 - int2 / Math.pow(2, deg / 2) / gamma(deg / 2);
  }
  var regression_exports = {};
  __export(regression_exports, {
    bestPolynomial: () => bestPolynomial,
    coefficient: () => coefficient,
    exponential: () => exponential2,
    linear: () => linear,
    logarithmic: () => logarithmic,
    polynomial: () => polynomial2,
    power: () => power
  });
  function evaluatePolynomial(regression, x) {
    let xs = 1;
    let t = regression[0];
    for (let i = 1; i < regression.length; ++i) {
      xs *= x;
      t += xs * regression[i];
    }
    return t;
  }
  function linear(data, throughOrigin = false) {
    let sX = 0;
    let sY = 0;
    let sXX = 0;
    let sXY = 0;
    const len = data.length;
    for (let n = 0; n < len; n++) {
      sX += data[n][0];
      sY += data[n][1];
      sXX += data[n][0] * data[n][0];
      sXY += data[n][0] * data[n][1];
    }
    if (throughOrigin) {
      const gradient2 = sXY / sXX;
      return [0, gradient2];
    }
    const gradient = (len * sXY - sX * sY) / (len * sXX - sX * sX);
    const intercept = sY / len - gradient * sX / len;
    return [intercept, gradient];
  }
  function exponential2(data) {
    const sum2 = [0, 0, 0, 0, 0, 0];
    for (const d of data) {
      sum2[0] += d[0];
      sum2[1] += d[1];
      sum2[2] += d[0] * d[0] * d[1];
      sum2[3] += d[1] * Math.log(d[1]);
      sum2[4] += d[0] * d[1] * Math.log(d[1]);
      sum2[5] += d[0] * d[1];
    }
    const denominator = sum2[1] * sum2[2] - sum2[5] * sum2[5];
    const a2 = Math.exp((sum2[2] * sum2[3] - sum2[5] * sum2[4]) / denominator);
    const b2 = (sum2[1] * sum2[4] - sum2[5] * sum2[3]) / denominator;
    return [a2, b2];
  }
  function logarithmic(data) {
    const sum2 = [0, 0, 0, 0];
    const len = data.length;
    for (const d of data) {
      sum2[0] += Math.log(d[0]);
      sum2[1] += d[1] * Math.log(d[0]);
      sum2[2] += d[1];
      sum2[3] += Math.pow(Math.log(d[0]), 2);
    }
    const b2 = (len * sum2[1] - sum2[2] * sum2[0]) / (len * sum2[3] - sum2[0] * sum2[0]);
    const a2 = (sum2[2] - b2 * sum2[0]) / len;
    return [a2, b2];
  }
  function power(data) {
    const sum2 = [0, 0, 0, 0];
    const len = data.length;
    for (const d of data) {
      sum2[0] += Math.log(d[0]);
      sum2[1] += Math.log(d[1]) * Math.log(d[0]);
      sum2[2] += Math.log(d[1]);
      sum2[3] += Math.pow(Math.log(d[0]), 2);
    }
    const b2 = (len * sum2[1] - sum2[2] * sum2[0]) / (len * sum2[3] - sum2[0] * sum2[0]);
    const a2 = Math.exp((sum2[2] - b2 * sum2[0]) / len);
    return [a2, b2];
  }
  function polynomial2(data, order = 2) {
    const X = data.map((d) => list(order + 1).map((p) => Math.pow(d[0], p)));
    const XT = transpose(X);
    const y = data.map((d) => [d[1]]);
    const XTX = product(XT, X);
    const inv = inverse(XTX);
    const r = product(inv, XT, y);
    return r.map((x) => x[0]);
  }
  function coefficient(data, fn) {
    const total4 = data.reduce((sum2, d) => sum2 + d[1], 0);
    const mean2 = total4 / data.length;
    const ssyy = data.reduce((sum2, d) => sum2 + (d[1] - mean2) ** 2, 0);
    const sse = data.reduce((sum2, d) => sum2 + (d[1] - fn(d[0])) ** 2, 0);
    return 1 - sse / ssyy;
  }
  function bestPolynomial(data, threshold = 0.85, maxOrder = 8) {
    if (data.length <= 1) return void 0;
    for (let i = 1; i < maxOrder; ++i) {
      const reg = polynomial2(data, i);
      const fn = (x) => evaluatePolynomial(reg, x);
      const coeff = coefficient(data, fn);
      if (coeff >= threshold) return { order: i, coefficients: reg, fn };
    }
    return void 0;
  }

  // node_modules/@mathigon/euclid/dist/index.esm.js
  var TWO_PI = 2 * Math.PI;
  function rad(p, c) {
    const a2 = Math.atan2(p.y - (c ? c.y : 0), p.x - (c ? c.x : 0));
    return mod(a2, TWO_PI);
  }
  function findClosest(p, items) {
    let q = void 0;
    let d = Infinity;
    let index = -1;
    for (const [i, e] of items.entries()) {
      const q1 = e.project(p);
      const d1 = Point.distance(p, q1);
      if (d1 < d) {
        q = q1;
        d = d1;
        index = i;
      }
    }
    return q ? [q, index] : void 0;
  }
  var Point = class _Point {
    constructor(x = 0, y = 0) {
      this.x = x;
      this.y = y;
      this.type = "point";
    }
    get unitVector() {
      if (nearlyEquals(this.length, 0)) return new _Point(1, 0);
      return this.scale(1 / this.length);
    }
    get length() {
      return Math.sqrt(this.x ** 2 + this.y ** 2);
    }
    get inverse() {
      return new _Point(-this.x, -this.y);
    }
    get flip() {
      return new _Point(this.y, this.x);
    }
    get perpendicular() {
      return new _Point(-this.y, this.x);
    }
    get array() {
      return [this.x, this.y];
    }
    /** Finds the perpendicular distance between this point and a line. */
    distanceFromLine(l) {
      return _Point.distance(this, l.project(this));
    }
    /** Clamps this point to specific bounds. */
    clamp(bounds, padding = 0) {
      const x = clamp(this.x, bounds.xMin + padding, bounds.xMax - padding);
      const y = clamp(this.y, bounds.yMin + padding, bounds.yMax - padding);
      return new _Point(x, y);
    }
    changeCoordinates(originCoords, targetCoords) {
      const x = targetCoords.xMin + (this.x - originCoords.xMin) / originCoords.dx * targetCoords.dx;
      const y = targetCoords.yMin + (this.y - originCoords.yMin) / originCoords.dy * targetCoords.dy;
      return new _Point(x, y);
    }
    add(p) {
      return _Point.sum(this, p);
    }
    subtract(p) {
      return _Point.difference(this, p);
    }
    round(inc = 1) {
      return new _Point(roundTo(this.x, inc), roundTo(this.y, inc));
    }
    floor() {
      return new _Point(Math.floor(this.x), Math.floor(this.y));
    }
    mod(x, y = x) {
      return new _Point(this.x % x, this.y % y);
    }
    angle(c = ORIGIN) {
      return rad(this, c);
    }
    // Snap to the x or y values of another point
    snap(p, tolerance = 5) {
      if (nearlyEquals(this.x, p.x, tolerance)) return new _Point(p.x, this.y);
      if (nearlyEquals(this.y, p.y, tolerance)) return new _Point(this.x, p.y);
      return this;
    }
    /** Calculates the average of multiple points. */
    static average(...points) {
      const x = total(points.map((p) => p.x)) / points.length;
      const y = total(points.map((p) => p.y)) / points.length;
      return new _Point(x, y);
    }
    /** Calculates the dot product of two points p1 and p2. */
    static dot(p1, p2) {
      return p1.x * p2.x + p1.y * p2.y;
    }
    static sum(p1, p2) {
      return new _Point(p1.x + p2.x, p1.y + p2.y);
    }
    static difference(p1, p2) {
      return new _Point(p1.x - p2.x, p1.y - p2.y);
    }
    /** Returns the Euclidean distance between two points p1 and p2. */
    static distance(p1, p2) {
      return Math.sqrt(square(p1.x - p2.x) + square(p1.y - p2.y));
    }
    /** Returns the Manhattan distance between two points p1 and p2. */
    static manhattan(p1, p2) {
      return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
    }
    /** Interpolates two points p1 and p2 by a factor of t. */
    static interpolate(p1, p2, t = 0.5) {
      return new _Point(lerp(p1.x, p2.x, t), lerp(p1.y, p2.y, t));
    }
    /** Interpolates a list of multiple points. */
    static interpolateList(points, t = 0.5) {
      const n = points.length - 1;
      const a2 = Math.floor(clamp(t, 0, 1) * n);
      return _Point.interpolate(points[a2], points[a2 + 1], n * t - a2);
    }
    /** Creates a point from polar coordinates. */
    static fromPolar(angle, r = 1) {
      return new _Point(r * Math.cos(angle), r * Math.sin(angle));
    }
    static random(b2) {
      const x = random_exports.uniform(b2.xMin, b2.xMax);
      const y = random_exports.uniform(b2.yMin, b2.yMax);
      return new _Point(x, y);
    }
    static equals(p1, p2, precision) {
      return nearlyEquals(p1.x, p2.x, precision) && nearlyEquals(p1.y, p2.y, precision);
    }
    /** Check if p1, p2 and p3 lie on a straight line. */
    static colinear(p1, p2, p3, tolerance) {
      const dx1 = p1.x - p2.x;
      const dy1 = p1.y - p2.y;
      const dx2 = p2.x - p3.x;
      const dy2 = p2.y - p3.y;
      return nearlyEquals(dx1 * dy2, dx2 * dy1, tolerance);
    }
    // ---------------------------------------------------------------------------
    /** Transforms this point using a 2x3 matrix m. */
    transform(m) {
      const x = m[0][0] * this.x + m[0][1] * this.y + m[0][2];
      const y = m[1][0] * this.x + m[1][1] * this.y + m[1][2];
      return new _Point(x, y);
    }
    /** Rotates this point by a given angle (in radians) around point `c`. */
    rotate(angle, c = ORIGIN) {
      if (nearlyEquals(angle, 0)) return this;
      const x0 = this.x - c.x;
      const y0 = this.y - c.y;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const x = x0 * cos - y0 * sin + c.x;
      const y = x0 * sin + y0 * cos + c.y;
      return new _Point(x, y);
    }
    /** Reflects this point across a line l. */
    reflect(l) {
      const v = l.p2.x - l.p1.x;
      const w = l.p2.y - l.p1.y;
      const x0 = this.x - l.p1.x;
      const y0 = this.y - l.p1.y;
      const mu = (v * y0 - w * x0) / (v * v + w * w);
      const x = this.x + 2 * mu * w;
      const y = this.y - 2 * mu * v;
      return new _Point(x, y);
    }
    scale(sx, sy = sx) {
      return new _Point(this.x * sx, this.y * sy);
    }
    shift(x, y = x) {
      return new _Point(this.x + x, this.y + y);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, precision) {
      return _Point.equals(this, other, precision);
    }
    toString() {
      return `point(${this.x},${this.y})`;
    }
  };
  var ORIGIN = new Point(0, 0);
  function isPolygonLike(shape) {
    return ["polygon", "polyline", "rectangle", "triangle"].includes(shape.type);
  }
  function isPolygon(shape) {
    return ["polygon", "triangle"].includes(shape.type);
  }
  function isPolyline(shape) {
    return shape.type === "polyline";
  }
  function isRectangle(shape) {
    return shape.type === "rectangle";
  }
  function isLineLike(shape) {
    return ["line", "ray", "segment"].includes(shape.type);
  }
  function isLine(shape) {
    return shape.type === "line";
  }
  function isRay(shape) {
    return shape.type === "ray";
  }
  function isSegment(shape) {
    return shape.type === "segment";
  }
  function isCircle(shape) {
    return shape.type === "circle";
  }
  function isEllipse(shape) {
    return shape.type === "ellipse";
  }
  function isArc(shape) {
    return shape.type === "arc";
  }
  function isSector(shape) {
    return shape.type === "sector";
  }
  function isAngle(shape) {
    return shape.type === "angle";
  }
  var Line = class _Line {
    constructor(p1, p2) {
      this.p1 = p1;
      this.p2 = p2;
      this.type = "line";
    }
    /* The distance between the two points defining this line. */
    get length() {
      return Point.distance(this.p1, this.p2);
    }
    /* The squared distance between the two points defining this line. */
    get lengthSquared() {
      return (this.p1.x - this.p2.x) ** 2 + (this.p1.y - this.p2.y) ** 2;
    }
    /** The midpoint of this line. */
    get midpoint() {
      return Point.average(this.p1, this.p2);
    }
    /** The slope of this line. */
    get slope() {
      return (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x);
    }
    /** The y-axis intercept of this line. */
    get intercept() {
      return this.p1.y - this.slope * this.p1.x;
    }
    /** The angle formed between this line and the x-axis. */
    get angle() {
      return rad(this.p2, this.p1);
    }
    /** The point representing a unit vector along this line. */
    get unitVector() {
      return this.p2.subtract(this.p1).unitVector;
    }
    /** The point representing the perpendicular vector of this line. */
    get perpendicularVector() {
      return new Point(this.p2.y - this.p1.y, this.p1.x - this.p2.x).unitVector;
    }
    /** Finds the line parallel to this one, going through point p. */
    parallel(p) {
      return new _Line(p, p.add(this.p2).subtract(this.p1));
    }
    /** Finds the line perpendicular to this one, going through point p. */
    perpendicular(p) {
      const q = this.line.project(p);
      if (Point.equals(p, q)) return new _Line(q, q.add(this.perpendicularVector.scale(this.length / 2)));
      return new _Line(q, p);
    }
    /** The perpendicular bisector of this line. */
    get perpendicularBisector() {
      return this.perpendicular(this.midpoint);
    }
    /** Squared distance between a point and a line. */
    distanceSquared(p) {
      const proj = this.project(p);
      return (p.x - proj.x) ** 2 + (p.y - proj.y) ** 2;
    }
    get line() {
      return this.type === "line" ? this : new _Line(this.p1, this.p2);
    }
    get ray() {
      return isRay(this) ? this : new Ray(this.p1, this.p2);
    }
    get segment() {
      return isSegment(this) ? this : new Segment(this.p1, this.p2);
    }
    // ---------------------------------------------------------------------------
    /** Signed distance along the line (opposite of .at()). */
    offset(p) {
      const a2 = Point.difference(this.p2, this.p1);
      const b2 = Point.difference(p, this.p1);
      return Point.dot(a2, b2) / this.lengthSquared;
    }
    /** Projects a point `p` onto this line. */
    project(p) {
      return this.at(this.offset(p));
    }
    /** Returns which side of this line a point p is on (or 0 on the line). */
    side(p, tolerance) {
      const a2 = Point.difference(this.p2, this.p1);
      const b2 = Point.difference(p, this.p1);
      const d = b2.x * a2.y - b2.y * a2.x;
      return nearlyEquals(d, 0, tolerance) ? 0 : Math.sign(d);
    }
    /** Checks if a point p lies on this line. */
    contains(p, tolerance) {
      return this.side(p, tolerance) === 0;
    }
    /** Gets the point at a specific offset along the line (opposite of .offset()). */
    at(t) {
      return Point.interpolate(this.p1, this.p2, t);
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return new this.constructor(this.p1.transform(m), this.p2.transform(m));
    }
    /** Rotates this line by a given angle (in radians), optionally around point `c`. */
    rotate(a2, c = ORIGIN) {
      if (nearlyEquals(a2, 0)) return this;
      return new this.constructor(this.p1.rotate(a2, c), this.p2.rotate(a2, c));
    }
    reflect(l) {
      return new this.constructor(this.p1.reflect(l), this.p2.reflect(l));
    }
    scale(sx, sy = sx) {
      return new this.constructor(this.p1.scale(sx, sy), this.p2.scale(sx, sy));
    }
    shift(x, y = x) {
      return new this.constructor(this.p1.shift(x, y), this.p2.shift(x, y));
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, tolerance) {
      return this.contains(other.p1, tolerance) && this.contains(other.p2, tolerance);
    }
    toString() {
      return `line(${this.p1},${this.p2})`;
    }
  };
  var Ray = class extends Line {
    constructor() {
      super(...arguments);
      this.type = "ray";
    }
    equals(other, tolerance) {
      if (other.type !== "ray") return false;
      if (!this.p1.equals(other.p1, tolerance)) return false;
      if (this.p2.equals(other.p2, tolerance)) return true;
      return other.contains(this.p2, tolerance) || this.contains(other.p2, tolerance);
    }
    contains(p, tolerance) {
      if (!super.contains(p, tolerance)) return false;
      const offset = this.offset(p);
      return nearlyEquals(offset, 0, tolerance) || offset > 0;
    }
    toString() {
      return `ray(${this.p1},${this.p2})`;
    }
  };
  var Segment = class _Segment extends Line {
    constructor() {
      super(...arguments);
      this.type = "segment";
    }
    contains(p, tolerance) {
      if (!super.contains(p, tolerance)) return false;
      if (this.p1.equals(p, tolerance) || this.p2.equals(p, tolerance)) return true;
      if (nearlyEquals(this.p1.x, this.p2.x, tolerance)) {
        return isBetween(p.y, this.p1.y, this.p2.y);
      } else {
        return isBetween(p.x, this.p1.x, this.p2.x);
      }
    }
    project(p) {
      const a2 = Point.difference(this.p2, this.p1);
      const b2 = Point.difference(p, this.p1);
      const q = clamp(Point.dot(a2, b2) / this.lengthSquared, 0, 1);
      return this.p1.add(a2.scale(q));
    }
    /** Contracts (or expands) a line by a specific ratio. */
    contract(x) {
      return new _Segment(this.at(x), this.at(1 - x));
    }
    equals(other, tolerance, oriented = false) {
      if (other.type !== "segment") return false;
      return this.p1.equals(other.p1, tolerance) && this.p2.equals(other.p2, tolerance) || !oriented && this.p1.equals(other.p2, tolerance) && this.p2.equals(other.p1, tolerance);
    }
    toString() {
      return `segment(${this.p1},${this.p2})`;
    }
  };
  function liesOnSegment(s, p) {
    if (nearlyEquals(s.p1.x, s.p2.x)) return isBetween(p.y, s.p1.y, s.p2.y);
    return isBetween(p.x, s.p1.x, s.p2.x);
  }
  function liesOnRay(r, p) {
    if (nearlyEquals(r.p1.x, r.p2.x)) return (p.y - r.p1.y) / (r.p2.y - r.p1.y) > 0;
    return (p.x - r.p1.x) / (r.p2.x - r.p1.x) > 0;
  }
  function liesOnArc(a2, p) {
    return isBetween(a2.offset(p), 0, 1);
  }
  function lineLineIntersection(l1, l2) {
    const d1x = l1.p1.x - l1.p2.x;
    const d1y = l1.p1.y - l1.p2.y;
    const d2x = l2.p1.x - l2.p2.x;
    const d2y = l2.p1.y - l2.p2.y;
    const d = d1x * d2y - d1y * d2x;
    if (nearlyEquals(d, 0)) return [];
    const q1 = l1.p1.x * l1.p2.y - l1.p1.y * l1.p2.x;
    const q2 = l2.p1.x * l2.p2.y - l2.p1.y * l2.p2.x;
    const x = q1 * d2x - d1x * q2;
    const y = q1 * d2y - d1y * q2;
    return [new Point(x / d, y / d)];
  }
  function circleCircleIntersection(c1, c2) {
    const d = Point.distance(c1.c, c2.c);
    if (d > c1.r + c2.r) return [];
    if (d < Math.abs(c1.r - c2.r)) return [];
    if (nearlyEquals(d, 0) && nearlyEquals(c1.r, c2.r)) return [];
    if (nearlyEquals(d, c1.r + c2.r)) return [new Line(c1.c, c2.c).midpoint];
    const a2 = (square(c1.r) - square(c2.r) + square(d)) / (2 * d);
    const b2 = Math.sqrt(square(c1.r) - square(a2));
    const px = (c2.c.x - c1.c.x) * a2 / d + (c2.c.y - c1.c.y) * b2 / d + c1.c.x;
    const py = (c2.c.y - c1.c.y) * a2 / d - (c2.c.x - c1.c.x) * b2 / d + c1.c.y;
    const qx = (c2.c.x - c1.c.x) * a2 / d - (c2.c.y - c1.c.y) * b2 / d + c1.c.x;
    const qy = (c2.c.y - c1.c.y) * a2 / d + (c2.c.x - c1.c.x) * b2 / d + c1.c.y;
    return [new Point(px, py), new Point(qx, qy)];
  }
  function lineCircleIntersection(l, c) {
    const dx = l.p2.x - l.p1.x;
    const dy = l.p2.y - l.p1.y;
    const dr2 = square(dx) + square(dy);
    const cx = c.c.x;
    const cy = c.c.y;
    const D = (l.p1.x - cx) * (l.p2.y - cy) - (l.p2.x - cx) * (l.p1.y - cy);
    const disc = square(c.r) * dr2 - square(D);
    if (disc < 0) return [];
    const xa = D * dy / dr2;
    const ya = -D * dx / dr2;
    if (nearlyEquals(disc, 0)) return [c.c.shift(xa, ya)];
    const xb = dx * (dy < 0 ? -1 : 1) * Math.sqrt(disc) / dr2;
    const yb = Math.abs(dy) * Math.sqrt(disc) / dr2;
    return [c.c.shift(xa + xb, ya + yb), c.c.shift(xa - xb, ya - yb)];
  }
  function simpleIntersection(a2, b2) {
    let results = [];
    const a1 = isArc(a2) ? a2.circle : a2;
    const b1 = isArc(b2) ? b2.circle : b2;
    if (isLineLike(a2) && isLineLike(b2)) {
      results = lineLineIntersection(a2, b2);
    } else if (isLineLike(a1) && isCircle(b1)) {
      results = lineCircleIntersection(a1, b1);
    } else if (isCircle(a1) && isLineLike(b1)) {
      results = lineCircleIntersection(b1, a1);
    } else if (isCircle(a1) && isCircle(b1)) {
      results = circleCircleIntersection(a1, b1);
    }
    for (const x of [a2, b2]) {
      if (isSegment(x)) results = results.filter((i) => liesOnSegment(x, i));
      if (isRay(x)) results = results.filter((i) => liesOnRay(x, i));
      if (isArc(x)) results = results.filter((i) => liesOnArc(x, i));
    }
    return results;
  }
  function intersections(...elements) {
    if (elements.length < 2) return [];
    if (elements.length > 2) {
      return flatten(subsets(elements, 2).map((e) => intersections(...e)));
    }
    let [a2, b2] = elements;
    if (isAngle(a2)) a2 = a2.shape(true);
    if (isAngle(b2)) b2 = b2.shape(true);
    if (isPolygonLike(b2)) [a2, b2] = [b2, a2];
    if (isPolygonLike(a2)) {
      const results = isLineLike(b2) ? a2.points.filter((p) => b2.contains(p)) : [];
      for (const e of a2.edges) results.push(...intersections(e, b2));
      return results;
    }
    return simpleIntersection(a2, b2);
  }
  var Polygon = class _Polygon {
    constructor(...points) {
      this.type = "polygon";
      this.points = points;
    }
    get circumference() {
      if (this.points.length <= 1) return 0;
      let length = Point.distance(this.points[0], last(this.points));
      for (let i = 1; i < this.points.length; ++i) {
        length += Point.distance(this.points[i - 1], this.points[i]);
      }
      return length;
    }
    /**
     * The (signed) area of this polygon. The result is positive if the vertices
     * are ordered clockwise, and negative otherwise.
     */
    get signedArea() {
      const p = this.points;
      const n = p.length;
      let A = p[n - 1].x * p[0].y - p[0].x * p[n - 1].y;
      for (let i = 1; i < n; ++i) {
        A += p[i - 1].x * p[i].y - p[i].x * p[i - 1].y;
      }
      return A / 2;
    }
    get area() {
      return Math.abs(this.signedArea);
    }
    get centroid() {
      const p = this.points;
      const n = p.length;
      let Cx = 0;
      for (let i = 0; i < n; ++i) Cx += p[i].x;
      let Cy = 0;
      for (let i = 0; i < n; ++i) Cy += p[i].y;
      return new Point(Cx / n, Cy / n);
    }
    get edges() {
      const n = this.points.length;
      const edges = [];
      for (let i = 0; i < n; ++i) {
        edges.push(new Segment(this.points[i], this.points[(i + 1) % n]));
      }
      return edges;
    }
    get radius() {
      const c = this.centroid;
      const radii = this.points.map((p) => Point.distance(p, c));
      return Math.max(...radii);
    }
    /** The oriented version of this polygon (vertices in clockwise order). */
    get oriented() {
      if (this.signedArea >= 0) return this;
      const points = [...this.points].reverse();
      return new this.constructor(...points);
    }
    /** Checks if two polygons p1 and p2 collide. */
    static collision(p1, p2) {
      if (p1.points.some((q) => p2.contains(q))) return true;
      if (p2.points.some((q) => p1.contains(q))) return true;
      for (const e1 of p1.edges) {
        for (const e2 of p2.edges) {
          if (intersections(e1, e2)[0]) return true;
        }
      }
      return false;
    }
    /** Creates a regular polygon. */
    static regular(n, radius = 1) {
      const da = TWO_PI / n;
      const a0 = Math.PI / 2 - da / 2;
      const points = tabulate((i) => Point.fromPolar(a0 + da * i, radius), n);
      return new _Polygon(...points);
    }
    /** Interpolates the points of two polygons */
    static interpolate(p1, p2, t = 0.5) {
      const points = p1.points.map(
        (p, i) => Point.interpolate(p, p2.points[i], t)
      );
      return new _Polygon(...points);
    }
    static convexHull(...points) {
      if (points.length <= 3) return new _Polygon(...points);
      const sorted = points.sort((a2, b2) => a2.x !== b2.x ? a2.x - b2.x : a2.y - b2.y);
      const sortedReverse = sorted.slice(0).reverse();
      const upper = [];
      const lower = [];
      for (const [source, target] of [[sorted, upper], [sortedReverse, lower]]) {
        for (const p of source) {
          while (target.length >= 2) {
            const p1 = target[target.length - 1];
            const p2 = target[target.length - 2];
            if ((p1.x - p2.x) * (p.y - p2.y) >= (p.x - p2.x) * (p1.y - p2.y)) {
              target.pop();
            } else {
              break;
            }
          }
          target.push(p);
        }
        target.pop();
      }
      return new _Polygon(...upper.concat(lower));
    }
    // ---------------------------------------------------------------------------
    /**
     * Checks if a point p lies inside this polygon, by using a ray-casting
     * algorithm and calculating the number of intersections.
     */
    contains(p) {
      let inside = false;
      for (const e of this.edges) {
        if (e.p1.equals(p) || e.contains(p)) return false;
        if (e.p1.y > p.y === e.p2.y > p.y) continue;
        const det = (e.p2.x - e.p1.x) / (e.p2.y - e.p1.y);
        if (p.x < det * (p.y - e.p1.y) + e.p1.x) inside = !inside;
      }
      return inside;
    }
    at(t) {
      if (t < 0) t += Math.floor(t);
      const offset = t * this.circumference;
      let cum = 0;
      for (const e of this.edges) {
        const l = e.length;
        if (cum + l > offset) return e.at((offset - cum) / l);
        cum += l;
      }
      return this.points[0];
    }
    offset(p) {
      const edges = this.edges;
      const proj = findClosest(p, this.edges) || [this.points[0], 0];
      let offset = 0;
      for (let i = 0; i < proj[1]; ++i) offset += edges[i].length;
      offset += edges[proj[1]].offset(p) * edges[proj[1]].length;
      return offset / this.circumference;
    }
    project(p) {
      const proj = findClosest(p, this.edges);
      return proj ? proj[0] : this.points[0];
    }
    /** Center this polygon on a given point or the origin */
    centerAt(on = ORIGIN) {
      return this.translate(on.subtract(this.centroid));
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return new this.constructor(...this.points.map((p) => p.transform(m)));
    }
    /** Rotates this polygon by a given angle (in radians), optionally around point `center`. */
    rotate(a2, center = ORIGIN) {
      if (nearlyEquals(a2, 0)) return this;
      const points = this.points.map((p) => p.rotate(a2, center));
      return new this.constructor(...points);
    }
    reflect(line) {
      const points = this.points.map((p) => p.reflect(line));
      return new this.constructor(...points);
    }
    scale(sx, sy = sx) {
      const points = this.points.map((p) => p.scale(sx, sy));
      return new this.constructor(...points);
    }
    shift(x, y = x) {
      const points = this.points.map((p) => p.shift(x, y));
      return new this.constructor(...points);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(other, tolerance, oriented) {
      const n = this.points.length;
      if (n !== other.points.length) return false;
      const p1 = oriented ? this : this.oriented;
      const p2 = oriented ? other : other.oriented;
      for (let offset = 0; offset < n; ++offset) {
        if (p1.points.every((p, i) => p.equals(p2.points[(i + offset) % n], tolerance))) {
          return true;
        }
      }
      return false;
    }
    toString() {
      return `polygon(${this.points.join(",")})`;
    }
  };
  var RAD_TO_DEG = 180 / Math.PI;
  var DEG_TO_RAD = Math.PI / 180;
  function toDeg(n) {
    return n * RAD_TO_DEG;
  }
  var Rectangle = class _Rectangle {
    constructor(p, w = 1, h = w) {
      this.p = p;
      this.w = w;
      this.h = h;
      this.type = "rectangle";
    }
    /** Creates the smallest rectangle containing all given points. */
    static aroundPoints(points) {
      let xMin = Infinity;
      let xMax = -Infinity;
      let yMin = Infinity;
      let yMax = -Infinity;
      for (const p of points) {
        xMin = xMin < p.x ? xMin : p.x;
        xMax = xMax > p.x ? xMax : p.x;
        yMin = yMin < p.y ? yMin : p.y;
        yMax = yMax > p.y ? yMax : p.y;
      }
      return new _Rectangle(new Point(xMin, yMin), xMax - xMin, yMax - yMin);
    }
    get center() {
      return new Point(this.p.x + this.w / 2, this.p.y + this.h / 2);
    }
    get centroid() {
      return this.center;
    }
    get circumference() {
      return 2 * Math.abs(this.w) + 2 * Math.abs(this.h);
    }
    get area() {
      return Math.abs(this.signedArea);
    }
    get signedArea() {
      return this.w * this.h;
    }
    /** @returns {Segment[]} */
    get edges() {
      return this.polygon.edges;
    }
    /** @returns {Point[]} */
    get points() {
      return this.polygon.points;
    }
    /** A polygon class representing this rectangle. */
    get polygon() {
      const b2 = new Point(this.p.x + this.w, this.p.y);
      const c = new Point(this.p.x + this.w, this.p.y + this.h);
      const d = new Point(this.p.x, this.p.y + this.h);
      return new Polygon(this.p, b2, c, d);
    }
    get bounds() {
      return new Bounds(this.p.x, this.p.x + this.w, this.p.y, this.p.y + this.h);
    }
    collision(r) {
      return this.p.x < r.p.x + r.w && this.p.x + this.w > r.p.x && this.p.y < r.p.y + r.h && this.p.y + this.h > r.p.y;
    }
    padding(top, right, bottom, left) {
      return new _Rectangle(this.p.shift(-left, -top), this.w + left + right, this.h + top + bottom);
    }
    get unsigned() {
      if (this.w > 0 && this.h > 0) return this;
      const p = this.p.shift(this.w < 0 ? this.w : 0, this.h < 0 ? this.h : 0);
      return new _Rectangle(p, Math.abs(this.w), Math.abs(this.h));
    }
    // ---------------------------------------------------------------------------
    contains(p, tolerance) {
      return isBetween(p.x, this.p.x, this.p.x + this.w, tolerance) && isBetween(p.y, this.p.y, this.p.y + this.h, tolerance);
    }
    project(p) {
      let q = void 0;
      for (const e of this.edges) {
        const q1 = e.project(p);
        if (!q || Point.distance(p, q1) < Point.distance(p, q)) q = q1;
      }
      return q;
    }
    at(t) {
      return this.polygon.at(t);
    }
    offset(p) {
      return this.polygon.offset(p);
    }
    get oriented() {
      return this.polygon.oriented;
    }
    // ---------------------------------------------------------------------------
    transform(m) {
      return this.polygon.transform(m);
    }
    /** Rotates this rectangle by a given angle (in radians), optionally around point `c`. */
    rotate(a2, c = ORIGIN) {
      if (nearlyEquals(a2, 0)) return this;
      return this.polygon.rotate(a2, c);
    }
    reflect(l) {
      return this.polygon.reflect(l);
    }
    scale(sx, sy = sx) {
      return new _Rectangle(this.p.scale(sx, sy), this.w * sx, this.h * sy);
    }
    shift(x, y = x) {
      return new _Rectangle(this.p.shift(x, y), this.w, this.h);
    }
    translate(p) {
      return this.shift(p.x, p.y);
    }
    equals(_other) {
      return false;
    }
    toString() {
      return `rectangle(${this.p},${this.w},${this.h})`;
    }
  };
  var Bounds = class _Bounds {
    /**
     * Use the `errorHandling` option to decide how to deal with cases where the
     * min and max values are in the wrong order.
     */
    constructor(xMin, xMax, yMin, yMax, errorHandling) {
      this.xMin = xMin;
      this.xMax = xMax;
      this.yMin = yMin;
      this.yMax = yMax;
      if (errorHandling === "swap") {
        if (this.dx < 0) [this.xMin, this.xMax] = [xMax, xMin];
        if (this.dy < 0) [this.yMin, this.yMax] = [yMax, yMin];
      } else if (errorHandling === "center") {
        if (this.dx < 0) this.xMin = this.xMax = (xMin + xMax) / 2;
        if (this.dy < 0) this.yMin = this.yMax = (yMin + yMax) / 2;
      }
    }
    contains(p) {
      return this.containsX(p) && this.containsY(p);
    }
    containsX(p) {
      return isBetween(p.x, this.xMin, this.xMax);
    }
    containsY(p) {
      return isBetween(p.y, this.yMin, this.yMax);
    }
    resize(dx, dy) {
      return new _Bounds(this.xMin, this.xMax + dx, this.yMin, this.yMax + dy);
    }
    get dx() {
      return this.xMax - this.xMin;
    }
    get dy() {
      return this.yMax - this.yMin;
    }
    get xRange() {
      return [this.xMin, this.xMax];
    }
    get yRange() {
      return [this.yMin, this.yMax];
    }
    extend(top, right = top, bottom = top, left = right) {
      return new _Bounds(this.xMin - left, this.xMax + right, this.yMin - top, this.yMax + bottom);
    }
    get rect() {
      return new Rectangle(new Point(this.xMin, this.yMin), this.dx, this.dy);
    }
    get center() {
      return new Point(this.xMin + this.dx / 2, this.yMin + this.dy / 2);
    }
    get flip() {
      return new _Bounds(this.yMin, this.yMax, this.xMin, this.xMax);
    }
  };
  function drawCanvas(ctx, obj, options = {}) {
    if (isAngle(obj)) return drawCanvas(ctx, obj.shape(!!options.fill), options);
    if (options.fill) ctx.fillStyle = options.fill;
    if (options.opacity) ctx.globalAlpha = options.opacity;
    if (options.stroke) {
      ctx.strokeStyle = options.stroke;
      ctx.lineWidth = options.strokeWidth || 1;
      if (options.lineCap) ctx.lineCap = options.lineCap;
      if (options.lineJoin) ctx.lineJoin = options.lineJoin;
    }
    ctx.beginPath();
    if (isSegment(obj)) {
      ctx.moveTo(obj.p1.x, obj.p1.y);
      ctx.lineTo(obj.p2.x, obj.p2.y);
    } else if (isLineLike(obj)) {
      if (!options.box) return;
      let [start, end] = intersections(obj, options.box);
      if (isRay(obj)) end = obj.p1;
      if (!start || !end) return;
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
    } else if (isCircle(obj)) {
      ctx.arc(obj.c.x, obj.c.y, obj.r, 0, TWO_PI);
    } else if (isPolygonLike(obj)) {
      const points = obj.points;
      ctx.moveTo(points[0].x, points[0].y);
      for (const p of points.slice(1)) ctx.lineTo(p.x, p.y);
      ctx.closePath();
    } else if (isPolyline(obj)) {
      ctx.moveTo(obj.points[0].x, obj.points[0].y);
      for (const p of obj.points.slice(1)) ctx.lineTo(p.x, p.y);
    } else if (isEllipse(obj)) {
      ctx.ellipse(obj.c.x, obj.c.y, obj.a, obj.b, obj.angle, 0, TWO_PI);
    }
    if (options.fill) ctx.fill();
    if (options.stroke) ctx.stroke();
  }
  var CIRCLE_MAGIC = 4 * (Math.sqrt(2) - 1) / 3;
  function drawArc(a2, b2, c) {
    const orient = b2.x * (c.y - a2.y) + a2.x * (b2.y - c.y) + c.x * (a2.y - b2.y);
    const sweep = orient > 0 ? 1 : 0;
    const size = Point.distance(b2, a2);
    return [a2.x, `${a2.y}A${size}`, size, 0, sweep, 1, c.x, c.y].join(",");
  }
  function drawPath(...points) {
    return `M${points.map((p) => `${p.x},${p.y}`).join("L")}`;
  }
  function drawLineMark(x, type) {
    const p = x.perpendicularVector.scale(6);
    const n = x.unitVector.scale(3);
    const m = x.midpoint;
    switch (type) {
      case "bar":
        return drawPath(m.add(p), m.add(p.inverse));
      case "bar2":
        return drawPath(m.add(n).add(p), m.add(n).add(p.inverse)) + drawPath(m.add(n.inverse).add(p), m.add(n.inverse).add(p.inverse));
      case "arrow":
        return drawPath(
          m.add(n.inverse).add(p),
          m.add(n),
          m.add(n.inverse).add(p.inverse)
        );
      case "arrow2":
        return drawPath(
          m.add(n.scale(-2)).add(p),
          m,
          m.add(n.scale(-2)).add(p.inverse)
        ) + drawPath(m.add(p), m.add(n.scale(2)), m.add(p.inverse));
      default:
        return "";
    }
  }
  function arrowPath(start, normal2) {
    if (!start || !normal2) return "";
    const perp = normal2.perpendicular;
    const a2 = start.add(normal2.scale(9)).add(perp.scale(9));
    const b2 = start.add(normal2.scale(9)).add(perp.scale(-9));
    return drawPath(a2, start, b2);
  }
  function drawLineArrows(x, type) {
    let path = "";
    if (isOneOf(type, "start", "both")) {
      path += arrowPath(x.p1, x.unitVector);
    }
    if (isOneOf(type, "end", "both")) {
      path += arrowPath(x.p2, x.unitVector.inverse);
    }
    return path;
  }
  function drawArcArrows(x, type) {
    let path = "";
    if (isOneOf(type, "start", "both")) {
      const normal2 = new Line(x.c, x.start).perpendicularVector.inverse;
      path += arrowPath(x.start, normal2);
    }
    if (isOneOf(type, "end", "both")) {
      const normal2 = new Line(x.c, x.end).perpendicularVector;
      path += arrowPath(x.end, normal2);
    }
    return path;
  }
  function getBezierPoints(points, radius) {
    const length0 = Point.distance(points[0], points[1]);
    const length1 = Point.distance(points[1], points[2]);
    const r1 = Math.max(0.1, length0 / 2);
    const r2 = Math.max(0.1, length1 / 2);
    const rad2 = Math.min(radius, r1, r2);
    const d1 = rad2 / length0;
    const d2 = rad2 / length1;
    const shift = 1 - CIRCLE_MAGIC;
    const p1 = Point.interpolate(points[0], points[1], clamp(1 - d1, 0, 1));
    const p2 = Point.interpolate(points[0], points[1], clamp(1 - d1 * shift, 0, 1));
    const p3 = Point.interpolate(points[1], points[2], clamp(d2 * shift, 0, 1));
    const p4 = Point.interpolate(points[1], points[2], clamp(d2, 0, 1));
    return [p1, p2, p3, p4];
  }
  function drawRoundedPath(points, radius, close = false) {
    if (radius < 0) radius = 0;
    let path = "M";
    if (!close) {
      path += `${points[0].x} ${points[0].y}`;
    } else {
      const p1 = points[points.length - 1];
      const p2 = points[0];
      const p3 = points[1];
      const offsets = getBezierPoints([p1, p2, p3], radius);
      path += `${offsets[3].x} ${offsets[3].y}`;
    }
    for (let index = 0; index < points.length; index++) {
      if (index < points.length - 2 || close) {
        const p1 = points[index];
        const p2 = points[(index + 1) % points.length];
        const p3 = points[(index + 2) % points.length];
        const offsets = getBezierPoints([p1, p2, p3], radius).map((p) => `${p.x} ${p.y}`);
        path += `L${offsets[0]}C${offsets[1]} ${offsets[2]} ${offsets[3]}`;
      } else if (index === points.length - 2 && !close) {
        path += `L${points[index + 1].x} ${points[index + 1].y}`;
      }
    }
    return path;
  }
  function drawSVG(obj, options = {}) {
    if (isAngle(obj)) {
      const shape = obj.shape(!!options.fill, options.size, options.round);
      return drawSVG(shape, options);
    }
    if (isSegment(obj)) {
      if (obj.p1.equals(obj.p2)) return "";
      let line = drawPath(obj.p1, obj.p2);
      if (options.mark) line += drawLineMark(obj, options.mark);
      if (options.arrows) line += drawLineArrows(obj, options.arrows);
      return line;
    }
    if (isRay(obj)) {
      if (!options.box) return "";
      const end = intersections(obj, options.box)[0];
      if (!end) return "";
      let line = drawPath(obj.p1, end);
      if (options.mark) line += drawLineMark(obj, options.mark);
      return line;
    }
    if (isLine(obj)) {
      if (!options.box) return "";
      const points = intersections(obj, options.box);
      if (points.length < 2) return "";
      let line = drawPath(points[0], points[1]);
      if (options.mark) line += drawLineMark(obj, options.mark);
      return line;
    }
    if (isCircle(obj)) {
      return `M${obj.c.x - obj.r} ${obj.c.y}a${obj.r},${obj.r} 0 1 0 ${2 * obj.r} 0a${obj.r} ${obj.r} 0 1 0 ${-2 * obj.r} 0Z`;
    }
    if (isEllipse(obj)) {
      const [u, v] = obj.majorVertices;
      const rot = toDeg(obj.angle);
      return `M${u.x} ${u.y}A${obj.a} ${obj.b} ${rot} 0 0 ${v.x} ${v.y}A${obj.a} ${obj.b} ${rot} 0 0 ${u.x} ${u.y}Z`;
    }
    if (isArc(obj)) {
      let path = `M${drawArc(obj.start, obj.c, obj.end)}`;
      if (options.arrows) path += drawArcArrows(obj, options.arrows);
      return path;
    }
    if (isSector(obj)) {
      return `M${obj.c.x} ${obj.c.y} L ${drawArc(obj.start, obj.c, obj.end)}Z`;
    }
    if (isPolyline(obj)) {
      if (options.cornerRadius) return drawRoundedPath(obj.points, options.cornerRadius, false);
      return drawPath(...obj.points);
    }
    if (isPolygon(obj) || isRectangle(obj) && options.cornerRadius) {
      if (options.cornerRadius) {
        return drawRoundedPath(obj.points, options.cornerRadius, true);
      }
      return `${drawPath(...obj.points)}Z`;
    }
    if (isRectangle(obj)) {
      return `${drawPath(...obj.polygon.points)}Z`;
    }
    return "";
  }

  // node_modules/@mathigon/boost/dist/index.esm.js
  var __knownSymbol2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
  var __typeError2 = (msg) => {
    throw TypeError(msg);
  };
  var __async2 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var __await2 = function(promise, isYieldStar) {
    this[0] = promise;
    this[1] = isYieldStar;
  };
  var __yieldStar2 = (value) => {
    var obj = value[__knownSymbol2("asyncIterator")], isAwait = false, method, it = {};
    if (obj == null) {
      obj = value[__knownSymbol2("iterator")]();
      method = (k) => it[k] = (x) => obj[k](x);
    } else {
      obj = obj.call(value);
      method = (k) => it[k] = (v) => {
        if (isAwait) {
          isAwait = false;
          if (k === "throw") throw v;
          return v;
        }
        isAwait = true;
        return {
          done: false,
          value: new __await2(new Promise((resolve) => {
            var x = obj[k](v);
            if (!(x instanceof Object)) __typeError2("Object expected");
            resolve(x);
          }), 1)
        };
      };
    }
    return it[__knownSymbol2("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
      throw x;
    }, "return" in obj && method("return"), it;
  };
  var STORAGE_KEY = "_M";
  var UA = window.navigator.userAgent.toLowerCase();
  var MOBILE_REGEX = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;
  var IOS_REGEX = /iphone|ipad|ipod/i;
  var SAFARI_REGEX = /^((?!chrome|android).)*safari/i;
  var _a;
  var BrowserInstance = class {
    constructor() {
      this.isMobile = MOBILE_REGEX.test(UA);
      this.isRetina = (window.devicePixelRatio || 1) > 1;
      this.isTouch = !!window.Touch || "ontouchstart" in window;
      this.isChrome = !!window.chrome;
      this.isFirefox = UA.indexOf("firefox") >= 0;
      this.isAndroid = UA.indexOf("android") >= 0;
      this.isIOS = IOS_REGEX.test(UA);
      this.isSafari = IOS_REGEX.test(UA) || SAFARI_REGEX.test(UA);
      this.loadQueue = [];
      this.loaded = false;
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.resizeCallbacks = [];
      this.theme = { name: "light", isDark: false };
      this.themeChangedCallbacks = [];
      this.themeOverride = "";
      this.darkQuery = (_a = window.matchMedia) == null ? void 0 : _a.call(window, "(prefers-color-scheme: dark)");
      var _a22, _b;
      window.onload = () => this.afterLoad();
      document.addEventListener("DOMContentLoaded", () => this.afterLoad());
      const applyResizeThrottled = throttle(() => this.applyResize());
      window.addEventListener("resize", applyResizeThrottled);
      try {
        (_a22 = this.darkQuery) == null ? void 0 : _a22.addEventListener("change", () => this.applyThemeChange());
      } catch (e) {
        (_b = this.darkQuery) == null ? void 0 : _b.addListener(() => this.applyThemeChange());
      }
      const initial = this.getCookie("theme");
      if (initial) this.setTheme(initial);
      try {
        this.localStorage = window.localStorage;
      } catch (e) {
        console.warn("Unable to access Local Storage in this context.");
      }
    }
    afterLoad() {
      if (this.loaded) return;
      this.loaded = true;
      for (const fn of this.loadQueue) fn();
      setTimeout(() => this.resize());
    }
    /** Binds an event listener that is triggered when the page is loaded. */
    ready(fn) {
      if (this.loaded) {
        fn();
      } else {
        this.loadQueue.push(fn);
      }
    }
    /** Forces a re-paint. This is useful when updating transition properties. */
    redraw() {
      document.body.offsetHeight;
    }
    applyResize() {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;
      if (this.width === newWidth && this.height === newHeight) return;
      this.width = newWidth;
      this.height = newHeight;
      for (const fn of this.resizeCallbacks) fn({ width: this.width, height: this.height });
      $body.trigger("scroll", { top: $body.scrollTop });
    }
    onResize(fn) {
      fn({ width: this.width, height: this.height });
      this.resizeCallbacks.push(fn);
    }
    offResize(fn) {
      const i = this.resizeCallbacks.indexOf(fn);
      if (i >= 0) this.resizeCallbacks.splice(i, 1);
    }
    resize() {
      this.applyResize();
    }
    applyThemeChange() {
      const name = this.theme.name;
      const isDark = name === "dark" || name === "auto" && this.darkQuery.matches;
      if (isDark === this.theme.isDark) return;
      this.theme.isDark = isDark;
      for (const c of this.themeChangedCallbacks) c(this.theme);
      setTimeout(() => $html.setAttr("theme", this.themeOverride || (isDark ? "dark" : "light")));
    }
    setTheme(name) {
      if (name === this.theme.name) return;
      this.theme.name = name;
      this.setCookie("theme", name);
      this.applyThemeChange();
    }
    onThemeChange(fn) {
      this.themeChangedCallbacks.push(fn);
    }
    // ---------------------------------------------------------------------------
    // Location
    /** Returns the hash string of the current window. */
    getHash() {
      return window.location.hash.slice(1);
    }
    /** Set the hash string of the current window. */
    setHash(h) {
      const scroll = document.body.scrollTop;
      window.location.hash = h;
      document.body.scrollTop = scroll;
    }
    /** Set the URL of the current window. */
    setURL(url, title = "") {
      window.history.replaceState({}, title, url);
      if (title) window.document.title = title;
    }
    // ---------------------------------------------------------------------------
    // Cookies
    /** Returns a JSON object of all cookies. */
    getCookies() {
      const pairs = document.cookie.split(";");
      const result = {};
      for (let i = 0, n = pairs.length; i < n; ++i) {
        const pair = pairs[i].split("=");
        result[decodeURIComponent(pair[0]).trim()] = decodeURIComponent(pair[1]);
      }
      return result;
    }
    getCookie(name) {
      const v = document.cookie.match(new RegExp(`(^|;) ?${name}=([^;]*)(;|$)`));
      return v ? v[2] : void 0;
    }
    setCookie(name, value, maxAge = 60 * 60 * 24 * 365) {
      const domain = window.location.hostname.replace(/^[a-z]{2}\./, "");
      document.cookie = `${name}=${value};path=/;max-age=${maxAge};domain=${domain}`;
    }
    deleteCookie(name) {
      this.setCookie(name, "", -1);
    }
    setStorage(key, value) {
      var _a22, _b;
      const keys = (key || "").split(".");
      const storage = safeToJSON(((_a22 = this.localStorage) == null ? void 0 : _a22.getItem(STORAGE_KEY)) || void 0, {});
      let path = storage;
      for (let i = 0; i < keys.length - 1; ++i) {
        if (path[keys[i]] === void 0) path[keys[i]] = {};
        path = path[keys[i]];
      }
      path[keys[keys.length - 1]] = value;
      (_b = this.localStorage) == null ? void 0 : _b.setItem(STORAGE_KEY, JSON.stringify(storage));
    }
    getStorage(key) {
      var _a22;
      let path = safeToJSON((_a22 = this.localStorage) == null ? void 0 : _a22.getItem(STORAGE_KEY), {});
      if (!key) return path;
      const keys = (key || "").split(".");
      const lastKey = keys.pop();
      for (const k of keys) {
        if (!(k in path)) return;
        path = path[k];
      }
      return path[lastKey];
    }
    deleteStorage(key) {
      var _a22;
      if (key) {
        this.setStorage(key, void 0);
      } else {
        (_a22 = this.localStorage) == null ? void 0 : _a22.setItem(STORAGE_KEY, "");
      }
    }
    // ---------------------------------------------------------------------------
    // Keyboard Event Handling
    /** The current active element on the page (e.g. and `<input>`). */
    getActiveInput() {
      let active2 = document.activeElement;
      if (active2 == null ? void 0 : active2.shadowRoot) active2 = active2.shadowRoot.activeElement;
      return active2 === document.body ? void 0 : $(active2);
    }
    get formIsActive() {
      var _a22;
      return !!((_a22 = this.getActiveInput()) == null ? void 0 : _a22.is("input, select, textarea, [contenteditable]"));
    }
  };
  var Browser = window.BoostBrowser || new BrowserInstance();
  window.BoostBrowser = Browser;
  var IEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/;
  var webkitUA = /\bAppleWebKit\/(\d+)\b/;
  var EdgeUA = /\bEdge\/12\.(\d+)\b/;
  var polyfill = IEUA.test(navigator.userAgent) || +(navigator.userAgent.match(EdgeUA) || [])[1] < 10547 || +(navigator.userAgent.match(webkitUA) || [])[1] < 537;
  var requests = {};
  function replaceSvgImports() {
    if (!polyfill) return;
    const uses = Array.from(document.querySelectorAll("svg > use"));
    uses.forEach(function(use) {
      const src = use.getAttribute("xlink:href");
      const [url, id] = src.split("#");
      if (!url.length || !id) return;
      const svg = use.parentNode;
      svg.removeChild(use);
      if (!(url in requests)) requests[url] = fetch(url).then((r) => r.text());
      const request = requests[url];
      request.then((response) => {
        const doc = document.implementation.createHTMLDocument("");
        doc.documentElement.innerHTML = response;
        const icon = doc.getElementById(id);
        const clone = icon.cloneNode(true);
        const fragment = document.createDocumentFragment();
        while (clone.childNodes.length) fragment.appendChild(clone.firstChild);
        svg.appendChild(fragment);
      });
    });
  }
  var KEY_FALLBACKS = new Map(Object.entries({
    " ": "Space",
    "Spacebar": "Space",
    "Del": "Delete",
    "Esc": "Escape",
    "Left": "ArrowLeft",
    "Right": "ArrowRight",
    "Down": "ArrowDown",
    "Up": "ArrowUp"
  }));
  function keyCode(e) {
    return KEY_FALLBACKS.get(e.key) || e.key;
  }
  function bindAccessibilityEvents(parent) {
    const KEYS = /* @__PURE__ */ new Set(["Enter", "Space"]);
    let isDown = false;
    document.addEventListener("keyup", (e) => {
      if (KEYS.has(keyCode(e))) isDown = false;
    });
    (parent || document).addEventListener("keydown", (e) => {
      if (!isDown && KEYS.has(keyCode(e))) {
        isDown = true;
        const $active = Browser.getActiveInput();
        if ($active && $active.hasAttr("tabindex") && $active.tagName !== "TEXTAREA") {
          e.preventDefault();
          $active.trigger("pointerdown", e);
          $active.trigger("pointerstop", e);
          $body.trigger("pointerstop", e);
          $active.trigger("click", e);
        }
      }
    });
  }
  var isReady = false;
  setTimeout(() => isReady = true);
  var BOUNCE_IN = "cubic-bezier(0.175, 0.885, 0.32, 1.275)";
  var BOUNCE_OUT = "cubic-bezier(0.68, -0.275, 0.825, 0.115)";
  var ResolvedAnimation = { cancel: () => void 0, promise: Promise.resolve() };
  function animate(callback, duration) {
    if (duration === 0) {
      callback(1, 0, () => void 0);
      return ResolvedAnimation;
    }
    const startTime = Date.now();
    const deferred = defer();
    let lastTime = 0;
    let running = true;
    const cancel = () => {
      running = false;
      deferred.reject();
    };
    function getFrame() {
      if (!running) return;
      if (!duration || lastTime <= duration) {
        window.requestAnimationFrame(getFrame);
      }
      const time = Date.now() - startTime;
      callback(duration ? Math.min(1, time / duration) : time, time - lastTime, cancel);
      if (duration && time >= duration) deferred.resolve();
      lastTime = time;
    }
    getFrame();
    return { cancel, promise: deferred.promise };
  }
  function easeIn(type, t = 0, s = 0) {
    switch (type) {
      case "quad":
        return t ** 2;
      case "cubic":
        return t ** 3;
      case "quart":
        return t ** 4;
      case "quint":
        return t ** 5;
      case "circ":
        return 1 - Math.sqrt(1 - t ** 2);
      case "sine":
        return 1 - Math.cos(t * Math.PI / 2);
      case "exp":
        return t <= 0 ? 0 : Math.pow(2, 10 * (t - 1));
      case "back":
        if (!s) s = 1.70158;
        return t * t * ((s + 1) * t - s);
      case "elastic":
        if (!s) s = 0.3;
        return -Math.pow(2, 10 * (t - 1)) * Math.sin(((t - 1) * 2 / s - 0.5) * Math.PI);
      case "swing":
        return 0.5 - Math.cos(t * Math.PI) / 2;
      case "spring":
        return 1 - Math.cos(t * 4.5 * Math.PI) * Math.exp(-t * 6);
      case "bounce":
        if (t < 1 / 11) return 1 / 64 - 7.5625 * (0.5 / 11 - t) * (0.5 / 11 - t);
        if (t < 3 / 11) return 1 / 16 - 7.5625 * (2 / 11 - t) * (2 / 11 - t);
        if (t < 7 / 11) return 1 / 4 - 7.5625 * (5 / 11 - t) * (5 / 11 - t);
        return 1 - 7.5625 * (1 - t) * (1 - t);
      default:
        return t;
    }
  }
  function ease(type, t = 0, s = 0) {
    if (t === 0) return 0;
    if (t === 1) return 1;
    const [name, direction] = type.split("-");
    if (direction === "in") return easeIn(name, t, s);
    if (direction === "out") return 1 - easeIn(name, 1 - t, s);
    if (t <= 0.5) return easeIn(name, 2 * t, s) / 2;
    return 1 - easeIn(name, 2 * (1 - t), s) / 2;
  }
  function transition($el, properties, duration = 400, _delay = 0, easing = "ease-in-out") {
    if (!isReady) {
      Object.keys(properties).forEach((k) => {
        const p = properties[k];
        $el.css(k, Array.isArray(p) ? p[1] : p);
      });
      return ResolvedAnimation;
    }
    if (easing === "bounce-in") easing = BOUNCE_IN;
    if (easing === "bounce-out") easing = BOUNCE_OUT;
    let oldTransition = "";
    if (Browser.isSafari) {
      oldTransition = $el._el.style.transition;
      $el.css("transition", "none");
      Browser.redraw();
    }
    const currentAnimation = $el._data.animation;
    if (currentAnimation) currentAnimation.cancel();
    const to = {};
    const from = {};
    const deferred = defer();
    const style2 = window.getComputedStyle($el._el);
    Object.keys(properties).forEach((k) => {
      const p = properties[k];
      const k1 = toCamelCase(k);
      from[k1] = Array.isArray(p) ? p[0] : style2.getPropertyValue(k);
      to[k1] = Array.isArray(p) ? p[1] : p;
      if (_delay) $el.css(k, from[k1]);
    });
    const oldHeight = to.height;
    if (to.height === "auto") {
      const children = $el.children.filter((c) => c.css("position") !== "absolute");
      to.height = `${total(children.map(($c) => $c.outerHeight))}px`;
    }
    let player;
    let cancelled = false;
    delay(() => {
      if (cancelled) return;
      player = $el._el.animate([from, to], { duration, easing, fill: "forwards" });
      player.onfinish = () => {
        if ($el._el) {
          Object.keys(properties).forEach((k) => $el.css(k, k === "height" ? oldHeight : to[k]));
        }
        if (Browser.isSafari) $el.css("transition", oldTransition);
        deferred.resolve();
        player.cancel();
        $el._data.animation = void 0;
      };
    }, _delay);
    const animation = {
      cancel() {
        if (cancelled) return;
        cancelled = true;
        if ($el._el) Object.keys(properties).forEach((k) => $el.css(k, $el.css(k)));
        if (player) player.cancel();
        $el._data.animation = void 0;
      },
      promise: deferred.promise
    };
    setTimeout(() => $el._data.animation = animation);
    return animation;
  }
  var CSS_MATRIX = /matrix\([0-9.\-\s]+,[0-9.\-\s]+,[0-9.\-\s]+,[0-9.\-\s]+,([0-9.\-\s]+),([0-9.\-\s]+)\)/;
  function enter($el, effect = "fade", duration = 500, _delay = 0) {
    $el.show();
    if (!isReady) return ResolvedAnimation;
    const opacity = $el._data.animation ? 1 : +$el.css("opacity") || 1;
    if (effect === "fade") {
      return transition($el, { opacity: [0, opacity] }, duration, _delay);
    } else if (effect === "pop") {
      const transform2 = $el.transform.replace(/scale\([0-9.]*\)/, "").replace(CSS_MATRIX, "translate($1px,$2px)");
      transition($el, { opacity: [0, opacity] }, duration, _delay);
      return transition($el, {
        transform: [`${transform2} scale(0.5)`, `${transform2} scale(1)`]
      }, duration, _delay, "bounce-in");
    } else if (effect === "descend") {
      const rules = { opacity: [0, 1], transform: ["translateY(-50%)", "none"] };
      return transition($el, rules, duration, _delay);
    } else if (effect.startsWith("draw")) {
      const l = $el.strokeLength;
      $el.css("stroke-dasharray", `${l}px`);
      if (!$el.css("opacity")) $el.css("opacity", 1);
      const end = effect === "draw-reverse" ? `${2 * l}px` : 0;
      const rules = { "stroke-dashoffset": [`${l}px`, end] };
      const animation = transition($el, rules, duration, _delay, "linear");
      animation.promise.then(() => $el.css("stroke-dasharray", ""));
      return animation;
    } else if (effect.startsWith("slide")) {
      const rules = { opacity: [0, opacity], transform: ["translateY(50px)", "none"] };
      if (effect.includes("down")) rules.transform[0] = "translateY(-50px)";
      if (effect.includes("right")) rules.transform[0] = "translateX(-50px)";
      if (effect.includes("left")) rules.transform[0] = "translateX(50px)";
      return transition($el, rules, duration, _delay);
    } else if (effect.startsWith("reveal")) {
      const rules = { opacity: [0, opacity], height: [0, "auto"] };
      if (effect.includes("left")) rules.transform = ["translateX(-50%)", "none"];
      if (effect.includes("right")) rules.transform = ["translateX(50%)", "none"];
      return transition($el, rules, duration, _delay);
    }
    return ResolvedAnimation;
  }
  function exit($el, effect = "fade", duration = 400, delay3 = 0, remove = false) {
    if (!$el._el) return ResolvedAnimation;
    if (!isReady) {
      $el.hide();
      return ResolvedAnimation;
    }
    if ($el.css("display") === "none") return ResolvedAnimation;
    let animation;
    if (effect === "fade") {
      animation = transition($el, { opacity: [1, 0] }, duration, delay3);
    } else if (effect === "pop") {
      const transform2 = $el.transform.replace(/scale\([0-9.]*\)/, "");
      transition($el, { opacity: [1, 0] }, duration, delay3);
      animation = transition($el, {
        transform: [`${transform2} scale(1)`, `${transform2} scale(0.5)`]
      }, duration, delay3, "bounce-out");
    } else if (effect === "ascend") {
      const rules = { opacity: [1, 0], transform: ["none", "translateY(-50%)"] };
      animation = transition($el, rules, duration, delay3);
    } else if (effect.startsWith("draw")) {
      const l = $el.strokeLength;
      $el.css("stroke-dasharray", l);
      const start = effect === "draw-reverse" ? `${2 * l}px` : 0;
      const rules = { "stroke-dashoffset": [start, `${l}px`] };
      animation = transition($el, rules, duration, delay3, "linear");
    } else if (effect.startsWith("slide")) {
      const rules = { opacity: 0, transform: "translateY(50px)" };
      if (effect.includes("up")) rules.transform = "translateY(-50px)";
      animation = transition($el, rules, duration, delay3);
    } else if (effect.startsWith("reveal")) {
      const rules = { opacity: 0, height: 0 };
      if (effect.includes("left")) rules.transform = "translateX(-50%)";
      if (effect.includes("right")) rules.transform = "translateX(50%)";
      animation = transition($el, rules, duration, delay3);
    }
    animation.promise.then(() => remove ? $el.remove() : $el.hide());
    return animation;
  }
  var BINARY_OPS = {
    // TODO Operator overloading (e.g. add vectors or complex numbers)
    "===": (a2, b2) => a2 === b2,
    "!==": (a2, b2) => a2 !== b2,
    "||": (a2, b2) => a2 || b2,
    "&&": (a2, b2) => a2 && b2,
    // eslint-disable-next-line eqeqeq
    "==": (a2, b2) => a2 == b2,
    // eslint-disable-next-line eqeqeq
    "!=": (a2, b2) => a2 != b2,
    "<=": (a2, b2) => a2 <= b2,
    ">=": (a2, b2) => a2 >= b2,
    "**": (a2, b2) => a2 ** b2,
    "<": (a2, b2) => a2 < b2,
    ">": (a2, b2) => a2 > b2,
    "+": (a2, b2) => a2 + b2,
    "-": (a2, b2) => a2 - b2,
    "*": (a2, b2) => a2 * b2,
    "/": (a2, b2) => a2 / b2,
    "%": (a2, b2) => a2 % b2
  };
  var UNARY_OPS = {
    "-": (a2) => -a2,
    "+": (a2) => +a2,
    "!": (a2) => !a2
  };
  var BINARY_PRECEDENCE = {
    "||": 1,
    "&&": 2,
    "==": 3,
    "!=": 3,
    "===": 3,
    "!==": 3,
    "<": 4,
    ">": 4,
    "<=": 4,
    ">=": 4,
    "+": 5,
    "-": 5,
    "*": 6,
    "/": 6,
    "%": 6,
    "**": 7
    // TODO Exponentiation should be right-to-left.
  };
  var LITERALS = {
    "true": true,
    "false": false,
    "undefined": void 0
  };
  var SPACE = /\s/;
  var DIGIT = /[0-9]/;
  var IDENTIFIER_START = /[a-zA-ZÎ±-Ï‰Î‘-Î©$_]/;
  var IDENTIFIER_PART = /[0-9a-zA-ZÎ±-Ï‰Î‘-Î©$_]/;
  function parseSyntaxTree(expr) {
    const length = expr.length;
    let index = 0;
    function throwError(message) {
      throw new Error(`${message} at character ${index} of "${expr}"`);
    }
    function gobbleSpaces() {
      while (SPACE.test(expr[index])) index += 1;
    }
    function gobbleNumericLiteral() {
      var _a22;
      const number = ((_a22 = expr.slice(index).match(/^\d*(\.\d+)?([eE][+-]?\d+)?/)) == null ? void 0 : _a22[0]) || "";
      index += number.length;
      const char = expr[index];
      if (char && (IDENTIFIER_START.test(char) || char === ".")) {
        throwError(`Unexpected character (${number + char})`);
      }
      return { type: 5, value: parseFloat(number) };
    }
    function gobbleStringLiteral() {
      const quote = expr[index];
      index += 1;
      let closed = false;
      let string = "";
      while (index < length) {
        const char = expr[index++];
        if (char === quote) {
          closed = true;
          break;
        }
        string += char;
      }
      if (!closed) throwError(`Unclosed quote after "${string}"`);
      return { type: 5, value: string };
    }
    function gobbleIdentifier() {
      let name = expr[index];
      if (!IDENTIFIER_START.test(expr[index])) throwError(`Unexpected ${name}`);
      index += 1;
      while (index < length) {
        if (IDENTIFIER_PART.test(expr[index])) {
          name += expr[index++];
        } else {
          break;
        }
      }
      if (name in LITERALS) {
        return { type: 5, value: LITERALS[name] };
      } else {
        return { type: 4, name };
      }
    }
    function gobbleArguments(termination) {
      const args = [];
      let closed = false;
      let lastArg = void 0;
      while (index < length) {
        if (expr[index] === termination) {
          if (lastArg) args.push(lastArg);
          closed = true;
          index += 1;
          break;
        } else if (expr[index] === ",") {
          args.push(lastArg || { type: 5, value: void 0 });
          index += 1;
        } else {
          lastArg = gobbleExpression();
        }
      }
      if (!closed) throwError(`Expected ${termination}`);
      return args;
    }
    function gobbleVariable() {
      let node2;
      if (expr[index] === "(") {
        index += 1;
        node2 = gobbleExpression();
        gobbleSpaces();
        if (expr[index] === ")") {
          index += 1;
          return node2;
        } else {
          throwError("Unclosed (");
        }
      } else {
        node2 = gobbleIdentifier();
      }
      gobbleSpaces();
      while (".[(".includes(expr[index])) {
        if (expr[index] === ".") {
          index++;
          gobbleSpaces();
          node2 = {
            type: 6,
            object: node2,
            computed: false,
            property: gobbleIdentifier()
          };
        } else if (expr[index] === "[") {
          index++;
          node2 = {
            type: 6,
            object: node2,
            computed: true,
            property: gobbleExpression()
          };
          gobbleSpaces();
          if (expr[index] !== "]") throwError("Unclosed [");
          index++;
        } else if (expr[index] === "(") {
          index++;
          node2 = {
            type: 2,
            args: gobbleArguments(")"),
            callee: node2
          };
        }
        gobbleSpaces();
      }
      return node2;
    }
    function gobbleBinaryOp() {
      gobbleSpaces();
      for (const length2 of [3, 2, 1]) {
        const substr = expr.substr(index, length2);
        if (substr in BINARY_OPS) {
          index += length2;
          return substr;
        }
      }
    }
    function gobbleToken() {
      gobbleSpaces();
      const operator = expr[index];
      if (DIGIT.test(operator) || operator === ".") {
        return gobbleNumericLiteral();
      } else if (operator === "'" || operator === '"') {
        return gobbleStringLiteral();
      } else if (operator === "[") {
        index += 1;
        return { type: 0, elements: gobbleArguments("]") };
      } else if (operator in UNARY_OPS) {
        index += 1;
        return { type: 7, operator, argument: gobbleToken() };
      } else if (IDENTIFIER_START.test(operator) || operator === "(") {
        return gobbleVariable();
      }
      throwError("Expression parsing error");
    }
    function gobbleBinaryExpression() {
      let left = gobbleToken();
      let biop = gobbleBinaryOp();
      if (!biop) return left;
      let right = gobbleToken();
      if (!right) throwError(`Expected expression after ${biop}`);
      let node2;
      const stack = [left, biop, right];
      while (biop = gobbleBinaryOp()) {
        const prec = BINARY_PRECEDENCE[biop];
        const curBiop = biop;
        while (stack.length > 2 && prec <= BINARY_PRECEDENCE[stack[stack.length - 2]]) {
          right = stack.pop();
          biop = stack.pop();
          left = stack.pop();
          node2 = { type: 1, operator: biop, left, right };
          stack.push(node2);
        }
        node2 = gobbleToken();
        if (!node2) throwError(`Expected expression after ${curBiop}`);
        stack.push(curBiop, node2);
      }
      let i = stack.length - 1;
      node2 = stack[i];
      while (i > 1) {
        node2 = {
          type: 1,
          operator: stack[i - 1],
          left: stack[i - 2],
          right: node2
        };
        i -= 2;
      }
      return node2;
    }
    function gobbleExpression() {
      const test = gobbleBinaryExpression();
      gobbleSpaces();
      if (test && expr[index] === "?") {
        index += 1;
        const consequent = gobbleExpression();
        if (!consequent) throwError("Expected expression");
        gobbleSpaces();
        if (expr[index] === ":") {
          index++;
          const alternate = gobbleExpression();
          if (!alternate) throwError("Expected expression");
          return { type: 3, test, consequent, alternate };
        } else {
          throwError("Expected :");
        }
      } else {
        return test;
      }
    }
    const node = gobbleExpression();
    if (index < expr.length) throwError(`Unexpected "${expr[index]}"`);
    return node;
  }
  var EMPTY = [void 0, void 0];
  var FORBIDDEN_KEYS = ["__proto__", "constructor", "prototype"];
  function evaluate(node, context, local) {
    switch (node.type) {
      case 0:
        const v1 = node.elements.map((n) => evaluate(n, context, local)[0]);
        if (v1.some((v) => v === void 0)) return EMPTY;
        return [v1, void 0];
      case 1:
        const left = evaluate(node.left, context, local)[0];
        const right = evaluate(node.right, context, local)[0];
        if ("+-**/%".includes(node.operator) && (left === void 0 || right === void 0)) return EMPTY;
        return [BINARY_OPS[node.operator](left, right), void 0];
      case 2:
        const [fn, self] = evaluate(node.callee, context, local);
        if (fn === Function || fn === eval) return EMPTY;
        const args = node.args.map((n) => evaluate(n, context, local)[0]);
        if (args.some((v) => v === void 0) || typeof fn !== "function") return EMPTY;
        return [fn.apply(self, args), void 0];
      case 3:
        const consequent = evaluate(node.consequent, context, local);
        const alternate = evaluate(node.alternate, context, local);
        return evaluate(node.test, context, local)[0] ? consequent : alternate;
      case 4:
        if (FORBIDDEN_KEYS.includes(node.name)) return EMPTY;
        return [local[node.name] || context[node.name], void 0];
      case 5:
        return [node.value, void 0];
      case 6:
        const object = evaluate(node.object, context, local)[0];
        const property = node.computed ? evaluate(node.property, context, local)[0] : node.property.name;
        if (FORBIDDEN_KEYS.includes(property)) return EMPTY;
        return object ? [object[property], object] : [void 0, void 0];
      case 7:
        const arg = evaluate(node.argument, context, local)[0];
        if (arg === void 0 && node.operator !== "!") return EMPTY;
        return [UNARY_OPS[node.operator](arg), void 0];
    }
  }
  function compile(expr) {
    const node = parseSyntaxTree(expr);
    if (!node) return (_context = {}) => void 0;
    return (context = {}, local = {}) => evaluate(node, context, local)[0];
  }
  var TEMPLATE = /\${([^}]+)}/g;
  function compileString(expr, isAttribute = false) {
    const parts = expr.split(TEMPLATE);
    const fns = parts.map((p, i) => i % 2 ? compile(p.replace(/Ã—/g, "*")) : void 0);
    return (context) => {
      return parts.map((p, i) => {
        if (!(i % 2)) return p;
        const value = fns[i](context);
        return !isAttribute && typeof value === "number" && value < 0 ? `\u2013${-value}` : value;
      }).join("");
    };
  }
  var touchSupport = "ontouchstart" in window;
  var pointerSupport = "onpointerdown" in window;
  function pointerPosition(e) {
    if (e.touches) {
      const touches = e.targetTouches.length ? e.targetTouches : e.changedTouches;
      return new Point(touches[0].clientX, touches[0].clientY);
    } else {
      return new Point(e.clientX || 0, e.clientY || 0);
    }
  }
  function getTouches(e) {
    return e.touches || [];
  }
  function svgPointerPosn(event, $svg) {
    const posn = pointerPosition(event);
    return posn.transform($svg.inverseTransformMatrix);
  }
  function canvasPointerPosition(event, $canvas) {
    const posn = pointerPosition(event);
    const bounds = $canvas.bounds;
    const x = (posn.x - bounds.left) * $canvas.canvasWidth / bounds.width;
    const y = (posn.y - bounds.top) * $canvas.canvasHeight / bounds.height;
    return new Point(x, y);
  }
  function getEventTarget(event) {
    if (event instanceof PointerEvent && event.pointerType === "mouse") {
      return $(event.target);
    }
    const posn = pointerPosition(event);
    return $(document.elementFromPoint(posn.x, posn.y) || void 0);
  }
  function stopEvent(event) {
    event.stopPropagation();
    event.preventDefault();
  }
  function makeTapEvent($el) {
    if ($el._data["tapEvent"]) return;
    $el._data["tapEvent"] = true;
    let start = void 0;
    $el.on("pointerdown", (e) => start = pointerPosition(e));
    $el.on("pointerup", (e) => {
      if (!start) return;
      const end = pointerPosition(e);
      if (Point.distance(start, end) < 6) $el.trigger("tap", e);
      start = void 0;
    });
    $el.on("pointercancel", () => start = void 0);
  }
  function makeClickOutsideEvent($el) {
    if ($el._data["clickOutsideEvent"]) return;
    $el._data["clickOutsideEvent"] = true;
    $body.on("pointerdown", (e) => {
      const target = e.composedPath()[0] || e.target;
      if (!target || $el._el === target || $el._el.contains(target)) return;
      $el.trigger("clickOutside", e);
    });
  }
  function slide($el, fns) {
    const $box = fns.$box || $el;
    let posn = pointerPosition;
    if ($box.type === "svg") {
      posn = (e) => svgPointerPosn(e, $box.$ownerSVG);
    } else if ($box.type === "canvas") {
      posn = (e) => canvasPointerPosition(e, $box);
    }
    const $parent = fns.justInside ? $el : $body;
    let startPosn = void 0;
    let lastPosn = void 0;
    let hasMoved = false;
    let pointerId = 0;
    if ($el.css("touch-action") === "auto") $el.css("touch-action", "none");
    $el.addClass("noselect");
    function start(e) {
      if (e.handled || getTouches(e).length > 1) return;
      e.preventDefault();
      hasMoved = false;
      pointerId = e.pointerId || 0;
      $parent.on("pointermove", move);
      $parent.on("pointerstop", end);
      startPosn = lastPosn = posn(e);
      if (fns.down) fns.down(startPosn);
    }
    function move(e) {
      if (!startPosn) return;
      if (pointerId && e.pointerId !== pointerId) return;
      e.preventDefault();
      const p = posn(e);
      if (Point.distance(p, lastPosn) < 0.5) return;
      if (!hasMoved && fns.start) fns.start(startPosn);
      if (fns.move) fns.move(p, startPosn, lastPosn);
      lastPosn = p;
      hasMoved = true;
    }
    function end(e, preventClick = false) {
      if (!startPosn) return;
      if (pointerId && e.pointerId !== pointerId) return;
      e.preventDefault();
      $parent.off("pointermove", move);
      $parent.off("pointerstop", end);
      if (fns.up) fns.up(lastPosn, startPosn);
      if (hasMoved && fns.end) fns.end(lastPosn, startPosn);
      if (!hasMoved && fns.click && !preventClick) fns.click(startPosn);
      startPosn = void 0;
    }
    $body.onKey("Escape", () => {
      if (!startPosn) return;
      if (hasMoved && fns.move) fns.move(startPosn, startPosn, lastPosn);
      lastPosn = startPosn;
      const event = document.createEvent("MouseEvent");
      event.pointerId = pointerId;
      end(event, true);
    });
    $el.on("pointerdown", start);
    if (fns.justInside) $el.on("mouseleave", end);
    if (fns.accessible) {
      $el.setAttr("tabindex", "0");
      document.addEventListener("keydown", (e) => {
        if (![37, 38, 39, 40].includes(e.keyCode)) return;
        if ($el !== Browser.getActiveInput()) return;
        const center = $el.boxCenter;
        const start2 = posn({ clientX: center.x, clientY: center.y });
        const dx = e.keyCode === 37 ? -25 : e.keyCode === 39 ? 25 : 0;
        const dy = e.keyCode === 38 ? -25 : e.keyCode === 40 ? 25 : 0;
        const end2 = start2.shift(dx, dy);
        if (fns.down) fns.down(start2);
        if (fns.start) fns.start(start2);
        if (fns.move) fns.move(end2, start2, start2);
        if (fns.end) fns.end(end2, start2);
      });
    }
  }
  function makeScrollEvents($el) {
    if ($el._data["scrollEvents"]) return;
    $el._data["scrollEvents"] = true;
    let ticking = false;
    let top = void 0;
    function tick() {
      const newTop = $el.scrollTop;
      if (newTop === top) {
        ticking = false;
        return;
      }
      top = newTop;
      $el.trigger("scroll", { top });
      window.requestAnimationFrame(tick);
    }
    function scroll() {
      if (!ticking) window.requestAnimationFrame(tick);
      ticking = true;
    }
    const target = $el.type === "window" ? window : $el._el;
    target.addEventListener("scroll", scroll);
    function touchStart() {
      window.addEventListener("touchmove", scroll);
      window.addEventListener("touchend", touchEnd);
    }
    function touchEnd() {
      window.removeEventListener("touchmove", scroll);
      window.removeEventListener("touchend", touchEnd);
    }
    $el._el.addEventListener("touchstart", function(e) {
      if (!e.handled) touchStart();
    });
  }
  function hover($el, options) {
    const $clickTarget = options.$clickTarget || $el;
    let timeout = 0;
    let active2 = false;
    let wasTriggeredByMouse = false;
    let wasTriggeredByFocus = false;
    function enter2() {
      if (active2) return;
      if (options.enter) options.enter();
      active2 = true;
    }
    function exit2() {
      if (!active2) return;
      clearTimeout(timeout);
      if (options.exit) options.exit();
      active2 = false;
    }
    $el.on("mouseover", () => {
      if (options.preventMouseover && options.preventMouseover()) return;
      clearTimeout(timeout);
      timeout = delay(() => {
        enter2();
        wasTriggeredByMouse = true;
      }, options.delay);
    });
    $el.on("mouseout", () => {
      if (!wasTriggeredByMouse) return;
      clearTimeout(timeout);
      timeout = delay(exit2, options.exitDelay || options.delay);
    });
    $clickTarget.on("focus", () => {
      if (active2 || options.preventMouseover && options.preventMouseover()) return;
      clearTimeout(timeout);
      enter2();
      wasTriggeredByFocus = true;
    });
    const onBlur = () => {
      if (!wasTriggeredByFocus) return;
      if (options.canFocusWithin) {
        setTimeout(() => {
          const $newActive = Browser.getActiveInput();
          if ($newActive && $newActive.hasParent($el)) {
            $newActive.one("blur", onBlur);
          } else {
            exit2();
          }
        });
      } else {
        exit2();
      }
    };
    $clickTarget.on("blur", onBlur);
    $clickTarget.on("click", () => {
      if (active2 && !wasTriggeredByMouse) {
        exit2();
      } else if (!active2) {
        enter2();
        wasTriggeredByMouse = false;
      }
    });
    $el.on("clickOutside", exit2);
  }
  var observer;
  function intersectionCallback(entries) {
    for (const e of entries) {
      const event = e.isIntersecting ? "enterViewport" : "exitViewport";
      setTimeout(() => $(e.target).trigger(event));
    }
  }
  function makeIntersectionEvents($el) {
    if ($el._data["intersectionEvents"]) return;
    $el._data["intersectionEvents"] = true;
    if (!window.IntersectionObserver) {
      let wasVisible = false;
      $body.on("scroll", () => {
        const isVisible = $el.isInViewport;
        if (wasVisible && !isVisible) {
          $el.trigger("exitViewport");
          wasVisible = false;
        } else if (isVisible && !wasVisible) {
          $el.trigger("enterViewport");
          wasVisible = true;
        }
      });
      return;
    }
    if (!observer) observer = new IntersectionObserver(intersectionCallback);
    observer.observe($el._el);
  }
  function makeResizeEvents($el, remove = false) {
    if (remove) {
      if ($el._data["resizeObserver"]) $el._data["resizeObserver"].disconnect();
      $el._data["resizeObserver"] = void 0;
    }
    if ($el._data["resizeObserver"]) return;
    if (window.ResizeObserver) {
      const observer2 = new window.ResizeObserver(() => $el.trigger("resize"));
      observer2.observe($el._el);
      $el._data["resizeObserver"] = observer2;
    } else if (window.MutationObserver) {
      const observer2 = new MutationObserver(() => $el.trigger("resize"));
      observer2.observe($el._el, { attributes: true, childList: true, characterData: true, subtree: true });
      $el._data["resizeObserver"] = observer2;
    }
  }
  function makePointerPositionEvents($el) {
    if ($el._data["pointerPositionEvents"]) return;
    $el._data["pointerPositionEvents"] = true;
    const parent = $el.parent;
    let isInside;
    parent.on("pointerend", () => isInside = void 0);
    parent.on("pointermove", (e) => {
      const wasInside = isInside;
      const target = getEventTarget(e);
      isInside = target.equals($el) || target.hasParent($el);
      if (wasInside !== void 0 && isInside && !wasInside) $el.trigger("pointerenter", e);
      if (!isInside && wasInside) $el.trigger("pointerleave", e);
    });
  }
  function makeMouseEvent(eventName, $el) {
    if ($el._data[`_${eventName}`]) return;
    $el._data[`_${eventName}`] = true;
    if (pointerSupport) {
      $el.on(eventName.replace("mouse", "pointer"), (e) => {
        if (e.pointerType === "mouse") $el.trigger(eventName, e);
      });
    } else if (!touchSupport) {
      $el._el.addEventListener(eventName, (e) => $el.trigger(eventName, e));
    }
  }
  function makeKeyEvent($el) {
    $el.on("keydown", (e) => {
      if (e.metaKey || e.ctrlKey) return;
      if (Browser.isAndroid && e.keyCode === 229) return;
      const key = e.key || String.fromCharCode(e.which);
      const shift = !!e.shiftKey;
      $el.trigger("key", { code: e.keyCode, key, char: key, shift });
    });
    if (Browser.isAndroid && $el.type === "input") {
      $el.on("input", (e) => {
        const key = e.key || e.data[e.data.length - 1];
        $el.trigger("key", { code: void 0, key, char: key });
        $el.value = "";
      });
    }
  }
  var aliases = {
    scrollwheel: "DOMMouseScroll mousewheel",
    pointerdown: pointerSupport ? "pointerdown" : touchSupport ? "touchstart" : "mousedown",
    pointermove: pointerSupport ? "pointermove" : touchSupport ? "touchmove" : "mousemove",
    pointerup: pointerSupport ? "pointerup" : touchSupport ? "touchend" : "mouseup",
    pointercancel: pointerSupport ? "pointercancel" : "touchcancel",
    pointerstop: pointerSupport ? "pointerup pointercancel" : touchSupport ? "touchend touchcancel" : "mouseup"
  };
  var customEvents = {
    scroll: makeScrollEvents,
    tap: makeTapEvent,
    clickOutside: makeClickOutsideEvent,
    key: makeKeyEvent,
    mousedown: makeMouseEvent.bind(void 0, "mousedown"),
    mousemove: makeMouseEvent.bind(void 0, "mousemove"),
    mouseup: makeMouseEvent.bind(void 0, "mouseup"),
    pointerenter: makePointerPositionEvents,
    pointerleave: makePointerPositionEvents,
    enterViewport: makeIntersectionEvents,
    exitViewport: makeIntersectionEvents,
    resize: makeResizeEvents
  };
  function bindEvent($el, event, fn, options) {
    if (event in customEvents) {
      customEvents[event]($el, false);
    } else if (event in aliases) {
      const events = words(aliases[event]);
      for (const e of events) $el._el.addEventListener(e, fn, options);
    } else {
      $el._el.addEventListener(event, fn, options);
    }
  }
  function unbindEvent($el, event, fn) {
    if (event in customEvents) {
      if (!$el._events[event] || !$el._events[event].length) {
        customEvents[event]($el, true);
      }
    } else if (fn && event in aliases) {
      const events = words(aliases[event]);
      for (const e of events) $el._el.removeEventListener(e, fn);
    } else if (fn) {
      $el._el.removeEventListener(event, fn);
    }
  }
  var batchDepth = 0;
  var batchedCallbacks = /* @__PURE__ */ new Map();
  function enqueueCallback(callback, state) {
    batchedCallbacks.set(callback, state);
  }
  function batch(callback) {
    batchDepth++;
    callback();
    batchDepth--;
    if (batchDepth === 0) {
      for (const [callback2, state] of batchedCallbacks.entries()) callback2(state);
      batchedCallbacks.clear();
    }
  }
  function observe(state, parentModel) {
    const callbackMap = /* @__PURE__ */ new Map();
    const computedKeys = /* @__PURE__ */ new Map();
    const watchAllCallbacks = /* @__PURE__ */ new Set();
    let pendingCallback = void 0;
    let lastKey = 0;
    function watch(callback) {
      pendingCallback = callback;
      const result = callback(proxy, true);
      pendingCallback = void 0;
      return result;
    }
    function watchKeys(keys, fn) {
      for (const key of keys.split(" ")) {
        if (!callbackMap.has(key)) callbackMap.set(key, /* @__PURE__ */ new Set());
        callbackMap.get(key).add(fn);
      }
      return fn(proxy, true);
    }
    function unwatch(callback) {
      for (const callbacks of callbackMap.values()) {
        if (callbacks.has(callback)) callbacks.delete(callback);
      }
      watchAllCallbacks.delete(callback);
    }
    function watchAll(callback, dontRun) {
      watchAllCallbacks.add(callback);
      return dontRun ? void 0 : callback(proxy, true);
    }
    function setComputed(key, expr) {
      if (computedKeys.has(key)) unwatch(computedKeys.get(key));
      const callback = () => {
        state[key] = expr(proxy);
        if (pendingCallback === callback) pendingCallback = void 0;
        triggerCallbacks(key);
      };
      computedKeys.set(key, callback);
      watch(callback);
    }
    function triggerCallbacks(key) {
      if (batchDepth > 0) {
        for (const callback of callbackMap.get(key) || []) enqueueCallback(callback, state);
        for (const callback of watchAllCallbacks) enqueueCallback(callback, state);
      } else {
        for (const callback of callbackMap.get(key) || []) callback(state);
        for (const callback of watchAllCallbacks) callback(state);
      }
    }
    function forceUpdate() {
      for (const callbacks of callbackMap.values()) {
        for (const callback of callbacks) callback(state);
      }
      for (const callback of watchAllCallbacks) callback(state);
    }
    function assign2(changes, clear2) {
      if (clear2) state = {};
      batch(() => {
        for (const [key, value] of Object.entries(changes)) {
          if (!(key in previous)) previous[key] = state[key];
          proxy[key] = value;
        }
      });
    }
    function getKey() {
      lastKey += 1;
      while (`_x${lastKey}` in state) lastKey += 1;
      return `_x${lastKey}`;
    }
    function clear() {
      state = {};
      callbackMap.clear();
      computedKeys.clear();
      lastKey = 0;
    }
    function copy() {
      return Object.assign({}, state);
    }
    let previous = {};
    function getChanges() {
      const changes = [{}, {}];
      for (const k of Object.keys(previous)) {
        if (previous[k] === state[k]) continue;
        changes[0][k] = previous[k];
        changes[1][k] = state[k];
      }
      previous = {};
      return changes;
    }
    function inherit(key) {
      if (!parentModel) return;
      parentModel.watch(() => proxy[key] = parentModel[key]);
    }
    const proxy = new Proxy(state, {
      get(_, key) {
        if (key === "watch") return watch;
        if (key === "watchKeys") return watchKeys;
        if (key === "unwatch") return unwatch;
        if (key === "watchAll") return watchAll;
        if (key === "setComputed") return setComputed;
        if (key === "forceUpdate") return forceUpdate;
        if (key === "getChanges") return getChanges;
        if (key === "assign") return assign2;
        if (key === "getKey") return getKey;
        if (key === "clear") return clear;
        if (key === "copy") return copy;
        if (key === "_internal") return [state, callbackMap];
        if (pendingCallback) {
          if (!callbackMap.has(key)) callbackMap.set(key, /* @__PURE__ */ new Set());
          callbackMap.get(key).add(pendingCallback);
        }
        if (!(key in state)) inherit(key);
        return state[key];
      },
      set(_, key, value) {
        if (state[key] === value) return true;
        if (!(key in previous)) previous[key] = state[key];
        state[key] = value;
        if (computedKeys.has(key)) {
          unwatch(computedKeys.get(key));
          computedKeys.delete(key);
        }
        triggerCallbacks(key);
        return true;
      },
      deleteProperty(_, p) {
        delete state[p];
        callbackMap.delete(p);
        computedKeys.delete(p);
        return true;
      }
    });
    return proxy;
  }
  var pathLength = { A: 7, C: 6, H: 1, L: 2, M: 2, Q: 4, S: 4, T: 2, V: 1, Z: 0 };
  var pathSegment = /[astvzqmhlc]([^astvzqmhlc]*)/ig;
  var pathPoint = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
  function pathCommands(path) {
    const commands = [];
    let lastPoint = void 0;
    for (const match of path.match(pathSegment) || []) {
      const uType = match[0].toUpperCase();
      if (uType === "Z") {
        commands.push({ type: "Z", points: [] });
        continue;
      }
      const args = (match.slice(1).match(pathPoint) || []).map((p) => +p);
      const isAbsolute = uType === match[0];
      for (const [i, p] of chunk(args, pathLength[uType]).entries()) {
        let points = [];
        let type = uType === "M" && i > 0 ? "L" : uType;
        let options = void 0;
        if (uType === "H") {
          type = "L";
          points = [new Point(p[0], isAbsolute ? (lastPoint == null ? void 0 : lastPoint.y) || 0 : 0)];
        } else if (uType === "V") {
          type = "L";
          points = [new Point(isAbsolute ? (lastPoint == null ? void 0 : lastPoint.x) || 0 : 0, p[0])];
        } else if (uType === "A") {
          type = "A";
          points = [new Point(p[5], p[6])];
          options = p.slice(0, 5);
        } else if ("MLCSQT".includes(uType)) {
          points = chunk(p, 2).map((q) => new Point(q[0], q[1]));
        }
        if (!isAbsolute && lastPoint) points = points.map((p2) => p2.translate(lastPoint));
        lastPoint = last(points);
        commands.push({ type, points, options });
      }
    }
    return commands;
  }
  function parsePath(d) {
    if (!d) return [];
    const commands = pathCommands(d);
    return commands.map((c) => last(c.points)).filter((p) => !!p);
  }
  var COMMON_STYLES = [
    "font-family",
    "font-size",
    "font-style",
    "font-weight",
    "letter-spacing",
    "text-decoration",
    "color",
    "display",
    "visibility",
    "alignment-baseline",
    "baseline-shift",
    "opacity",
    "text-anchor",
    "clip",
    "clip-path",
    "clip-rule",
    "mask",
    "filter",
    "transform",
    "transform-origin",
    "white-space",
    "line-height"
  ];
  var SVG_STYLES = [
    "fill",
    "fill-rule",
    "marker",
    "marker-start",
    "marker-mid",
    "marker-end",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-width",
    "text-rendering",
    "dominant-baseline",
    "transform-box",
    "paint-order"
  ];
  var HTML_STYLES = [
    "padding",
    "min-width",
    "max-width",
    "height",
    "border-width",
    "border-style",
    "border-color",
    "box-sizing",
    "background",
    "width",
    "grid-template-columns",
    "text-align"
  ];
  var REMOVE_ATTRIBUTES = ["class", "tabindex", "contenteditable"];
  var DONT_INHERIT = /* @__PURE__ */ new Set(["opacity", "transform-box", "transform-origin", "border-width", "border-style", "border-color"]);
  var STYLE_DEFAULTS = {
    "font-style": "normal",
    "font-weight": "400",
    "letter-spacing": "normal",
    "text-decoration": "none",
    "display": "block",
    "visibility": "visible",
    "alignment-baseline": "auto",
    "baseline-shift": "0px",
    "text-anchor": "start",
    "clip": "auto",
    "clip-path": "none",
    "clip-rule": "nonzero",
    "mask": "none",
    "opacity": "1",
    "filter": "none",
    "fill": "rgb(0, 0, 0)",
    "fill-rule": "nonzero",
    "marker": "none",
    "stroke": "none",
    "stroke-dasharray": "none",
    "stroke-dashoffset": "0px",
    "stroke-linecap": "butt",
    "stroke-linejoin": "miter",
    "stroke-width": "1px",
    "text-rendering": "auto",
    "transform": "none",
    "dominant-baseline": "auto",
    "transform-origin": "0px 0px",
    "transform-box": "view-box",
    "paint-order": "normal"
  };
  function cleanSVG(node) {
    var _a22, _b;
    if (node.getAttribute("hidden") || node.style.opacity === "0" || node.style.display === "none") {
      (_a22 = node.parentNode) == null ? void 0 : _a22.removeChild(node);
    } else {
      for (const child of Array.from(node.children)) cleanSVG(child);
      if (node.tagName === "g" && node.childElementCount === 0) {
        (_b = node.parentNode) == null ? void 0 : _b.removeChild(node);
      } else {
        for (const a2 of REMOVE_ATTRIBUTES) {
          if (node.hasAttribute(a2)) node.removeAttribute(a2);
        }
      }
    }
  }
  function inheritedStyle(node, prop) {
    let n = node.parentElement;
    while (n) {
      const value = n.style.getPropertyValue(prop);
      if (value) return value;
      n = n.parentElement;
    }
  }
  function copySVGStyles(source, copy, isHTML = false) {
    const style2 = window.getComputedStyle(source);
    copy.removeAttribute("style");
    const html = isHTML || source.tagName === "foreignObject";
    const properties = [...COMMON_STYLES, ...html ? HTML_STYLES : SVG_STYLES];
    for (const p of properties) {
      const value = style2.getPropertyValue(p);
      const inherited = inheritedStyle(copy, p);
      if (value === STYLE_DEFAULTS[p] && !inherited) continue;
      if (!DONT_INHERIT.has(p) && value === inherited) continue;
      copy.style.setProperty(p, value);
    }
    const sourceChildren = source.children;
    const copyChildren = copy.children;
    for (let i = 0; i < copyChildren.length; ++i) {
      copySVGStyles(sourceChildren[i], copyChildren[i], html);
    }
  }
  var BaseView = class {
    constructor(_el) {
      this._el = _el;
      this._data = {};
      this._events = {};
      this.type = "default";
      _el._view = this;
    }
    get id() {
      return this._el.id;
    }
    get data() {
      return this._el.dataset;
    }
    get tagName() {
      return this._el.tagName.toUpperCase();
    }
    equals(el) {
      return this._el === el._el;
    }
    /** Adds one or more space-separated classes to this element. */
    addClass(className) {
      for (const c of words(className)) this._el.classList.add(c);
    }
    removeClass(className) {
      for (const c of words(className)) this._el.classList.remove(c);
    }
    hasClass(className) {
      return this._el.classList.contains(className);
    }
    toggleClass(className) {
      return this._el.classList.toggle(className);
    }
    /** Toggles multiple space-separated class names based on a condition. */
    setClass(className, condition) {
      if (condition) {
        this.addClass(className);
      } else {
        this.removeClass(className);
      }
    }
    attr(attr) {
      return this._el.getAttribute(attr) || "";
    }
    hasAttr(attr) {
      return this._el.hasAttribute(attr);
    }
    setAttr(attr, value) {
      if (value === void 0) {
        this.removeAttr(attr);
      } else {
        this._el.setAttribute(attr, `${value}`);
      }
    }
    removeAttr(attr) {
      this._el.removeAttribute(attr);
    }
    get attributes() {
      return Array.from(this._el.attributes || []);
    }
    get html() {
      return this._el.innerHTML || "";
    }
    set html(h) {
      this._el.innerHTML = h;
    }
    get text() {
      return this._el.textContent || "";
    }
    set text(t) {
      this._el.textContent = t;
    }
    // Required because TS doesn't allow getters and setters with different types.
    set textStr(t) {
      this._el.textContent = `${t}`;
    }
    /** Blurs this DOM element. */
    blur() {
      this._el.blur();
    }
    /** Focuses this DOM element. */
    focus() {
      this._el.focus();
    }
    // ---------------------------------------------------------------------------
    // Templates and Model Binding
    getParentModel() {
      const parent = this.parent;
      return parent ? parent.model || parent.getParentModel() : void 0;
    }
    bindModel(model, recursive = true) {
      var _a22;
      if (this.model) return;
      this.model = model;
      if (this.hasAttr(":for")) return this.makeDynamicList(model);
      for (const { name, value } of this.attributes) {
        this.makeDynamicAttribute(name, value, model);
      }
      for (const $c of this.childNodes) {
        if ($c instanceof Text) {
          if ((_a22 = $c.textContent) == null ? void 0 : _a22.includes("${")) {
            const expr = compileString($c.textContent);
            model.watch(() => $c.textContent = expr(model) || "");
          }
        } else if (recursive) {
          $c.bindModel(model);
        }
      }
    }
    bindVariable(_model, _name) {
    }
    /** Conditionally hide this element from the DOM (using placeholder comments). */
    toggleDOM(show = true) {
      if (show === !!this._el.parentNode) return;
      if (!this.$placeholder) {
        this.$placeholder = $(document.createComment(""));
        this.insertBefore(this.$placeholder);
      }
      if (show) {
        this.$placeholder.insertBefore(this);
      } else {
        this.detach();
      }
    }
    makeDynamicAttribute(name, value, model) {
      if (name.startsWith("@")) {
        const event = name.slice(1);
        const expr = compile(value);
        this.on(event, (e) => expr(model, { $event: e }));
      } else if (name === ":show") {
        const expr = compile(value);
        model.watch(() => this.toggle(!!expr(model)));
      } else if (name === ":if") {
        const expr = compile(value);
        model.watch(() => this.toggleDOM(!!expr(model)));
      } else if (name === ":html") {
        const expr = compile(value);
        model.watch(() => this.html = expr(model) || "");
      } else if (name === ":draw") {
        const expr = compile(value);
        model.watch(() => this.draw(expr(model)));
      } else if (name === ":class") {
        const expr = compile(value);
        const initialClass = `${this.attr("class")} `;
        model.watch(() => this.setAttr("class", initialClass + expr(model)));
      } else if (name === ":bind") {
        this.bindVariable(model, value);
      } else if (name.startsWith(":")) {
        const expr = compile(value);
        const attr = name.slice(1);
        model.watch(() => this.setAttr(attr, expr(model)));
      } else if (value.includes("${")) {
        const expr = compileString(value, true);
        model.watch(() => this.setAttr(name, expr(model) || ""));
      }
      if (name.startsWith("@") || name.startsWith(":")) this.removeAttr(name);
    }
    makeDynamicList(model) {
      const [name, value] = this.attr(":for").split(" in ");
      this.removeAttr(":for");
      const expr = compile(value);
      const $placeholder = $(document.createComment(""));
      this.insertBefore($placeholder);
      this.detach();
      const $cached = [];
      let visible = 0;
      model.watch(() => {
        let array = expr(model);
        if (!Array.isArray(array)) array = [];
        for (let i = array.length; i < visible; ++i) $cached[i].detach();
        for (let i = visible; i < $cached.length; ++i) $placeholder.insertBefore($cached[i]);
        for (let i = $cached.length; i < array.length; ++i) {
          const $el = this.copy(true);
          $el.bindModel(observe({ [name]: void 0 }, model));
          $placeholder.insertBefore($el);
          $cached.push($el);
        }
        visible = array.length;
        for (let i = 0; i < visible; ++i) $cached[i].model[name] = array[i];
      });
    }
    // -------------------------------------------------------------------------
    // Scrolling and Dimensions
    get bounds() {
      return this._el.getBoundingClientRect();
    }
    get boundsRect() {
      const bounds = this.bounds;
      return new Rectangle(new Point(bounds.x, bounds.y), bounds.width, bounds.height);
    }
    contains(point) {
      return this.boundsRect.contains(point);
    }
    /** Checks if this element is currently visible in the viewport. */
    get isInViewport() {
      if (this.height === 0) return false;
      const bounds = this.bounds;
      return isBetween(bounds.top, -bounds.height, Browser.height);
    }
    get topLeftPosition() {
      const bounds = this.bounds;
      return new Point(bounds.left, bounds.top);
    }
    get boxCenter() {
      const box = this.bounds;
      return new Point(box.left + box.width / 2, box.top + box.height / 2);
    }
    get scrollWidth() {
      return this._el.scrollWidth;
    }
    get scrollHeight() {
      return this._el.scrollHeight;
    }
    get scrollTop() {
      return this._el.scrollTop;
    }
    set scrollTop(y) {
      this._el.scrollTop = y;
      this.trigger("scroll", { top: y, left: this.scrollLeft });
    }
    get scrollLeft() {
      return this._el.scrollLeft;
    }
    set scrollLeft(x) {
      this._el.scrollLeft = x;
      this.trigger("scroll", { top: this.scrollTop, left: x });
    }
    /** Scrolls the element to a specific position. */
    scrollTo(pos, time = 1e3, easing = "cubic") {
      if (pos < 0) pos = 0;
      const startPosition = this.scrollTop;
      const distance2 = pos - startPosition;
      if (this._data.scrollAnimation) this._data.scrollAnimation.cancel();
      this._data.scrollAnimation = animate((t) => {
        const y = startPosition + distance2 * ease(easing, t);
        this.scrollTop = y;
        this.trigger("scroll", { top: y });
      }, time);
    }
    /** Scrolls the element by a given distance. */
    scrollBy(distance2, time = 1e3, easing = "cubic") {
      if (!distance2) return;
      this.scrollTo(this.scrollTop + distance2, time, easing);
    }
    // -------------------------------------------------------------------------
    // Styles
    /**
     * Retrieves or sets CSS properties on this element. Examples:
     *   * $el.css('color');  // returns 'red'
     *   * $el.css('color', 'blue');
     *   * $el.css({color: 'blue'});
     */
    css(props, value) {
      if (value === void 0) {
        if (typeof props === "string") {
          return window.getComputedStyle(this._el).getPropertyValue(props);
        } else {
          const keys = Object.keys(props);
          for (const p of keys) this._el.style.setProperty(p, `${props[p]}`);
        }
      } else if (typeof props === "string") {
        this._el.style.setProperty(props, `${value}`);
      }
    }
    /** Shortcut for getting the CSS transform style of an element. */
    get transform() {
      return this.css("transform").replace("none", "");
    }
    get transformMatrix() {
      const transform2 = this.transform;
      if (!transform2) return [[1, 0, 0], [0, 1, 0]];
      const coords = transform2.match(/matrix\(([0-9,.\s-]*)\)/);
      if (!coords || !coords[1]) return [[1, 0, 0], [0, 1, 0]];
      const matrix = coords[1].split(",");
      return [
        [+matrix[0], +matrix[2], +matrix[4]],
        [+matrix[1], +matrix[3], +matrix[5]]
      ];
    }
    /** Finds the x and y scale of this element. */
    get scale() {
      const matrix = this.transformMatrix;
      return [matrix[0][0], matrix[1][1]];
    }
    /** Sets the CSS transform on this element. */
    setTransform(posn, angle = 0, scale = 1) {
      let t = "";
      if (posn) t += `translate(${roundTo(posn.x, 0.1)}px,${roundTo(posn.y, 0.1)}px)`;
      if (angle) t += ` rotate(${angle}rad)`;
      if (scale) t += ` scale(${scale})`;
      this._el.style.transform = t;
    }
    /** Sets the CSS transform of this element to an x/y translation. */
    translate(x, y) {
      this.setTransform(new Point(x, y));
    }
    /**
     * Makes the element visible. Use the `data-display` attribute to determine
     * how this is done. Possible options are `visibility`, to use CSS visibility,
     * or CSS display values. The default is `display: block`.
     */
    show() {
      if (this.hasAttr("hidden")) this.removeAttr("hidden");
      if (this.data["display"] === "visibility") {
        this._el.style.visibility = "visible";
      } else {
        this._el.style.display = this.data.display || "block";
      }
    }
    /**
     * Makes the element invisible, using CSS visibility (if
     * `data-display="visibility"`), or `display: none`.
     */
    hide() {
      if (this.data["display"] === "visibility") {
        this._el.style.visibility = "hidden";
      } else {
        this._el.style.display = "none";
      }
    }
    /** Hides or shows the element based on a boolean value. */
    toggle(show) {
      if (show) {
        this.show();
      } else {
        this.hide();
      }
    }
    // -------------------------------------------------------------------------
    // DOM Manipulation
    /** Checks if an element matches a given CSS selector. */
    is(selector) {
      if (this._el.matches) return this._el.matches(selector);
      return Array.from(document.querySelectorAll(selector)).includes(this._el);
    }
    /** Finds the index of an elements, in the list of its siblings. */
    index() {
      let i = 0;
      let child = this._el;
      while ((child = child.previousSibling || void 0) !== void 0) ++i;
      return i;
    }
    /** Adds a new child element at the beginning of this one. */
    prepend(newChild) {
      const children = this._el.childNodes;
      if (children.length) {
        this._el.insertBefore(newChild._el, children[0]);
      } else {
        this._el.appendChild(newChild._el);
      }
    }
    /** Adds a new child element at the end of this one. */
    append(newChild) {
      this._el.appendChild(newChild instanceof Text ? newChild : newChild._el);
    }
    /** Adds a new element immediately before this one, as a sibling. */
    insertBefore(newChild) {
      this.parent._el.insertBefore(newChild._el, this._el);
    }
    /** Adds a new element immediately after this one, as a sibling. */
    insertAfter(newChild) {
      const next = this._el.nextSibling;
      if (next) {
        this.parent._el.insertBefore(newChild._el, next);
      } else {
        this.parent._el.appendChild(newChild._el);
      }
    }
    /** Returns this element's next sibling, or undefined. */
    get next() {
      return $(this._el.nextSibling);
    }
    /** Returns this element's previous sibling, or undefined. */
    get prev() {
      return $(this._el.previousSibling);
    }
    /** The first child element matching a given selector. */
    $(selector) {
      return $(selector, this);
    }
    /** All child elements matching a given selector. */
    $$(selector) {
      return $$(selector, this);
    }
    /** Returns this element's parent, or undefined. */
    get parent() {
      return $(this._el.parentElement || void 0);
    }
    /** Finds all parent elements that match a specific selector. */
    parents(selector) {
      const result = [];
      let parent = this.parent;
      while (parent) {
        if (!selector || parent.is(selector)) result.push(parent);
        parent = parent.parent;
      }
      return result;
    }
    /** Checks if this element has one of the given elements as parent. */
    hasParent(...$p) {
      const tests = $p.map((p) => p._el);
      let parent = this._el.parentNode;
      while (parent) {
        if (isOneOf(parent, ...tests)) return true;
        parent = parent.parentNode;
      }
      return false;
    }
    /** Returns an array of all children of this element. */
    get children() {
      return Array.from(this._el.children || [], (n) => $(n));
    }
    /** Returns an array of all child nodes, including text nodes. */
    get childNodes() {
      return Array.from(this._el.childNodes, (node) => {
        if (node instanceof Comment) return void 0;
        if (node instanceof Text) return node;
        return $(node);
      }).filter((x) => x);
    }
    /** Detach and re-insert to restart CSS animations. */
    restartAnimation() {
      const n = this.next;
      const p = this.parent;
      this.detach();
      if (n) {
        n.insertBefore(this);
      } else {
        p.append(this);
      }
    }
    /** Detaches an element from the DOM. */
    detach() {
      if (this._el && this._el.parentNode) {
        this._el.parentNode.removeChild(this._el);
      }
    }
    /** Removes this element. */
    remove() {
      this.detach();
    }
    /** Removes all children of this element. */
    removeChildren() {
      while (this._el.firstChild) this._el.removeChild(this._el.firstChild);
    }
    /** Creates a copy of this element, and optionally its children. */
    copy(recursive = true) {
      return $(this._el.cloneNode(recursive));
    }
    // -------------------------------------------------------------------------
    // Events
    /** Binds one ore more space-separated event listeners on this element. */
    on(events, callback, options) {
      for (const e of words(events)) {
        if (e in this._events) {
          if (!this._events[e].includes(callback)) this._events[e].push(callback);
        } else {
          this._events[e] = [callback];
        }
        bindEvent(this, e, callback, options);
      }
    }
    /** Binds a one-time event listener on this element. */
    one(events, callback, options) {
      const callbackWrap = (e) => {
        this.off(events, callbackWrap);
        callback(e);
      };
      this.on(events, callbackWrap, options);
    }
    /**
     * Removes an event listener on this element. If callback is undefined, it
     * removes all event listeners for this event.
     */
    off(events, callback) {
      for (const e of words(events)) {
        if (e in this._events) {
          this._events[e] = callback ? this._events[e].filter((fn) => fn !== callback) : [];
        }
        unbindEvent(this, e, callback);
      }
    }
    /** Triggers a specific event on this element. */
    trigger(events, args = {}) {
      for (const e of words(events)) {
        if (!this._events[e]) return;
        for (const fn of this._events[e]) fn.call(this, args);
      }
    }
    /**
     * Binds an event listener for a specific key that is pressed while this
     * element is in focus.
     */
    onKey(keys, callback, options) {
      keys = keys.replace("AllArrows", "ArrowUp ArrowDown ArrowLeft ArrowRight");
      const keyNames = new Set(words(keys));
      const event = (options == null ? void 0 : options.up) ? "keyup" : "keydown";
      const target = this._el === document.body ? document : this._el;
      target.addEventListener(event, (e) => {
        var _a22, _b;
        const key = keyCode(e);
        if ((options == null ? void 0 : options.meta) ? !e.ctrlKey && !e.metaKey : e.ctrlKey || e.metaKey) return;
        if (!key || !keyNames.has(key)) return;
        if (document.activeElement !== this._el && ((_b = (_a22 = document.activeElement) == null ? void 0 : _a22.shadowRoot) == null ? void 0 : _b.activeElement) !== this._el && Browser.formIsActive) return;
        callback(e, key);
      });
    }
    onAttr(name, callback) {
      const observer2 = new MutationObserver((mutations) => {
        for (const m of mutations) {
          if (m.type === "attributes" && m.attributeName === name) {
            callback(this.attr(name));
          }
        }
      });
      observer2.observe(this._el, { attributes: true });
      callback(this.attr(name), true);
    }
    /** Returns a promise that is resolved when an event is triggered. */
    onPromise(event, resolveImmediately = false) {
      if (resolveImmediately) return Promise.resolve();
      return new Promise((resolve) => this.one(event, () => resolve()));
    }
    // -------------------------------------------------------------------------
    // Animations
    /**
     * Animates multiple CSS properties of this element, with a given duration,
     * delay and ease function.
     */
    animate(rules, duration = 400, delay3 = 0, easing = "ease-in-out") {
      return transition(this, rules, duration, delay3, easing);
    }
    /**
     * Runs an enter animation on this element. Valid effect names are
     *   * 'fade', 'pop' and 'descend'
     *   * 'draw' and 'draw-reverse'
     *   * 'slide' and 'slide-down'
     *   * 'reveal', 'reveal-left' and 'reveal-right'
     */
    enter(effect = "fade", duration = 500, delay3 = 0) {
      return enter(this, effect, duration, delay3);
    }
    /**
     * Runs an exit animation on this element. See `.enter()` for options.
     */
    exit(effect = "fade", duration = 500, delay3 = 0, remove = false) {
      return exit(this, effect, duration, delay3, remove);
    }
    /**
     * Triggers a CSS animation in an element by adding a class and removing it
     * after the `animationEnd` event.
     */
    effect(className) {
      this.one("animationend", () => this.removeClass(`effects-${className}`));
      this.addClass(`effects-${className}`);
    }
  };
  var HTMLBaseView = class extends BaseView {
    get offsetTop() {
      return this._el.offsetTop;
    }
    get offsetLeft() {
      return this._el.offsetLeft;
    }
    get offsetParent() {
      return $(this._el.offsetParent || void 0);
    }
    /** Returns this element's width, including border and padding. */
    get width() {
      return this._el.offsetWidth;
    }
    /** Returns this element's height, including border and padding. */
    get height() {
      return this._el.offsetHeight;
    }
    /** Returns this element's width, excluding border and padding. */
    get innerWidth() {
      const left = parseFloat(this.css("padding-left"));
      const right = parseFloat(this.css("padding-right"));
      return this._el.clientWidth - left - right;
    }
    /** Returns this element's height, excluding border and padding. */
    get innerHeight() {
      const bottom = parseFloat(this.css("padding-bottom"));
      const top = parseFloat(this.css("padding-top"));
      return this._el.clientHeight - bottom - top;
    }
    /** Returns this element's width, including margins. */
    get outerWidth() {
      const left = parseFloat(this.css("margin-left"));
      const right = parseFloat(this.css("margin-right"));
      return this.width + left + right || 0;
    }
    /** Returns this element's height, including margins. */
    get outerHeight() {
      const bottom = parseFloat(this.css("margin-bottom"));
      const top = parseFloat(this.css("margin-top"));
      return this.height + bottom + top || 0;
    }
    /** @returns {number} */
    get positionTop() {
      let el = this._el;
      let offset = 0;
      while (el) {
        offset += el.offsetTop;
        el = el.offsetParent;
      }
      return offset;
    }
    /** @returns {number} */
    get positionLeft() {
      let el = this._el;
      let offset = 0;
      while (el) {
        offset += el.offsetLeft;
        el = el.offsetParent;
      }
      return offset;
    }
    /** Calculates the element offset relative to any other parent element. */
    offset(parent) {
      if (parent._el === this._el.offsetParent) {
        const top = this.offsetTop + parent._el.clientTop;
        const left = this.offsetLeft + parent._el.clientLeft;
        const bottom = top + this.height;
        const right = left + this.width;
        return { top, left, bottom, right };
      } else {
        const parentBox = parent._el.getBoundingClientRect();
        const box = this._el.getBoundingClientRect();
        return {
          top: box.top - parentBox.top,
          left: box.left - parentBox.left,
          bottom: box.bottom - parentBox.top,
          right: box.right - parentBox.left
        };
      }
    }
  };
  var SVGBaseView = class extends BaseView {
    constructor() {
      super(...arguments);
      this.type = "svg";
    }
    /** Returns the owner `<svg>` which this element is a child of. */
    get $ownerSVG() {
      return $(this._el.ownerSVGElement || void 0);
    }
    // See https://www.chromestatus.com/features/5724912467574784
    get width() {
      return this.bounds.width;
    }
    get height() {
      return this.bounds.height;
    }
    // SVG Elements don't have offset properties. We instead use the position of
    // the first non-SVG parent, plus the margin of the SVG owner, plus the SVG
    // position of the individual element. This doesn't work for absolutely
    // positioned SVG elements, and some other edge cases.
    get positionLeft() {
      const svgLeft = this._el.getBBox().x + this._el.getCTM().e;
      return this.$ownerSVG.positionLeft + svgLeft;
    }
    get positionTop() {
      const svgTop = this._el.getBBox().y + this._el.getCTM().f;
      return this.$ownerSVG.positionTop + svgTop;
    }
    get inverseTransformMatrix() {
      const m = this._el.getScreenCTM().inverse();
      const matrix = [[m.a, m.c, m.e], [m.b, m.d, m.f]];
      if (Browser.isFirefox) {
        const transform2 = this.transformMatrix;
        matrix[0][2] -= transform2[0][2];
        matrix[1][2] -= transform2[1][2];
      }
      return matrix;
    }
    setTransform(posn, angle = 0, scale = 1) {
      const t1 = posn ? `translate(${roundTo(posn.x, 0.1)} ${roundTo(posn.y, 0.1)})` : "";
      const t2 = nearlyEquals(angle, 0) ? "" : `rotate(${angle * 180 / Math.PI})`;
      const t3 = nearlyEquals(scale, 1) ? "" : `scale(${scale})`;
      this.setAttr("transform", [t1, t2, t3].join(" "));
    }
    /**
     * Finds the total stroke length of this element. Similar to the SVG
     * `getTotalLength()` function, but works for a wider variety of elements.
     */
    get strokeLength() {
      if (this._el instanceof SVGGeometryElement) {
        return this._el.getTotalLength();
      } else {
        const dim = this.bounds;
        return 2 * dim.height + 2 * dim.width;
      }
    }
    /**
     * Gets the coordinates of the point at a distance `d` along the length of the
     * stroke of this `<path>` element.
     */
    getPointAtLength(d) {
      if (this._el instanceof SVGGeometryElement) {
        const point = this._el.getPointAtLength(d);
        return new Point(point.x, point.y);
      } else {
        return new Point(0, 0);
      }
    }
    /**
     * Gets the coordinates of the point at a position `p` along the length of the
     * stroke of this `<path>` element, where `0 â‰¤ p â‰¤ 1`.
     */
    getPointAt(p) {
      return this.getPointAtLength(p * this.strokeLength);
    }
    /** Returns a list of all points along an SVG `<path>` element. */
    get points() {
      return parsePath(this.attr("d"));
    }
    /** Sets the list of points for an SVG `<path>` element.c*/
    set points(p) {
      const d = p.length ? `M${p.map((x) => `${x.x},${x.y}`).join("L")}` : "";
      this.setAttr("d", d);
    }
    /** Appends a new point to an SVG `<path>` element. */
    addPoint(p) {
      const d = `${this.attr("d")} L ${p.x},${p.y}`;
      this.setAttr("d", d);
    }
    /** Finds the center of an SVG `<circle>` element. */
    get center() {
      const x = +this.attr(this.tagName === "TEXT" ? "x" : "cx") || 0;
      const y = +this.attr(this.tagName === "TEXT" ? "y" : "cy") || 0;
      return new Point(x, y);
    }
    /** Sets the center of an SVG `<circle>` or `<text>` element. */
    setCenter(c) {
      this.setAttr(this.tagName === "TEXT" ? "x" : "cx", c.x);
      this.setAttr(this.tagName === "TEXT" ? "y" : "cy", c.y);
    }
    /** Sets the end points of an SVG `<line>` element. */
    setLine(p, q) {
      this.setAttr("x1", p.x);
      this.setAttr("y1", p.y);
      this.setAttr("x2", q.x);
      this.setAttr("y2", q.y);
    }
    /** Sets the bounds of an SVG `<rectangle>` element. */
    setRect(rect) {
      this.setAttr("x", rect.p.x);
      this.setAttr("y", rect.p.y);
      this.setAttr("width", rect.w);
      this.setAttr("height", rect.h);
    }
    /** Draws a generic geometry object onto an SVG `<path>` element. */
    draw(obj, options = {}) {
      if (!obj) return this.setAttr("d", "");
      const attributes = {};
      for (const p of ["mark", "arrows", "round"]) {
        if (this.hasAttr(p)) attributes[p] = this.attr(p);
      }
      if (this.hasClass("fill")) attributes.fill = "fill";
      if (this.hasAttr("size")) attributes.size = +this.attr("size") || void 0;
      this.setAttr("d", drawSVG(obj, Object.assign(options, attributes)));
    }
  };
  var SVGParentView2 = class extends SVGBaseView {
    /** Returns the viewport coordinates of this `<svg>` element. */
    get viewBox() {
      return this._el.viewBox.baseVal || { width: 0, height: 0 };
    }
    get $ownerSVG() {
      return this;
    }
    get positionLeft() {
      return parseInt(this.css("margin-left")) + this.parent.positionLeft;
    }
    get positionTop() {
      return parseInt(this.css("margin-top")) + this.parent.positionTop;
    }
    /** Returns the intrinsic width of this `<svg>` element. */
    get svgWidth() {
      return this.viewBox.width || this.width;
    }
    /** Returns the intrinsic height of this `<svg>` element. */
    get svgHeight() {
      return this.viewBox.height || this.height;
    }
    /** Create a new `<path>` element child and draw a geometry object onto it. */
    drawPath(obj, attributes = {}, options = {}) {
      const $el = $N("path", attributes, this);
      $el.draw(obj, options);
      return $el;
    }
    /** Converts an SVG element into a PNG, JPG or SVG data URI. */
    image(type, width2, height, viewBox) {
      return __async2(this, null, function* () {
        const $copy = this.copy(true);
        copySVGStyles(this._el, $copy._el);
        if (type === "svg") cleanSVG($copy._el);
        if (!height) height = width2 || this.svgHeight;
        if (!width2) width2 = this.svgWidth;
        $copy.setAttr("width", width2);
        $copy.setAttr("height", height);
        $copy.setAttr("viewBox", viewBox || this.attr("viewBox") || `0 0 ${this.svgWidth} ${this.svgHeight}`);
        $copy.setAttr("xmlns", "http://www.w3.org/2000/svg");
        const $images = $copy.$$("image");
        if (type === "svg") {
          for (const $i of $images) $i.setAttr("href", new URL($i.attr("href"), location.href));
        } else {
          yield Promise.all($images.map(($i) => __async2(this, null, function* () {
            $i.setAttr("href", yield loadImageDataURI($i.attr("href")));
          })));
        }
        const serialised = new XMLSerializer().serializeToString($copy._el);
        const url = `data:image/svg+xml;utf8,${encodeURIComponent(serialised)}`;
        if (type === "svg") return url;
        const $canvas = $N("canvas", { width: width2, height });
        if (type === "jpg") {
          $canvas.ctx.fillStyle = "white";
          $canvas.ctx.fillRect(0, 0, width2, height);
        }
        const image = yield loadImage(url);
        $canvas.ctx.drawImage(image, 0, 0, width2, height);
        return $canvas.image(type);
      });
    }
    downloadImage(fileName, width2, height, viewBox) {
      const windowRef = Browser.isIOS ? window.open("", "_blank") : void 0;
      const isDarkTheme = Browser.theme.isDark;
      if (isDarkTheme) Browser.setTheme("light");
      const type = fileName.endsWith(".jpg") ? "jpg" : fileName.endsWith(".svg") ? "svg" : "png";
      const dataUri = this.image(type, width2, height, viewBox);
      if (isDarkTheme) Browser.setTheme("dark");
      dataUri.then((href) => {
        if (windowRef) return windowRef.location.href = href;
        const $a = $N("a", { download: fileName, href, target: "_blank" });
        $a._el.dispatchEvent(new MouseEvent(
          "click",
          { view: window, bubbles: false, cancelable: true }
        ));
      });
    }
  };
  var WindowView = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "window";
    }
    get width() {
      return window.innerWidth;
    }
    get height() {
      return window.innerHeight;
    }
    get innerWidth() {
      return window.innerWidth;
    }
    get innerHeight() {
      return window.innerHeight;
    }
    get outerWidth() {
      return window.outerWidth;
    }
    get outerHeight() {
      return window.outerHeight;
    }
    get scrollWidth() {
      return document.body.scrollWidth;
    }
    get scrollHeight() {
      return document.body.scrollHeight;
    }
    get scrollTop() {
      return window.pageYOffset;
    }
    set scrollTop(y) {
      document.body.scrollTop = document.documentElement.scrollTop = y;
      this.trigger("scroll", { top: y, left: this.scrollLeft });
    }
    get scrollLeft() {
      return window.pageXOffset;
    }
    set scrollLeft(x) {
      document.body.scrollLeft = document.documentElement.scrollLeft = x;
      this.trigger("scroll", { top: this.scrollTop, left: x });
    }
  };
  var FormView = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "form";
    }
    get action() {
      return this._el.action;
    }
    /** Summarises the data for an HTML <form> element in an JSON Object. */
    get formData() {
      const data = {};
      for (const el of Array.from(this._el.elements)) {
        const id = el.name || el.id;
        if (id) data[id] = el.value;
      }
      return data;
    }
    get isValid() {
      return this._el.checkValidity();
    }
  };
  var InputView2 = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "input";
    }
    get checked() {
      return this._el.checked || false;
    }
    set checked(value) {
      this._el.checked = value;
    }
    get value() {
      return this._el.value;
    }
    set value(v) {
      this._el.value = v;
    }
    bindVariable(model, name) {
      if (this._el.type === "checkbox") {
        const invert = name.startsWith("!");
        const inv = (t) => invert ? !t : t;
        if (invert) name = name.slice(1);
        if (model[name] !== void 0) {
          this.checked = inv(model[name]);
        } else if (this.hasAttr("checked")) {
          model[name] = inv(this.checked);
        }
        this.on("change", () => model[name] = inv(this.checked));
        model.watch(() => this.checked = inv(model[name]));
        return;
      }
      if (this._el.type === "number") {
        const min = this.hasAttr("min") ? +this.attr("min") : -Infinity;
        const max = this.hasAttr("max") ? +this.attr("max") : Infinity;
        this.change((v) => {
          if (v) model[name] = clamp(+v, min, max);
        });
      } else {
        this.change((v) => model[name] = v);
      }
      if (model[name] !== void 0) {
        this.value = model[name];
      } else if (this.value) {
        model[name] = this.value;
      }
      this.on("blur", () => this.value = model[name]);
      model.watch(() => {
        if (document.activeElement !== this._el) this.value = model[name];
      });
    }
    /** Polyfill for type and inputmode attributes. */
    setInputPattern(value) {
      if (isNaN(+value)) return;
      const digitsOnly = value.match(/^[0-9]+$/);
      this.setAttr("inputmode", digitsOnly ? "numeric" : "decimal");
      if (digitsOnly) this.setAttr("pattern", "[0-9]*");
    }
    /** Binds a change event listener. */
    change(callback) {
      let value = this.value || "";
      this.on("focus", () => value = this.value);
      this.on("change keyup input paste", () => {
        if (this.value === value) return;
        value = this.value;
        callback(value);
      });
    }
    validate(callback) {
      this.change((value) => this.setValidity(callback(value)));
    }
    setValidity(str) {
      this._el.setCustomValidity(str);
    }
    get isValid() {
      return this._el.checkValidity();
    }
  };
  var CanvasView2 = class extends HTMLBaseView {
    constructor() {
      super(...arguments);
      this.type = "canvas";
    }
    /** Returns the drawing context for a `<canvas>` element. */
    getContext(c = "2d", options = {}) {
      return this._el.getContext(c, options);
    }
    /** Converts a Canvas element into a PNG or JPEG data URI. */
    image(type = "png") {
      return this._el.toDataURL(type === "png" ? "image/png" : "image/jpeg");
    }
    /** Returns the intrinsic pixel width of this `<canvas>` element. */
    get canvasWidth() {
      return this._el.width;
    }
    /** Returns the intrinsic pixel height of this `<canvas>` element. */
    get canvasHeight() {
      return this._el.height;
    }
    /** Cached reference to the 2D context for this `<canvas>` element. */
    get ctx() {
      if (!this._ctx) this._ctx = this.getContext();
      return this._ctx;
    }
    /** Draws a generic geometry object ont a `<canvas>` element. */
    draw(obj, options = {}) {
      this.ctx.save();
      drawCanvas(this.ctx, obj, options);
      this.ctx.restore();
    }
    /** Clears this canvas. */
    clear() {
      this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    }
    /** Clears this canvas. */
    fill(color) {
      this.ctx.save();
      this.ctx.fillStyle = color;
      this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
      this.ctx.restore();
    }
    /** Erase a specific circle of the canvas. */
    clearCircle(center, radius) {
      this.ctx.save();
      this.ctx.globalCompositeOperation = "destination-out";
      this.ctx.beginPath();
      this.ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
      this.ctx.fill();
      this.ctx.restore();
    }
    downloadImage(fileName) {
      const href = this.image(fileName.endsWith(".jpg") ? "jpg" : "png");
      const $a = $N("a", { download: fileName, href, target: "_blank" });
      $a._el.dispatchEvent(new MouseEvent(
        "click",
        { view: window, bubbles: false, cancelable: true }
      ));
    }
  };
  var MediaView = class extends HTMLBaseView {
    /** Starts playback on a media element. */
    play() {
      return this._el.play() || Promise.resolve();
    }
    /** Pauses playback on a media element. */
    pause() {
      return this._el.pause();
    }
  };
  var SVG_TAGS = [
    "path",
    "rect",
    "circle",
    "ellipse",
    "polygon",
    "polyline",
    "g",
    "defs",
    "marker",
    "line",
    "text",
    "tspan",
    "pattern",
    "mask",
    "svg",
    "foreignObject",
    "image",
    "use",
    "clipPath",
    "linearGradient",
    "radialGradient"
  ];
  function $(query, context) {
    if (!query) return void 0;
    const c = context ? context._el : document.documentElement;
    const el = typeof query === "string" ? c.querySelector(query) : query;
    if (!el) return void 0;
    if (el._view) return el._view;
    const tagName = (el.tagName || "").toLowerCase();
    if (tagName === "svg") {
      return new SVGParentView2(el);
    } else if (tagName === "canvas") {
      return new CanvasView2(el);
    } else if (tagName === "form") {
      return new FormView(el);
    } else if (tagName === "input" || tagName === "select" || tagName === "textarea") {
      return new InputView2(el);
    } else if (tagName === "video" || tagName === "audio") {
      return new MediaView(el);
    } else if (SVG_TAGS.includes(tagName)) {
      return new SVGBaseView(el);
    } else {
      return new HTMLBaseView(el);
    }
  }
  function $$(selector, context) {
    const c = context ? context._el : document.documentElement;
    const els = selector ? c.querySelectorAll(selector) : [];
    return Array.from(els, (el) => $(el));
  }
  function $N(tag, attributes = {}, parent) {
    const el = !SVG_TAGS.includes(tag) ? document.createElement(tag) : document.createElementNS("http://www.w3.org/2000/svg", tag);
    for (const [key, value] of Object.entries(attributes)) {
      if (value === void 0) continue;
      if (key === "id") {
        el.id = value;
      } else if (key === "html") {
        el.innerHTML = value;
      } else if (key === "text") {
        el.textContent = value;
      } else if (key === "path") {
        el.setAttribute("d", drawSVG(value));
      } else {
        el.setAttribute(key, value);
      }
    }
    const $el = $(el);
    if (parent) parent.append($el);
    return $el;
  }
  var $body = new WindowView(document.body);
  var $html = new WindowView(document.documentElement);
  function toQueryString(data) {
    const pairs = [];
    for (let key of Object.keys(data)) {
      let value = data[key];
      key = encodeURIComponent(key);
      if (value == void 0) {
        pairs.push(key);
        continue;
      }
      value = Array.isArray(value) ? value.join(",") : `${value}`;
      value = value.replace(/(\r)?\n/g, "\r\n");
      value = encodeURIComponent(value);
      value = value.replace(/%20/g, "+");
      pairs.push(`${key}=${value}`);
    }
    return pairs.join("&");
  }
  function post(url, data) {
    return __async2(this, null, function* () {
      const isForm = data instanceof FormData;
      const options = {
        method: "POST",
        body: isForm ? data : data ? toQueryString(data) : void 0,
        headers: { "X-CSRF-Token": window.csrfToken || "" }
      };
      if (!isForm) options.headers["Content-Type"] = "application/x-www-form-urlencoded";
      const ext = url.includes("?") ? "&xhr=1" : "?xhr=1";
      const response = yield fetch(url + ext, options);
      if (!response.ok) throw new Error(`Fetch error ${response.status}: ${url}`);
      return response.text();
    });
  }
  function loadImage(url, credentials = false) {
    return new Promise((resolve) => {
      const img = new Image();
      if (!credentials) img.crossOrigin = "Anonymous";
      img.onload = () => resolve(img);
      img.src = url;
    });
  }
  var loadImageDataURI = cache((url) => __async2(void 0, null, function* () {
    const img = yield loadImage(url);
    const $canvas = $N("canvas", { width: img.width, height: img.height });
    $canvas.ctx.drawImage(img, 0, 0, img.width, img.height);
    return $canvas.image("png");
  }));
  var POST_DATA = /* @__PURE__ */ new Map();
  function savePostData(url, data) {
    if (POST_DATA.has(url)) {
      deepExtend(POST_DATA.get(url), data, (a2, b2) => unique(a2.concat(b2)));
    } else {
      POST_DATA.set(url, data);
    }
  }
  function sendPostData() {
    if (!window.navigator.onLine) return;
    for (const [url, data] of POST_DATA) {
      POST_DATA.delete(url);
      post(url, { data: JSON.stringify(data) }).catch((error) => {
        console.error("Failed to send POST request:", error);
        savePostData(url, data);
      });
    }
  }
  var doDeferredPost = throttle(sendPostData, 5e3);
  window.addEventListener("online", doDeferredPost);
  window.onbeforeunload = sendPostData;
  function deferredPost(url, data) {
    savePostData(url, data);
    doDeferredPost();
  }
  var colours = loop(["#cd0e66", "#0f82f2", "#22ab24", "#fd8c00"]);
  var Draggable = class extends EventTarget {
    constructor($el, options = {}) {
      super();
      this.$el = $el;
      this.startPos = new Point(0, 0);
      this.position = new Point(0, 0);
      this.disabled = false;
      this.options = Object.assign({ moveX: true, moveY: true, withinBounds: true }, options);
      Browser.onResize(() => this.updateBounds());
      slide($el, {
        start: () => {
          if (this.disabled) return;
          this.startPos = this.position;
          this.trigger("start");
          $html.addClass("grabbing");
        },
        move: (posn, start) => {
          if (this.disabled) return;
          this.setPosition(this.startPos.x + posn.x - start.x, this.startPos.y + posn.y - start.y);
          this.trigger("drag", { posn: this.position, pointerPosn: posn });
          this.checkTarget(posn);
        },
        end: (last2, start) => {
          if (this.disabled) return;
          this.trigger(last2.equals(start) ? "click" : "end", { $target: this.$over });
          if (this.options.$targets && !this.$over && this.options.resetOnMiss) this.resetPosition();
          this.$over = void 0;
          $html.removeClass("grabbing");
        },
        click: () => this.trigger("click"),
        accessible: true
      });
    }
    // ---------------------------------------------------------------------------
    // Target drag-n-drop
    addTarget($target) {
      var _a22;
      if (!this.options.$targets) this.options.$targets = [];
      (_a22 = this.options.$targets) == null ? void 0 : _a22.push($target);
    }
    removeTarget($target) {
      var _a22, _b;
      this.options.$targets = (_a22 = this.options.$targets) == null ? void 0 : _a22.filter(($el) => $el !== $target);
      if (!((_b = this.options.$targets) == null ? void 0 : _b.length)) this.options.$targets = void 0;
    }
    checkTarget(posn) {
      if (!this.options.$targets) return;
      const $target = this.options.$targets.find(($t) => $t.boundsRect.contains(posn));
      if ($target === this.$over) return;
      if (this.$over) this.trigger("exit-target", { $target: this.$over });
      if ($target) this.trigger("enter-target", { $target });
      this.$over = $target;
    }
    // ---------------------------------------------------------------------------
    // Resizing and positioning
    updateBounds() {
      if (!this.options.withinBounds) return this.bounds = void 0;
      if (this.options.bounds) return this.bounds = this.options.bounds;
      const oldBounds = this.bounds;
      const $parent = this.options.$parent || this.$el.parent;
      const width2 = $parent.type === "svg" ? $parent.svgWidth : $parent.width;
      const height = $parent.type === "svg" ? $parent.svgHeight : $parent.height;
      this.bounds = new Bounds(0, width2, 0, height);
      if (!width2 && !height) setTimeout(() => this.updateBounds());
      if (oldBounds) {
        this.setPosition(
          this.position.x * this.bounds.dx / oldBounds.dx || 0,
          this.position.y * this.bounds.dy / oldBounds.dy || 0
        );
      }
    }
    /** Sets the position of the element. */
    setPosition(x, y) {
      var _a22;
      let p = new Point(this.options.moveX ? x : 0, this.options.moveY ? y : 0);
      if (this.bounds) p = p.clamp(this.bounds, (_a22 = this.options.margin) != null ? _a22 : 0);
      p = p.round(this.options.snap || 1);
      if (this.options.round) p = this.options.round(p);
      if (p.equals(this.position)) return;
      this.position = p;
      if (this.options.useTransform) {
        this.$el.translate(p.x, p.y);
      } else {
        if (this.options.moveX) this.$el.css("left", `${p.x}px`);
        if (this.options.moveY) this.$el.css("top", `${p.y}px`);
      }
      this.trigger("move", { posn: p });
    }
    resetPosition(duration = 250) {
      return __async2(this, null, function* () {
        const initial = this.position;
        this.$el.css({ "pointer-events": "none" });
        yield animate((p) => {
          const currentPos = Point.interpolate(initial, this.startPos, p);
          this.setPosition(currentPos.x, currentPos.y);
        }, duration).promise;
        this.$el.css({ "pointer-events": "initial" });
      });
    }
  };
  var LOADING_STYLE = "position: fixed; top: 0; left: 0; width: 100%; height: 4px; background: #0f82f2; pointer-events: none; z-index: 9999; will-change: transform;";
  function getViewParams(url, view) {
    const match = view.regex.exec(url);
    if (match) {
      match.shift();
      const params = {};
      for (const [i, p] of view.params.entries()) params[p] = match[i];
      return params;
    } else {
      return void 0;
    }
  }
  function getTemplate(view, params, url) {
    return __async2(this, null, function* () {
      if (view.template) {
        if (typeof view.template === "string") return view.template;
        return view.template(params);
      }
      const str = yield fetch(url + (url.indexOf("?") >= 0 ? "&xhr=1" : "?xhr=1"));
      return str.text();
    });
  }
  var isReady2 = document.readyState === "complete";
  window.addEventListener("load", () => setTimeout(() => isReady2 = true));
  if ("scrollRestoration" in window.history) {
    window.history.scrollRestoration = "manual";
  }
  var Router = class extends EventTarget {
    constructor() {
      super(...arguments);
      this.$viewport = $body;
      this.views = [];
      this.active = { path: "", hash: "" };
      this.preloaded = false;
      this.transition = false;
      this.noLoad = false;
      this.initialise = () => void 0;
    }
    setup(options = {}) {
      if (options.$viewport) this.$viewport = options.$viewport;
      if (options.initialise) this.initialise = options.initialise;
      if (options.preloaded) this.preloaded = options.preloaded;
      if (options.transition) this.transition = options.transition;
      if (options.noLoad) this.noLoad = options.noLoad;
      if (options.click) {
        $body.on("click", (e) => this.onLinkClick(e));
      }
      if (options.history) {
        window.addEventListener("popstate", (e) => __async2(this, null, function* () {
          var _a22;
          if (!isReady2 || !((_a22 = e.state) == null ? void 0 : _a22.path)) return;
          const success = yield this.load(e.state.path, e.state.hash);
          if (!success) window.history.pushState(this.active, "", this.active.path + this.active.hash);
        }));
      }
    }
    view(url, { enter: enter2, exit: exit2, template: template2 } = {}) {
      const params = (url.match(/:\w+/g) || []).map((x) => x.substr(1));
      const regexStr = `${url.replace(/:\w+/g, "([\\w-]+)").replace("/", "\\/")}\\/?`;
      const searchStr = url.includes("?") ? "" : "(\\?.*)?";
      const regex = new RegExp(`^${regexStr}${searchStr}$`, "i");
      const thisView = { regex, params, enter: enter2, exit: exit2, template: template2 };
      this.views.push(thisView);
      const current = window.location.pathname + window.location.search;
      const viewParams = getViewParams(current, thisView);
      if (!viewParams) return;
      this.active = { path: current, hash: window.location.hash };
      window.history.replaceState(this.active, "", this.active.path + this.active.hash);
      Browser.ready(() => {
        setTimeout(() => {
          if (this.preloaded) {
            this.initialise(this.$viewport, viewParams);
            if (thisView.enter) thisView.enter(this.$viewport, viewParams);
          } else {
            this.loadView(thisView, viewParams);
          }
        });
      });
    }
    paths(...urls) {
      for (const url of urls) this.view(url);
    }
    getView(path) {
      for (const view of this.views) {
        const params = getViewParams(path, view);
        if (params) return { view, params };
      }
    }
    // ---------------------------------------------------------------------------
    // Loading and Rendering
    load(path, hash) {
      return __async2(this, null, function* () {
        if (path === this.active.path && hash !== this.active.hash) {
          this.trigger("hashChange", hash.slice(1));
          this.trigger("change", path + hash);
          this.active = { path, hash };
          return true;
        }
        const go = this.getView(path);
        if (!go) return false;
        if (this.beforeChange && !(yield this.beforeChange())) return false;
        this.active = { path, hash };
        this.trigger("change", path + hash);
        if (window.ga) window.ga("send", "pageview", path + hash);
        if (this.noLoad) {
          if (go.view.enter) go.view.enter(this.$viewport, go.params);
        } else {
          this.loadView(go.view, go.params);
        }
        return true;
      });
    }
    loadView(_0) {
      return __async2(this, arguments, function* (view, params = {}) {
        this.showLoadingBar();
        const path = this.active.path;
        const template2 = yield getTemplate(view, params, path);
        if (this.active.path !== path) return;
        yield this.$viewport.animate({ opacity: 0 }, 200).promise;
        this.$viewport.removeChildren();
        $body.scrollTop = 0;
        this.$viewport.html = template2;
        Browser.resize();
        replaceSvgImports();
        this.$viewport.animate({ "opacity": 1 }, 200);
        this.hideLoadingBar();
        const $title = this.$viewport.$("title");
        if ($title) document.title = $title.text;
        this.initialise(this.$viewport, params);
        if (view.enter) view.enter(this.$viewport, params);
        this.trigger("afterChange", { $viewport: this.$viewport });
      });
    }
    // ---------------------------------------------------------------------------
    // Navigation Functions
    onLinkClick(e) {
      if (e.metaKey || e.ctrlKey || e.shiftKey) return;
      if (e.defaultPrevented) return;
      let el = e.target;
      while (el && el.nodeName !== "A") el = el.parentNode;
      if (!el || el.nodeName !== "A") return;
      const anchor = el;
      if (anchor.target) return;
      if (anchor.origin !== window.location.origin) return;
      if (anchor.hasAttribute("download") || anchor.getAttribute("rel") === "external") return;
      const link = anchor.getAttribute("href");
      if (link && link.indexOf("mailto:") > -1) return;
      if (this.getView(anchor.pathname + anchor.search)) {
        e.preventDefault();
        this.goTo(anchor.pathname + anchor.search, anchor.hash);
      }
    }
    goTo(path, hash = "") {
      return __async2(this, null, function* () {
        const current = this.active.path + this.active.hash;
        const success = yield this.load(path, hash);
        if (success && current !== this.active.path + this.active.hash) {
          window.history.pushState(this.active, "", path + hash);
        }
      });
    }
    replace(path, hash = "") {
      this.active = { path, hash };
      window.history.replaceState(this.active, "", path + hash);
    }
    back() {
      window.history.back();
    }
    forward() {
      window.history.forward();
    }
    showLoadingBar() {
      if (!this.$loadingBar) this.$loadingBar = $N("div", { style: LOADING_STYLE }, $body);
      this.$loadingBar.css({ transform: "translateX(-100%)", opacity: 1 });
      this.$loadingBar.show();
      this.animation = animate((p) => {
        this.$loadingBar.css("transform", `translateX(-${10 + 90 * Math.exp(-4 * p)}%)`);
      }, 3e3);
    }
    hideLoadingBar() {
      return __async2(this, null, function* () {
        var _a22, _b, _c;
        (_a22 = this.animation) == null ? void 0 : _a22.cancel();
        yield (_b = this.$loadingBar) == null ? void 0 : _b.animate({ transform: "none", opacity: 0 }).promise;
        (_c = this.$loadingBar) == null ? void 0 : _c.hide();
      });
    }
  };
  var RouterInstance = new Router();
  function applyTemplate(el, template2) {
    const children = Array.from(el.childNodes);
    el.innerHTML = template2;
    const slots = {};
    for (const s of Array.from(el.querySelectorAll("slot"))) {
      slots[s.getAttribute("name") || ""] = s;
    }
    for (const child of children) {
      const name = child.getAttribute ? child.getAttribute("slot") || "" : "";
      const slot = slots[name] || slots[""];
      if (slot) slot.parentNode.insertBefore(child, slot);
    }
    for (const slot of Object.values(slots)) slot.parentNode.removeChild(slot);
  }
  function* customElementChildren(el) {
    for (const c of Array.from(el.children)) {
      if (c.tagName.includes("-")) {
        yield c;
      } else {
        yield* __yieldStar(__yieldStar2(customElementChildren(c)));
      }
    }
  }
  var customElementOptions = /* @__PURE__ */ new Map();
  var CustomHTMLElement = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.wasConnected = false;
      this.isReady = false;
    }
    connectedCallback() {
      return __async2(this, null, function* () {
        if (this.wasConnected) {
          this._view.trigger("connected");
          return;
        }
        this.wasConnected = true;
        this.isReady = false;
        this._view.created();
        const options = customElementOptions.get(this._view.tagName) || {};
        if (options.template) applyTemplate(this, options.template);
        const promises = [...customElementChildren(this)].filter((c) => !c.isReady).map((c) => new Promise((res) => c.addEventListener("ready", res)));
        setTimeout(() => {
          if (!this.isReady) console.error(`Children of custom element ${this.tagName} not ready after 1s.`);
        }, 1e3);
        yield Promise.all(promises);
        this._view.ready();
        this.dispatchEvent(new CustomEvent("ready"));
        this.isReady = true;
      });
    }
    disconnectedCallback() {
      this._view.trigger("disconnected");
    }
  };
  var CustomElementView = class extends HTMLBaseView {
    created() {
    }
    ready() {
    }
  };
  var CUSTOM_ELEMENTS = /* @__PURE__ */ new Map();
  function register(tagName, options = {}) {
    return function(ElementClass) {
      if (window.customElements.get(tagName)) {
        console.warn(`Trying to declare the custom element ${tagName} twice!`);
        return;
      }
      class Constructor extends CustomHTMLElement {
        constructor() {
          super();
          this._view = new ElementClass(this);
        }
      }
      CUSTOM_ELEMENTS.set(tagName, ElementClass);
      customElementOptions.set(tagName.toUpperCase(), options);
      window.customElements.define(tagName, Constructor);
    };
  }

  // node_modules/@mathigon/studio/frontend/components/step/narration.ts
  var AudioSegment = class {
    constructor(url) {
      this.clipEndTime = 0;
      this.player = new Audio(url);
      this.player.preload = "true";
      this.player.addEventListener("timeupdate", () => {
        if (this.player.currentTime >= this.clipEndTime) {
          this.triggerCallback(true);
        }
      });
      window.addEventListener("beforeunload", () => this.player.pause());
    }
    playClip(start, end, callback) {
      this.triggerCallback(false);
      this.player.currentTime = start;
      this.clipEndTime = end;
      this.clipCallback = callback;
      this.player.play();
    }
    triggerCallback(ended) {
      if (!this.clipCallback) return;
      const callback = this.clipCallback;
      this.clipCallback = void 0;
      this.player.pause();
      callback({ ended });
    }
    pause() {
      this.triggerCallback(false);
    }
    get isPlaying() {
      return !!this.clipCallback;
    }
  };
  var continuePlaying = false;
  var $waitingReveal = void 0;
  var Narration = class {
    constructor(audio, $step) {
      this.audio = audio;
      this.paragraphs = [];
      this.paragraphs = $step.$$(".voice").map(($p) => new Paragraph($p, audio));
      for (const [i, p] of this.paragraphs.entries()) {
        p.on("end", () => {
          var _a4;
          if (this.paragraphs[i + 1]) {
            this.paragraphs[i + 1].play();
          } else {
            const $next = $step.nextStep;
            if ($next && $next.isShown) (_a4 = $next.narration) == null ? void 0 : _a4.play();
          }
        });
      }
    }
    play() {
      var _a4;
      if (this.audio.isPlaying || !continuePlaying) return;
      (_a4 = this.paragraphs[0]) == null ? void 0 : _a4.play();
    }
  };
  var Paragraph = class extends EventTarget {
    constructor($p, audio) {
      super();
      this.$p = $p;
      this.audio = audio;
      this.playing = void 0;
      this.sentences = $p.$$(".sentence[data-timings]").map(($s) => new Sentence($s, audio));
      this.$button = $N("button", { class: "playback-btn", title: "Play Narration" });
      this.$button.on("click", () => {
        this.playing ? this.audio.pause() : this.play();
        continuePlaying = !continuePlaying;
        $waitingReveal = void 0;
      });
      $p.prepend(this.$button);
      $p.addClass("sentence-wrap");
      for (const [i, s] of this.sentences.entries()) {
        s.on("end", (playNext) => {
          this.playing = void 0;
          if (playNext && this.sentences[i + 1]) {
            setTimeout(() => this.play(this.sentences[i + 1]), 200);
          } else {
            this.$button.removeClass("active");
            if (playNext) setTimeout(() => this.trigger("end"), 400);
          }
        });
      }
    }
    play(s) {
      const sentence = s || this.sentences[0];
      const $reveal = sentence.$reveal;
      if ($reveal && $reveal.css("visibility") === "hidden") {
        this.$button.removeClass("active");
        $waitingReveal = $reveal;
        $reveal.one("reveal", () => {
          if ($waitingReveal === $reveal && !this.audio.isPlaying) {
            this.play(sentence);
          }
        });
        return;
      }
      this.playing = sentence;
      this.playing.play();
      this.$button.addClass("active");
      const $tab = this.$p.parents("x-tabbox .tab")[0];
      if ($tab) {
        const $tabBox = $tab.parents("x-tabbox")[0];
        $tabBox.makeActive($tab.index());
        const active2 = $tabBox.active;
        $tabBox.one("change", (i) => {
          if (this.playing && i !== active2) this.audio.pause();
        });
      }
      const bounds = this.$p.bounds;
      const dy = bounds.top + bounds.height - Browser.height + 20;
      if (dy > 0) $body.scrollBy(dy + 100);
      setTimeout(() => this.$button.focus(), 800);
    }
  };
  var Sentence = class extends EventTarget {
    constructor($el, audio) {
      super();
      this.$el = $el;
      this.audio = audio;
      const timings = $el.attr("data-timings").split("-");
      this.start = +timings[0] / 1e3;
      this.end = (+timings[1] - 200) / 1e3;
    }
    play() {
      this.$el.addClass("playing");
      this.audio.playClip(this.start, this.end, ({ ended }) => {
        this.$el.removeClass("playing");
        this.trigger("end", ended);
      });
    }
    get $reveal() {
      return this.$el.parents(".reveal")[0];
    }
  };

  // node_modules/@mathigon/boost/dist/components.js
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __decorateClass2 = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp3(target, key, result);
    return result;
  };
  var __async3 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var $openAlert;
  var $alertParent = $N("div", { class: "snackbar" }, $body);
  var Alert = class extends CustomElementView {
    ready() {
      var _a4;
      $alertParent.append(this);
      (_a4 = this.$("button")) == null ? void 0 : _a4.on("click", () => this.close());
    }
    open(duration = 2e3) {
      return __async3(this, null, function* () {
        if ($openAlert === this) return;
        if ($openAlert) yield $openAlert.close();
        $openAlert = this;
        yield this.enter("pop", 300).promise;
        this.setAttr("role", "alert");
        if (duration) setTimeout(() => this.close(), duration);
      });
    }
    close() {
      return __async3(this, null, function* () {
        if ($openAlert !== this) return;
        $openAlert = void 0;
        this.removeAttr("role");
        yield this.exit("pop", 300).promise;
      });
    }
  };
  Alert = __decorateClass2([
    register("x-alert")
  ], Alert);
  var IconView = class extends CustomElementView {
    ready() {
      if (this.children.length) return;
      const $svg = $N("svg", { viewBox: "0 0 24 24", alt: "", role: "presentation" }, this);
      const $use = $N("use", {}, $svg);
      const size = +this.attr("size") || 24;
      for (const $el of [this, $svg]) $el.css({ width: `${size}px`, height: `${size}px` });
      this.onAttr("name", (n) => $use.setAttr("href", `/icons.ec50cc2c.svg#${n}`));
    }
  };
  IconView = __decorateClass2([
    register("x-icon")
  ], IconView);
  var $modalBackground = $N("div", { class: "modal-background" }, $body);
  var backgroundAnimation;
  var $openModal = void 0;
  var lastFocusElement = void 0;
  var TITLE_ID = "boost-modal-title";
  function tryClose() {
    if ($openModal && $openModal.canClose) $openModal.close();
  }
  $modalBackground.on("click", tryClose);
  $body.onKey("Escape", (e) => {
    stopEvent(e);
    tryClose();
  });
  RouterInstance.on("change", tryClose);
  $modalBackground.on("scrollwheel touchmove", stopEvent);
  $body.onKey("Space ArrowUp ArrowDown PageDown PageUp", (e) => {
    if ($openModal) stopEvent(e);
  });
  var Modal = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.isOpen = false;
      this.canClose = true;
    }
    ready() {
      this.canClose = !this.hasAttr("no-close");
      this.$iframe = this.$("iframe[data-src]");
      this.$video = this.$("video");
      const $buttons = $$(`[data-modal=${this.id}]`);
      for (const $b of $buttons) $b.on("click", () => this.open());
      RouterInstance.on("afterChange", ({ $viewport }) => {
        const $buttons2 = $viewport.$$(`[data-modal=${this.id}]`);
        for (const $b of $buttons2) $b.on("click", () => this.open());
      });
      if ((this.hasClass("open") || Browser.getHash() === this.id) && !$openModal) this.open(true);
      if (this.$("input")) this.addClass("interactive");
      const $close = this.$(".close");
      if ($close) $close.on("click", () => this.close());
      for (const $btn of this.$$(".btn")) $btn.on("click", () => this.trigger("btn-click", $btn));
      this.setAttr("tabindex", -1);
      this.setAttr("role", "dialog");
      this.setAttr("aria-modal", "true");
      this.setAttr("aria-labelledby", TITLE_ID);
      this.onKey("Tab", (e) => {
        if (!this.isOpen) return;
        const $focus = this.$$("input:not([type=hidden]), a, button, textarea, [tabindex=0]");
        if (e.shiftKey && e.target === $focus[0]._el) {
          e.preventDefault();
          last($focus).focus();
        } else if (!e.shiftKey && e.target === last($focus)._el) {
          e.preventDefault();
          $focus[0].focus();
        }
      });
    }
    open(noAnimation = false) {
      var _a4, _b, _c;
      if (this.isOpen) return;
      $modalBackground.setClass("light", this.hasClass("light"));
      if ($openModal) {
        $openModal.close(true);
      } else if (noAnimation) {
        $modalBackground.show();
      } else if ($modalBackground.css("display") === "block") {
        backgroundAnimation == null ? void 0 : backgroundAnimation.cancel();
      } else {
        $modalBackground.enter("fade", 250);
      }
      this.isOpen = true;
      $openModal = this;
      if (this.$iframe) this.$iframe.setAttr("src", this.$iframe.data.src);
      if (this.$video) this.$video.play();
      if (noAnimation) {
        this.show();
      } else {
        this.enter("pop", 250).promise.then(() => this.css("transform", ""));
      }
      (_a4 = this.$("h2")) == null ? void 0 : _a4.setAttr("id", TITLE_ID);
      lastFocusElement = document.activeElement;
      (this.$("input:not([type=hidden]), textarea") || this).focus();
      this.trigger("open");
      (_b = window.ga) == null ? void 0 : _b.call(window, "send", "event", "Modal", this.id);
      (_c = window.gtag) == null ? void 0 : _c.call(window, "event", "modal", { action: this.id });
    }
    close(keepBg = false, noEvent = false) {
      var _a4;
      if (!this.isOpen) return;
      this.isOpen = false;
      $openModal = void 0;
      if (this.$iframe) this.$iframe.setAttr("src", "");
      if (this.$video) this.$video.pause();
      (_a4 = this.$(`#${TITLE_ID}`)) == null ? void 0 : _a4.removeAttr("id");
      if (!keepBg) backgroundAnimation = $modalBackground.exit("fade", 250);
      this.exit("pop", 250).promise.then(() => this.css("transform", ""));
      if (!noEvent) this.trigger("close");
      if (lastFocusElement) lastFocusElement.focus();
    }
    getOpenModal() {
      return $openModal;
    }
  };
  Modal = __decorateClass2([
    register("x-modal")
  ], Modal);
  var Popup = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.isOpen = false;
    }
    ready() {
      this.animation = this.attr("animation") || "pop";
      this.$bubble = this.$(".popup-body");
      this.$bubble.hide();
      const $target = this.$(".popup-target");
      $target.on("click", () => this.toggleOpen());
      this.on("clickOutside", () => this.close());
      for (const $a of this.$bubble.$$("a")) $a.on("click", () => this.close());
      $body.onKey("Escape", () => this.close());
    }
    toggleOpen() {
      if (this.isOpen) {
        this.close();
      } else {
        this.open();
      }
    }
    open() {
      if (this.isOpen) return;
      this.isOpen = true;
      this.addClass("active");
      this.$bubble.enter(this.animation, 150);
      this.$bubble.setAttr("role", "dialog");
      this.$bubble.focus();
      this.trigger("open");
    }
    close() {
      if (!this.isOpen) return;
      this.isOpen = false;
      this.removeClass("active");
      this.$bubble.exit(this.animation, 150);
      this.$bubble.removeAttr("role");
      this.trigger("close");
    }
  };
  Popup = __decorateClass2([
    register("x-popup")
  ], Popup);
  var Select = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.$options = {};
    }
    ready() {
      const $items = this.children;
      this.$active = this.$(".active") || $items[0];
      this.$active.addClass("active");
      for (const [i, $i] of $items.entries()) {
        if (!isOneOf($i.tagName, "A", "BUTTON") && !$i.hasAttr("tabindex")) $i.setAttr("tabindex", 0);
        $i.on("click", () => this.makeActive($i));
        this.$options[$i.attr("value") || i] = $i;
      }
      this.trigger("change", this.$active);
    }
    makeActive($el) {
      if ($el === this.$active) return;
      this.$active.removeClass("active");
      this.$active = $el;
      $el.addClass("active");
      this.trigger("change", $el);
    }
    bindVariable(model, name) {
      if (model[name] === void 0) model[name] = this.$active.attr("value");
      this.on("change", ($el) => model[name] = $el.attr("value"));
      model.watch(() => {
        const $el = this.$options[model[name]];
        if ($el) this.makeActive($el);
      });
    }
  };
  Select = __decorateClass2([
    register("x-select")
  ], Select);

  // node_modules/@mathigon/studio/frontend/components/progress/progress.ts
  var PADDING = 12;
  function getProgress(r) {
    return `M${r},${r / 2}a${r / 2},${r / 2},0,0,1,0,${r}A${r / 2},${r / 2},0,0,1,${r},${r / 2}`;
  }
  function getCheck(r) {
    return `M ${r},0 C ${r / 2},0,0,${r / 2},0,${r}  s ${r / 2},${r},${r},${r} s ${r}-${r / 2},${r}-${r}     S ${r * 1.5},0,${r},0 z M ${r * 44.6 / 50},${r * 76.1 / 50} L ${r * 19.2 / 50},${r * 48.8 / 50} l ${r * 4 / 50}-${r * 4.2 / 50}     l ${r * 19.8 / 50},${r * 11.9 / 50} l ${r * 34.2 / 50}-${r * 32.6 / 50} l ${r * 3.5 / 50},${r * 3.5 / 50} L ${r * 44.6 / 50},${r * 76.1 / 50} z`;
  }
  var Progress = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.completed = false;
    }
    ready() {
      this.r = +this.attr("r") || 10;
      this.r1 = this.r + PADDING;
      this.$svg = $N("svg", { width: 2 * this.r1, height: 2 * this.r1 }, this);
      this.$progress = $N("path", {
        class: "pie",
        d: getProgress(this.r),
        "stroke-width": this.r
      }, this.$svg);
      this.onAttr("p", (p) => this.setProgress(+p, false));
    }
    setProgress(p, animation = true) {
      if (p > 0.99) return this.complete(animation);
      const c = Math.PI * this.r;
      this.$progress.css("stroke", p ? "currentColor" : "none");
      this.$progress.css("stroke-dasharray", `${p * c} ${c}`);
    }
    complete(animation = true) {
      if (this.completed) return;
      this.completed = true;
      this.$progress.css("stroke", "none");
      this.$progress.css("fill", "currentColor");
      this.$progress.setAttr("d", getCheck(this.r));
      if (!animation) return;
      const transform2 = `translate(${this.r1} ${this.r1})`;
      const $g = $N("g", { transform: transform2 }, this.$svg);
      const $burst = tabulate(() => $N("line", {}, $g), 18);
      animate((p) => {
        const r1 = this.r + PADDING * ease("quint-out", p);
        const r2 = this.r + PADDING * p;
        for (let i = 0; i < 18; ++i) {
          const c = Math.cos(Math.PI * 2 * i / 18);
          const s = Math.sin(Math.PI * 2 * i / 18);
          $burst[i].setLine({ x: c * r1, y: s * r1 }, { x: c * r2, y: s * r2 });
        }
      }, 800).promise.then(() => $g.remove());
    }
  };
  Progress = __decorateClass([
    register("x-progress")
  ], Progress);

  // node_modules/autotrack/lib/constants.js
  var VERSION = "2.4.1";
  var DEV_ID = "i5iSjo";
  var VERSION_PARAM = "_av";
  var USAGE_PARAM = "_au";
  var NULL_DIMENSION = "(not set)";

  // node_modules/autotrack/lib/method-chain.js
  var instances = [];
  var MethodChain = class {
    /**
     * Adds the passed override method to the list of method chain overrides.
     * @param {!Object} context The object containing the method to chain.
     * @param {string} methodName The name of the method on the object.
     * @param {!Function} methodOverride The override method to add.
     */
    static add(context, methodName, methodOverride) {
      getOrCreateMethodChain(context, methodName).add(methodOverride);
    }
    /**
     * Removes a method chain added via `add()`. If the override is the
     * only override added, the original method is restored.
     * @param {!Object} context The object containing the method to unchain.
     * @param {string} methodName The name of the method on the object.
     * @param {!Function} methodOverride The override method to remove.
     */
    static remove(context, methodName, methodOverride) {
      getOrCreateMethodChain(context, methodName).remove(methodOverride);
    }
    /**
     * Wraps a foreign object method and overrides it. Also stores a reference
     * to the original method so it can be restored later.
     * @param {!Object} context The object containing the method.
     * @param {string} methodName The name of the method on the object.
     */
    constructor(context, methodName) {
      this.context = context;
      this.methodName = methodName;
      this.isTask = /Task$/.test(methodName);
      this.originalMethodReference = this.isTask ? context.get(methodName) : context[methodName];
      this.methodChain = [];
      this.boundMethodChain = [];
      this.wrappedMethod = (...args) => {
        const lastBoundMethod = this.boundMethodChain[this.boundMethodChain.length - 1];
        return lastBoundMethod(...args);
      };
      if (this.isTask) {
        context.set(methodName, this.wrappedMethod);
      } else {
        context[methodName] = this.wrappedMethod;
      }
    }
    /**
     * Adds a method to the method chain.
     * @param {!Function} overrideMethod The override method to add.
     */
    add(overrideMethod) {
      this.methodChain.push(overrideMethod);
      this.rebindMethodChain();
    }
    /**
     * Removes a method from the method chain and restores the prior order.
     * @param {!Function} overrideMethod The override method to remove.
     */
    remove(overrideMethod) {
      const index = this.methodChain.indexOf(overrideMethod);
      if (index > -1) {
        this.methodChain.splice(index, 1);
        if (this.methodChain.length > 0) {
          this.rebindMethodChain();
        } else {
          this.destroy();
        }
      }
    }
    /**
     * Loops through the method chain array and recreates the bound method
     * chain array. This is necessary any time a method is added or removed
     * to ensure proper original method context and order.
     */
    rebindMethodChain() {
      this.boundMethodChain = [];
      for (let method, i = 0; method = this.methodChain[i]; i++) {
        const previousMethod = this.boundMethodChain[i - 1] || this.originalMethodReference.bind(this.context);
        this.boundMethodChain.push(method(previousMethod));
      }
    }
    /**
     * Calls super and destroys the instance if no registered handlers remain.
     */
    destroy() {
      const index = instances.indexOf(this);
      if (index > -1) {
        instances.splice(index, 1);
        if (this.isTask) {
          this.context.set(this.methodName, this.originalMethodReference);
        } else {
          this.context[this.methodName] = this.originalMethodReference;
        }
      }
    }
  };
  function getOrCreateMethodChain(context, methodName) {
    let methodChain = instances.filter((h) => h.context == context && h.methodName == methodName)[0];
    if (!methodChain) {
      methodChain = new MethodChain(context, methodName);
      instances.push(methodChain);
    }
    return methodChain;
  }

  // node_modules/dom-utils/lib/matches.js
  var proto = window.Element.prototype;
  var nativeMatches = proto.matches || proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector;

  // node_modules/dom-utils/lib/parse-url.js
  var HTTP_PORT = "80";
  var HTTPS_PORT = "443";
  var DEFAULT_PORT = RegExp(":(" + HTTP_PORT + "|" + HTTPS_PORT + ")$");
  var a = document.createElement("a");

  // node_modules/autotrack/lib/utilities.js
  function createFieldsObj(defaultFields, userFields, tracker = void 0, hitFilter = void 0, target = void 0, event = void 0) {
    if (typeof hitFilter == "function") {
      const originalBuildHitTask = tracker.get("buildHitTask");
      return {
        buildHitTask: (model) => {
          model.set(defaultFields, null, true);
          model.set(userFields, null, true);
          hitFilter(model, target, event);
          originalBuildHitTask(model);
        }
      };
    } else {
      return assign({}, defaultFields, userFields);
    }
  }
  var queueMap = {};
  function deferUntilPluginsLoaded(tracker, fn) {
    const trackingId = tracker.get("trackingId");
    const ref = queueMap[trackingId] = queueMap[trackingId] || {};
    const processQueue = () => {
      clearTimeout(ref.timeout);
      if (ref.send) {
        MethodChain.remove(tracker, "send", ref.send);
      }
      delete queueMap[trackingId];
      ref.queue.forEach((fn2) => fn2());
    };
    clearTimeout(ref.timeout);
    ref.timeout = setTimeout(processQueue, 0);
    ref.queue = ref.queue || [];
    ref.queue.push(fn);
    if (!ref.send) {
      ref.send = (originalMethod) => {
        return (...args) => {
          processQueue();
          originalMethod(...args);
        };
      };
      MethodChain.add(tracker, "send", ref.send);
    }
  }
  var assign = Object.assign || function(target, ...sources) {
    for (let i = 0, len = sources.length; i < len; i++) {
      const source = Object(sources[i]);
      for (let key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function isObject(value) {
    return typeof value == "object" && value !== null;
  }
  function now() {
    return +/* @__PURE__ */ new Date();
  }
  var uuid = function b(a2) {
    return a2 ? (a2 ^ Math.random() * 16 >> a2 / 4).toString(16) : ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, b);
  };

  // node_modules/autotrack/lib/provide.js
  function provide(pluginName, pluginConstructor) {
    const gaAlias = window.GoogleAnalyticsObject || "ga";
    window[gaAlias] = window[gaAlias] || function(...args) {
      (window[gaAlias].q = window[gaAlias].q || []).push(args);
    };
    window.gaDevIds = window.gaDevIds || [];
    if (window.gaDevIds.indexOf(DEV_ID) < 0) {
      window.gaDevIds.push(DEV_ID);
    }
    window[gaAlias]("provide", pluginName, pluginConstructor);
    window.gaplugins = window.gaplugins || {};
    window.gaplugins[capitalize(pluginName)] = pluginConstructor;
  }

  // node_modules/autotrack/lib/event-emitter.js
  var EventEmitter = class {
    /**
     * Creates the event registry.
     */
    constructor() {
      this.registry_ = {};
    }
    /**
     * Adds a handler function to the registry for the passed event.
     * @param {string} event The event name.
     * @param {!Function} fn The handler to be invoked when the passed
     *     event is emitted.
     */
    on(event, fn) {
      this.getRegistry_(event).push(fn);
    }
    /**
     * Removes a handler function from the registry for the passed event.
     * @param {string=} event The event name.
     * @param {Function=} fn The handler to be removed.
     */
    off(event = void 0, fn = void 0) {
      if (event && fn) {
        const eventRegistry = this.getRegistry_(event);
        const handlerIndex = eventRegistry.indexOf(fn);
        if (handlerIndex > -1) {
          eventRegistry.splice(handlerIndex, 1);
        }
      } else {
        this.registry_ = {};
      }
    }
    /**
     * Runs all registered handlers for the passed event with the optional args.
     * @param {string} event The event name.
     * @param {...*} args The arguments to be passed to the handler.
     */
    emit(event, ...args) {
      this.getRegistry_(event).forEach((fn) => fn(...args));
    }
    /**
     * Returns the total number of event handlers currently registered.
     * @return {number}
     */
    getEventCount() {
      let eventCount = 0;
      Object.keys(this.registry_).forEach((event) => {
        eventCount += this.getRegistry_(event).length;
      });
      return eventCount;
    }
    /**
     * Returns an array of handlers associated with the passed event name.
     * If no handlers have been registered, an empty array is returned.
     * @private
     * @param {string} event The event name.
     * @return {!Array} An array of handler functions.
     */
    getRegistry_(event) {
      return this.registry_[event] = this.registry_[event] || [];
    }
  };

  // node_modules/autotrack/lib/store.js
  var AUTOTRACK_PREFIX = "autotrack";
  var instances2 = {};
  var isListening = false;
  var browserSupportsLocalStorage;
  var Store = class _Store extends EventEmitter {
    /**
     * Gets an existing instance for the passed arguements or creates a new
     * instance if one doesn't exist.
     * @param {string} trackingId The tracking ID for the GA property.
     * @param {string} namespace A namespace unique to this store.
     * @param {Object=} defaults An optional object of key/value defaults.
     * @return {Store} The Store instance.
     */
    static getOrCreate(trackingId, namespace, defaults) {
      const key = [AUTOTRACK_PREFIX, trackingId, namespace].join(":");
      if (!instances2[key]) {
        instances2[key] = new _Store(key, defaults);
        if (!isListening) initStorageListener();
      }
      return instances2[key];
    }
    /**
     * Returns true if the browser supports and can successfully write to
     * localStorage. The results is cached so this method can be invoked many
     * times with no extra performance cost.
     * @private
     * @return {boolean}
     */
    static isSupported_() {
      if (browserSupportsLocalStorage != null) {
        return browserSupportsLocalStorage;
      }
      try {
        window.localStorage.setItem(AUTOTRACK_PREFIX, AUTOTRACK_PREFIX);
        window.localStorage.removeItem(AUTOTRACK_PREFIX);
        browserSupportsLocalStorage = true;
      } catch (err) {
        browserSupportsLocalStorage = false;
      }
      return browserSupportsLocalStorage;
    }
    /**
     * Wraps the native localStorage method for each stubbing in tests.
     * @private
     * @param {string} key The store key.
     * @return {string|null} The stored value.
     */
    static get_(key) {
      return window.localStorage.getItem(key);
    }
    /**
     * Wraps the native localStorage method for each stubbing in tests.
     * @private
     * @param {string} key The store key.
     * @param {string} value The value to store.
     */
    static set_(key, value) {
      window.localStorage.setItem(key, value);
    }
    /**
     * Wraps the native localStorage method for each stubbing in tests.
     * @private
     * @param {string} key The store key.
     */
    static clear_(key) {
      window.localStorage.removeItem(key);
    }
    /**
     * @param {string} key A key unique to this store.
     * @param {Object=} defaults An optional object of key/value defaults.
     */
    constructor(key, defaults = {}) {
      super();
      this.key_ = key;
      this.defaults_ = defaults;
      this.cache_ = null;
    }
    /**
     * Gets the data stored in localStorage for this store. If the cache is
     * already populated, return it as is (since it's always kept up-to-date
     * and in sync with activity in other windows via the `storage` event).
     * TODO(philipwalton): Implement schema migrations if/when a new
     * schema version is introduced.
     * @return {!Object} The stored data merged with the defaults.
     */
    get() {
      if (this.cache_) {
        return this.cache_;
      } else {
        if (_Store.isSupported_()) {
          try {
            this.cache_ = parse(_Store.get_(this.key_));
          } catch (err) {
          }
        }
        return this.cache_ = assign({}, this.defaults_, this.cache_);
      }
    }
    /**
     * Saves the passed data object to localStorage,
     * merging it with the existing data.
     * @param {Object} newData The data to save.
     */
    set(newData) {
      this.cache_ = assign({}, this.defaults_, this.cache_, newData);
      if (_Store.isSupported_()) {
        try {
          _Store.set_(this.key_, JSON.stringify(this.cache_));
        } catch (err) {
        }
      }
    }
    /**
     * Clears the data in localStorage for the current store.
     */
    clear() {
      this.cache_ = {};
      if (_Store.isSupported_()) {
        try {
          _Store.clear_(this.key_);
        } catch (err) {
        }
      }
    }
    /**
     * Removes the store instance for the global instances map. If this is the
     * last store instance, the storage listener is also removed.
     * Note: this does not erase the stored data. Use `clear()` for that.
     */
    destroy() {
      delete instances2[this.key_];
      if (!Object.keys(instances2).length) {
        removeStorageListener();
      }
    }
  };
  function initStorageListener() {
    window.addEventListener("storage", storageListener);
    isListening = true;
  }
  function removeStorageListener() {
    window.removeEventListener("storage", storageListener);
    isListening = false;
  }
  function storageListener(event) {
    const store = instances2[event.key];
    if (store) {
      const oldData = assign({}, store.defaults_, parse(event.oldValue));
      const newData = assign({}, store.defaults_, parse(event.newValue));
      store.cache_ = newData;
      store.emit("externalSet", newData, oldData);
    }
  }
  function parse(source) {
    let data = {};
    if (source) {
      try {
        data = /** @type {!Object} */
        JSON.parse(source);
      } catch (err) {
      }
    }
    return data;
  }

  // node_modules/autotrack/lib/session.js
  var SECONDS = 1e3;
  var MINUTES = 60 * SECONDS;
  var instances3 = {};
  var Session = class _Session {
    /**
     * Gets an existing instance for the passed arguments or creates a new
     * instance if one doesn't exist.
     * @param {!Tracker} tracker An analytics.js tracker object.
     * @param {number} timeout The session timeout (in minutes). This value
     *     should match what's set in the "Session settings" section of the
     *     Google Analytics admin.
     * @param {string=} timeZone The optional IANA time zone of the view. This
     *     value should match what's set in the "View settings" section of the
     *     Google Analytics admin. (Note: this assumes all views for the property
     *     use the same time zone. If that's not true, it's better not to use
     *     this feature).
     * @return {Session} The Session instance.
     */
    static getOrCreate(tracker, timeout, timeZone) {
      const trackingId = tracker.get("trackingId");
      if (instances3[trackingId]) {
        return instances3[trackingId];
      } else {
        return instances3[trackingId] = new _Session(tracker, timeout, timeZone);
      }
    }
    /**
     * @param {!Tracker} tracker An analytics.js tracker object.
     * @param {number} timeout The session timeout (in minutes). This value
     *     should match what's set in the "Session settings" section of the
     *     Google Analytics admin.
     * @param {string=} timeZone The optional IANA time zone of the view. This
     *     value should match what's set in the "View settings" section of the
     *     Google Analytics admin. (Note: this assumes all views for the property
     *     use the same time zone. If that's not true, it's better not to use
     *     this feature).
     */
    constructor(tracker, timeout, timeZone) {
      this.tracker = tracker;
      this.timeout = timeout || _Session.DEFAULT_TIMEOUT;
      this.timeZone = timeZone;
      this.sendHitTaskOverride = this.sendHitTaskOverride.bind(this);
      MethodChain.add(tracker, "sendHitTask", this.sendHitTaskOverride);
      try {
        this.dateTimeFormatter = new Intl.DateTimeFormat("en-US", { timeZone: this.timeZone });
      } catch (err) {
      }
      const defaultProps = {
        hitTime: 0,
        isExpired: false
      };
      this.store = Store.getOrCreate(
        tracker.get("trackingId"),
        "session",
        defaultProps
      );
      if (!this.store.get().id) {
        this.store.set(
          /** @type {SessionStoreData} */
          { id: uuid() }
        );
      }
    }
    /**
     * Returns the ID of the current session.
     * @return {string}
     */
    getId() {
      return this.store.get().id;
    }
    /**
     * Accepts a session ID and returns true if the specified session has
     * evidentially expired. A session can expire for two reasons:
     *   - More than 30 minutes has elapsed since the previous hit
     *     was sent (The 30 minutes number is the Google Analytics default, but
     *     it can be modified in GA admin "Session settings").
     *   - A new day has started since the previous hit, in the
     *     specified time zone (should correspond to the time zone of the
     *     property's views).
     *
     * Note: since real session boundaries are determined at processing time,
     * this is just a best guess rather than a source of truth.
     *
     * @param {string} id The ID of a session to check for expiry.
     * @return {boolean} True if the session has not exp
     */
    isExpired(id = this.getId()) {
      if (id != this.getId()) return true;
      const sessionData = this.store.get();
      if (sessionData.isExpired) return true;
      const oldHitTime = sessionData.hitTime;
      if (oldHitTime) {
        const currentDate = /* @__PURE__ */ new Date();
        const oldHitDate = new Date(oldHitTime);
        if (currentDate - oldHitDate > this.timeout * MINUTES || this.datesAreDifferentInTimezone(currentDate, oldHitDate)) {
          return true;
        }
      }
      return false;
    }
    /**
     * Returns true if (and only if) the timezone date formatting is supported
     * in the current browser and if the two dates are definitively not the
     * same date in the session timezone. Anything short of this returns false.
     * @param {!Date} d1
     * @param {!Date} d2
     * @return {boolean}
     */
    datesAreDifferentInTimezone(d1, d2) {
      if (!this.dateTimeFormatter) {
        return false;
      } else {
        return this.dateTimeFormatter.format(d1) != this.dateTimeFormatter.format(d2);
      }
    }
    /**
     * Keeps track of when the previous hit was sent to determine if a session
     * has expired. Also inspects the `sessionControl` field to handles
     * expiration accordingly.
     * @param {function(!Model)} originalMethod A reference to the overridden
     *     method.
     * @return {function(!Model)}
     */
    sendHitTaskOverride(originalMethod) {
      return (model) => {
        originalMethod(model);
        const sessionControl = model.get("sessionControl");
        const sessionWillStart = sessionControl == "start" || this.isExpired();
        const sessionWillEnd = sessionControl == "end";
        const sessionData = this.store.get();
        sessionData.hitTime = now();
        if (sessionWillStart) {
          sessionData.isExpired = false;
          sessionData.id = uuid();
        }
        if (sessionWillEnd) {
          sessionData.isExpired = true;
        }
        this.store.set(sessionData);
      };
    }
    /**
     * Restores the tracker's original `sendHitTask` to the state before
     * session control was initialized and removes this instance from the global
     * store.
     */
    destroy() {
      MethodChain.remove(this.tracker, "sendHitTask", this.sendHitTaskOverride);
      this.store.destroy();
      delete instances3[this.tracker.get("trackingId")];
    }
  };
  Session.DEFAULT_TIMEOUT = 30;

  // node_modules/autotrack/lib/usage.js
  var plugins = {
    CLEAN_URL_TRACKER: 1,
    EVENT_TRACKER: 2,
    IMPRESSION_TRACKER: 3,
    MEDIA_QUERY_TRACKER: 4,
    OUTBOUND_FORM_TRACKER: 5,
    OUTBOUND_LINK_TRACKER: 6,
    PAGE_VISIBILITY_TRACKER: 7,
    SOCIAL_WIDGET_TRACKER: 8,
    URL_CHANGE_TRACKER: 9,
    MAX_SCROLL_TRACKER: 10
  };
  var PLUGIN_COUNT = Object.keys(plugins).length;
  function trackUsage(tracker, plugin) {
    trackVersion(tracker);
    trackPlugin(tracker, plugin);
  }
  function convertHexToBin(hex) {
    return parseInt(hex || "0", 16).toString(2);
  }
  function convertBinToHex(bin) {
    return parseInt(bin || "0", 2).toString(16);
  }
  function padZeros(str, len) {
    if (str.length < len) {
      let toAdd = len - str.length;
      while (toAdd) {
        str = "0" + str;
        toAdd--;
      }
    }
    return str;
  }
  function flipBitOn(str, index) {
    return str.substr(0, index) + 1 + str.substr(index + 1);
  }
  function trackPlugin(tracker, pluginIndex) {
    const usageHex = tracker.get("&" + USAGE_PARAM);
    let usageBin = padZeros(convertHexToBin(usageHex), PLUGIN_COUNT);
    usageBin = flipBitOn(usageBin, PLUGIN_COUNT - pluginIndex);
    tracker.set("&" + USAGE_PARAM, convertBinToHex(usageBin));
  }
  function trackVersion(tracker) {
    tracker.set("&" + VERSION_PARAM, VERSION);
  }

  // node_modules/autotrack/lib/plugins/page-visibility-tracker.js
  var HIDDEN = "hidden";
  var VISIBLE = "visible";
  var PAGE_ID = uuid();
  var SECONDS2 = 1e3;
  var PageVisibilityTracker = class {
    /**
     * Registers outbound link tracking on tracker object.
     * @param {!Tracker} tracker Passed internally by analytics.js
     * @param {?Object} opts Passed by the require command.
     */
    constructor(tracker, opts) {
      trackUsage(tracker, plugins.PAGE_VISIBILITY_TRACKER);
      if (!document.visibilityState) return;
      const defaultOpts = {
        sessionTimeout: Session.DEFAULT_TIMEOUT,
        visibleThreshold: 5 * SECONDS2,
        // timeZone: undefined,
        sendInitialPageview: false,
        // pageLoadsMetricIndex: undefined,
        // visibleMetricIndex: undefined,
        fieldsObj: {}
        // hitFilter: undefined
      };
      this.opts = /** @type {PageVisibilityTrackerOpts} */
      assign(defaultOpts, opts);
      this.tracker = tracker;
      this.lastPageState = document.visibilityState;
      this.visibleThresholdTimeout_ = null;
      this.isInitialPageviewSent_ = false;
      this.trackerSetOverride = this.trackerSetOverride.bind(this);
      this.handleChange = this.handleChange.bind(this);
      this.handleWindowUnload = this.handleWindowUnload.bind(this);
      this.handleExternalStoreSet = this.handleExternalStoreSet.bind(this);
      this.store = Store.getOrCreate(
        tracker.get("trackingId"),
        "plugins/page-visibility-tracker"
      );
      this.store.on("externalSet", this.handleExternalStoreSet);
      this.session = Session.getOrCreate(
        tracker,
        this.opts.sessionTimeout,
        this.opts.timeZone
      );
      MethodChain.add(tracker, "set", this.trackerSetOverride);
      window.addEventListener("unload", this.handleWindowUnload);
      document.addEventListener("visibilitychange", this.handleChange);
      deferUntilPluginsLoaded(this.tracker, () => {
        if (document.visibilityState == VISIBLE) {
          if (this.opts.sendInitialPageview) {
            this.sendPageview({ isPageLoad: true });
            this.isInitialPageviewSent_ = true;
          }
          this.store.set(
            /** @type {PageVisibilityStoreData} */
            {
              time: now(),
              state: VISIBLE,
              pageId: PAGE_ID,
              sessionId: this.session.getId()
            }
          );
        } else {
          if (this.opts.sendInitialPageview && this.opts.pageLoadsMetricIndex) {
            this.sendPageLoad();
          }
        }
      });
    }
    /**
     * Inspects the last visibility state change data and determines if a
     * visibility event needs to be tracked based on the current visibility
     * state and whether or not the session has expired. If the session has
     * expired, a change to `visible` will trigger an additional pageview.
     * This method also sends as the event value (and optionally a custom metric)
     * the elapsed time between this event and the previously reported change
     * in the same session, allowing you to more accurately determine when users
     * were actually looking at your page versus when it was in the background.
     */
    handleChange() {
      if (!(document.visibilityState == VISIBLE || document.visibilityState == HIDDEN)) {
        return;
      }
      const lastStoredChange = this.getAndValidateChangeData();
      const change = {
        time: now(),
        state: document.visibilityState,
        pageId: PAGE_ID,
        sessionId: this.session.getId()
      };
      if (document.visibilityState == VISIBLE && this.opts.sendInitialPageview && !this.isInitialPageviewSent_) {
        this.sendPageview();
        this.isInitialPageviewSent_ = true;
      }
      if (document.visibilityState == HIDDEN && this.visibleThresholdTimeout_) {
        clearTimeout(this.visibleThresholdTimeout_);
      }
      if (this.session.isExpired(lastStoredChange.sessionId)) {
        this.store.clear();
        if (this.lastPageState == HIDDEN && document.visibilityState == VISIBLE) {
          clearTimeout(this.visibleThresholdTimeout_);
          this.visibleThresholdTimeout_ = setTimeout(() => {
            this.store.set(change);
            this.sendPageview({ hitTime: change.time });
          }, this.opts.visibleThreshold);
        }
      } else {
        if (lastStoredChange.pageId == PAGE_ID && lastStoredChange.state == VISIBLE) {
          this.sendPageVisibilityEvent(lastStoredChange);
        }
        this.store.set(change);
      }
      this.lastPageState = document.visibilityState;
    }
    /**
     * Retroactively updates the stored change data in cases where it's known to
     * be out of sync.
     * This plugin keeps track of each visiblity change and stores the last one
     * in localStorage. LocalStorage is used to handle situations where the user
     * has multiple page open at the same time and we don't want to
     * double-report page visibility in those cases.
     * However, a problem can occur if a user closes a page when one or more
     * visible pages are still open. In such cases it's impossible to know
     * which of the remaining pages the user will interact with next.
     * To solve this problem we wait for the next change on any page and then
     * retroactively update the stored data to reflect the current page as being
     * the page on which the last change event occured and measure visibility
     * from that point.
     * @return {!PageVisibilityStoreData}
     */
    getAndValidateChangeData() {
      const lastStoredChange = (
        /** @type {PageVisibilityStoreData} */
        this.store.get()
      );
      if (this.lastPageState == VISIBLE && lastStoredChange.state == HIDDEN && lastStoredChange.pageId != PAGE_ID) {
        lastStoredChange.state = VISIBLE;
        lastStoredChange.pageId = PAGE_ID;
        this.store.set(lastStoredChange);
      }
      return lastStoredChange;
    }
    /**
     * Sends a Page Visibility event to track the time this page was in the
     * visible state (assuming it was in that state long enough to meet the
     * threshold).
     * @param {!PageVisibilityStoreData} lastStoredChange
     * @param {{hitTime: (number|undefined)}=} param1
     *     - hitTime: A hit timestap used to help ensure original order in cases
     *                where the send is delayed.
     */
    sendPageVisibilityEvent(lastStoredChange, { hitTime } = {}) {
      const delta = this.getTimeSinceLastStoredChange(
        lastStoredChange,
        { hitTime }
      );
      if (delta && delta >= this.opts.visibleThreshold) {
        const deltaInSeconds = Math.round(delta / SECONDS2);
        const defaultFields = {
          transport: "beacon",
          nonInteraction: true,
          eventCategory: "Page Visibility",
          eventAction: "track",
          eventValue: deltaInSeconds,
          eventLabel: NULL_DIMENSION
        };
        if (hitTime) {
          defaultFields.queueTime = now() - hitTime;
        }
        if (this.opts.visibleMetricIndex) {
          defaultFields["metric" + this.opts.visibleMetricIndex] = deltaInSeconds;
        }
        this.tracker.send(
          "event",
          createFieldsObj(
            defaultFields,
            this.opts.fieldsObj,
            this.tracker,
            this.opts.hitFilter
          )
        );
      }
    }
    /**
     * Sends a page load event.
     */
    sendPageLoad() {
      const defaultFields = {
        transport: "beacon",
        eventCategory: "Page Visibility",
        eventAction: "page load",
        eventLabel: NULL_DIMENSION,
        ["metric" + this.opts.pageLoadsMetricIndex]: 1,
        nonInteraction: true
      };
      this.tracker.send(
        "event",
        createFieldsObj(
          defaultFields,
          this.opts.fieldsObj,
          this.tracker,
          this.opts.hitFilter
        )
      );
    }
    /**
     * Sends a pageview, optionally calculating an offset if hitTime is passed.
     * @param {{
     *   hitTime: (number|undefined),
     *   isPageLoad: (boolean|undefined)
     * }=} param1
     *     hitTime: The timestamp of the current hit.
     *     isPageLoad: True if this pageview was also a page load.
     */
    sendPageview({ hitTime, isPageLoad } = {}) {
      const defaultFields = { transport: "beacon" };
      if (hitTime) {
        defaultFields.queueTime = now() - hitTime;
      }
      if (isPageLoad && this.opts.pageLoadsMetricIndex) {
        defaultFields["metric" + this.opts.pageLoadsMetricIndex] = 1;
      }
      this.tracker.send(
        "pageview",
        createFieldsObj(
          defaultFields,
          this.opts.fieldsObj,
          this.tracker,
          this.opts.hitFilter
        )
      );
    }
    /**
     * Detects changes to the tracker object and triggers an update if the page
     * field has changed.
     * @param {function((Object|string), (string|undefined))} originalMethod
     *     A reference to the overridden method.
     * @return {function((Object|string), (string|undefined))}
     */
    trackerSetOverride(originalMethod) {
      return (field, value) => {
        const fields = isObject(field) ? field : { [field]: value };
        if (fields.page && fields.page !== this.tracker.get("page")) {
          if (this.lastPageState == VISIBLE) {
            this.handleChange();
          }
        }
        originalMethod(field, value);
      };
    }
    /**
     * Calculates the time since the last visibility change event in the current
     * session. If the session has expired the reported time is zero.
     * @param {PageVisibilityStoreData} lastStoredChange
     * @param {{hitTime: (number|undefined)}=} param1
     *     hitTime: The time of the current hit (defaults to now).
     * @return {number} The time (in ms) since the last change.
     */
    getTimeSinceLastStoredChange(lastStoredChange, { hitTime } = {}) {
      return lastStoredChange.time ? (hitTime || now()) - lastStoredChange.time : 0;
    }
    /**
     * Handles responding to the `storage` event.
     * The code on this page needs to be informed when other tabs or windows are
     * updating the stored page visibility state data. This method checks to see
     * if a hidden state is stored when there are still visible tabs open, which
     * can happen if multiple windows are open at the same time.
     * @param {PageVisibilityStoreData} newData
     * @param {PageVisibilityStoreData} oldData
     */
    handleExternalStoreSet(newData, oldData) {
      if (newData.time == oldData.time) return;
      if (oldData.pageId == PAGE_ID && oldData.state == VISIBLE && !this.session.isExpired(oldData.sessionId)) {
        this.sendPageVisibilityEvent(oldData, { hitTime: newData.time });
      }
    }
    /**
     * Handles responding to the `unload` event.
     * Since some browsers don't emit a `visibilitychange` event in all cases
     * where a page might be unloaded, it's necessary to hook into the `unload`
     * event to ensure the correct state is always stored.
     */
    handleWindowUnload() {
      if (this.lastPageState != HIDDEN) {
        this.handleChange();
      }
    }
    /**
     * Removes all event listeners and restores overridden methods.
     */
    remove() {
      this.store.destroy();
      this.session.destroy();
      MethodChain.remove(this.tracker, "set", this.trackerSetOverride);
      window.removeEventListener("unload", this.handleWindowUnload);
      document.removeEventListener("visibilitychange", this.handleChange);
    }
  };
  provide("pageVisibilityTracker", PageVisibilityTracker);

  // node_modules/@mathigon/studio/frontend/main.ts
  bindAccessibilityEvents();
  $html.addClass((Browser.isMobile ? "is" : "not") + "-mobile");
  if (Browser.isSafari) $html.addClass("is-safari");
  setTimeout(() => $html.addClass("ready"));
  window.addEventListener("keydown", (e) => {
    if (e.keyCode === 9) $html.addClass("is-tabbing");
  });
  window.addEventListener("mousedown", () => {
    $html.removeClass("is-tabbing");
  });
  var $cookies = $(".cookie-warning");
  if ($cookies) {
    $("#yes-to-cookies").on("click", function() {
      $cookies.exit("pop", 300);
      Browser.setCookie("cookie_consent", 1);
    });
  }
  var $privacyModal = $("x-modal#privacy");
  if ($privacyModal) {
    $privacyModal.$("form").on("submit", (e) => {
      e.preventDefault();
      fetch("/profile/accept-policies", { method: "POST" });
      $privacyModal.close();
    });
  }
  var _a2;
  (_a2 = navigator.serviceWorker) == null ? void 0 : _a2.register("/service_worker.js", { scope: "/" }).catch(() => console.warn("Unable to register Service Worker."));
  var _a3;
  (_a3 = $("#skip-nav")) == null ? void 0 : _a3.on("click", () => {
    var _a4;
    const $main = $("article") || $(".panel.active") || $(".body") || $body;
    (_a4 = $main.$("input, button, a, textarea, [contenteditable], [tabindex]")) == null ? void 0 : _a4.focus();
  });
  var $popup = $("nav x-popup");
  if ($popup) {
    const $buttons = $popup.$$(".popup-body a, .popup-body button");
    for (const $b of $buttons) $b.on("click", () => $popup.close());
  }
  var $languageLinks = $$("#language .locale-link");
  RouterInstance.on("change", (path) => {
    for (const $l of $languageLinks) $l.setAttr("href", $l.data.host + path);
  });
  var $darkMode = $("#dark-mode");
  if ($darkMode) {
    $darkMode.checked = Browser.theme.isDark;
    $darkMode.on("change", () => Browser.setTheme($darkMode.checked ? "dark" : "light"));
  }
  var SEARCH_CACHE = {};
  var $search = $("#search");
  var $input = $search == null ? void 0 : $search.$(".form-field input");
  var $results = $search == null ? void 0 : $search.$(".search-body");
  SEARCH_CACHE[""] = ($results == null ? void 0 : $results.html) || "";
  function cleanSearchInput(str) {
    str = str.trim().replace(/\s+/, " ").toLowerCase().slice(0, 50);
    return str === "pi" || str.length >= 3 ? str : "";
  }
  function loadSearchResults(str) {
    return __async(this, null, function* () {
      str = encodeURIComponent(cleanSearchInput(str));
      if (str in SEARCH_CACHE) return SEARCH_CACHE[str];
      const response = yield fetch(`/api/search?q=${str}`);
      if (!response.ok) return SEARCH_CACHE[str] = "";
      return SEARCH_CACHE[str] = yield response.text();
    });
  }
  var lastCount = 0;
  var visibleCount = 0;
  function triggerSearch(str) {
    return __async(this, null, function* () {
      const i = lastCount += 1;
      const results = yield loadSearchResults(str);
      if (i <= visibleCount) return;
      visibleCount = i;
      $results.html = results;
    });
  }
  $input == null ? void 0 : $input.change((str) => {
    Browser.setCookie("search", str, 60 * 60 * 24);
    setTimeout(() => {
      if ($input.value === str) triggerSearch(str);
    }, 300);
  });
  if ($input == null ? void 0 : $input.value) {
    $search.one("open", () => triggerSearch($input.value));
  }

  // node_modules/@mathigon/studio/frontend/components/blank/blank.pug
  var blank_default = '<label class="target"><input maxlength="15" autocomplete="off" aria-label="Fill in this blank"></label>';

  // node_modules/@mathigon/studio/frontend/components/blank/blank.ts
  function parseInput(str) {
    if (str.match("^[0-9]+/[0-9]+$")) {
      const frac = str.split("/");
      return +frac[0] / +frac[1];
    } else {
      return parseNumber(str);
    }
  }
  var Blank = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.solution = "";
      // Orignal version of the solution
      this.solutionNum = NaN;
      // Numeric version of the solution
      this.solutionDisplay = "";
      // Override the final text in the answer
      this.range = 0;
      this.input = "";
      this.hint = "";
      this.attempts = 0;
      this.placeholder = "???";
      this.done = false;
    }
    ready() {
      this.$input = this.$("input");
      this.$target = this.$(".target");
      this.solution = this.attr("solution");
      if (this.solution.indexOf("\xB1") >= 0) {
        const split = this.solution.split("\xB1");
        this.solution = split[0].trim();
        this.range = +split[1];
      }
      this.solutionNum = parseInput(this.solution);
      this.solutionDisplay = this.solution;
      this.hint = this.attr("hint");
      this.removeAttr("solution");
      this.removeAttr("hint");
      this.$input.setInputPattern(this.solution);
      if (this.hasAttr("placeholder")) this.placeholder = this.attr("placeholder");
      this.$input.setAttr("placeholder", this.placeholder);
      this.removeAttr("placeholder");
      this.$input.change((value) => {
        this.input = value;
        if (this.isCorrect) {
          this.solve();
          this.trigger("valid", value);
          this.moveCursor();
        }
      });
      this.$input.onKey("Enter", () => this.$input.blur());
      this.$input.on("focus", () => {
        this.addClass("on");
        this.removeClass("invalid");
        this.$input.setAttr("placeholder", " ");
      });
      this.$input.on("blur", () => {
        this.removeClass("on");
        this.setClass("invalid", !!this.input && !this.done);
        this.$input.setAttr("placeholder", this.placeholder);
        if (this.input && !this.done) {
          this.attempts += 1;
          const hint = this.attempts >= (this.hint ? 4 : 3) ? `Hmmm\u2026 maybe try ${this.solution}?` : this.attempts >= 2 ? this.hint : void 0;
          this.trigger("invalid", { hint });
        }
      });
    }
    setup($step, goal, userData) {
      var _a4;
      this.goal = goal;
      this.$step = $step;
      if ((_a4 = userData == null ? void 0 : userData.scores) == null ? void 0 : _a4.includes(goal)) this.solve(true);
      this.one("valid", () => {
        $step.addHint("correct");
        $step.score(this.solvedBlank ? this.solvedBlank.goal : goal);
      });
      this.on("invalid", (e) => $step.addHint(e.hint || "incorrect", { class: "incorrect" }));
    }
    get isCorrect() {
      if (this.done) return true;
      if (this.linkedBlanks) {
        const solved = this.linkedBlanks.map((b2) => b2.solvedBlank);
        this.solvedBlank = this.linkedBlanks.find((b2) => {
          if (b2.done && !b2.solvedBlank) return false;
          if (solved.includes(b2)) return false;
          if (b2.checkAnswer(this.input)) return true;
        });
        if (this.solvedBlank) this.solutionDisplay = this.solvedBlank.solution;
        return !!this.solvedBlank;
      }
      return this.checkAnswer(this.input);
    }
    checkAnswer(input) {
      const inputNum = parseInput(input);
      if (input.toLowerCase() === this.solution.toLowerCase()) return true;
      if (this.range && Math.abs(inputNum - this.solutionNum) <= this.range) {
        this.solutionDisplay = input;
        return true;
      }
      return nearlyEquals(inputNum, this.solutionNum) || toWord(inputNum) === this.solution || input === toWord(this.solutionNum);
    }
    moveCursor() {
      if (!this.$step) return;
      const $next = this.$step.$blanks[this.$step.$blanks.indexOf(this) + 1];
      if (!$next || $next.done || $next.tagName === "X-BLANK-MC") return;
      if ($next.css("visibility") === "hidden" || !$next.bounds.width) return;
      $next.focus();
    }
    solve(restore = false) {
      this.done = true;
      this.$input.remove();
      this.$target.html = this.solutionDisplay;
      this.addClass("done");
      this.trigger("solve", { solution: this.solutionDisplay, restore });
    }
    focus() {
      this.$input.focus();
    }
    blur() {
      this.$input.blur();
    }
  };
  Blank = __decorateClass([
    register("x-blank", { template: blank_default })
  ], Blank);

  // node_modules/@mathigon/studio/frontend/components/blank/blank-mc.pug
  var blank_mc_default = '<span class="target" slot="target" tabindex="0" aria-label="Fill in this blank">???</span><div class="popup"><slot></slot></div>';

  // node_modules/@mathigon/studio/frontend/components/blank/blank-mc.ts
  var BlankMC = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.done = false;
    }
    ready() {
      this.$target = this.$(".target");
      this.$popup = this.$(".popup");
      const $choices = this.$popup.$$(".choice");
      this.solution = $choices[0].html;
      const order = random_exports.shuffle(list($choices.length));
      order.forEach((i) => {
        this.$popup.append($choices[i]);
        $choices[i].on("click", () => {
          this.removeClass("on");
          $choices[i].blur();
          if (i) {
            this.$target.html = $choices[i].html;
            this.addClass("invalid");
            this.trigger("invalid");
          } else {
            this.solve();
            this.trigger("valid", this.solution);
          }
        });
      });
      const goLeft = this.$target.bounds.left + this.$popup.width > Browser.width - 15;
      this.setClass("left", goLeft);
      hover(this, {
        enter: () => {
          if (this.done) return;
          this.addClass("on");
          const targetBounds = this.$target.bounds;
          const popupWidth = this.$popup.width;
          const popupHeight = this.$popup.height;
          const maxWidth = Browser.width - 10 - targetBounds.left;
          const spaceOnRight = popupWidth < maxWidth;
          const spaceOnLeft = targetBounds.right - popupWidth > 10;
          const spaceBelow = targetBounds.top + targetBounds.height + popupHeight > Browser.height - 10;
          this.setClass("left", spaceOnLeft && !spaceOnRight);
          this.setClass("top", spaceBelow);
          this.$popup.css(
            "max-width",
            !spaceOnLeft && !spaceOnRight ? `${maxWidth}px` : "none"
          );
        },
        exit: () => {
          this.removeClass("on");
        },
        delay: 100,
        exitDelay: 400,
        $clickTarget: this.$target
      });
    }
    setup($step, goal, userData) {
      var _a4;
      if ((_a4 = userData == null ? void 0 : userData.scores) == null ? void 0 : _a4.includes(goal)) this.solve(true);
      this.one("valid", () => {
        $step.addHint("correct");
        $step.score(goal);
      });
      this.on("invalid", (e) => $step.addHint(e.hint || "incorrect", { class: "incorrect" }));
    }
    solve(restore = false) {
      this.done = true;
      this.$target.html = this.solution;
      this.removeClass("on invalid");
      this.addClass("done");
      this.trigger("solve", { solution: this.solution, restore });
      setTimeout(() => this.$popup.remove(), 250);
      this.$target.removeAttr("tabindex");
    }
  };
  BlankMC = __decorateClass([
    register("x-blank-mc", { template: blank_mc_default })
  ], BlankMC);

  // node_modules/@mathigon/studio/frontend/components/free-text/free-text.pug
  var free_text_default = '<div class="text-area" contenteditable="true"></div><div class="toolbar"><button class="command" data-command="bold"><x-icon name="bold" size="20"></x-icon></button><button class="command" data-command="italic"><x-icon name="italic" size="20"></x-icon></button><button class="command" data-command="underline"><x-icon name="underline" size="20"></x-icon></button><div class="space"></div><button class="btn btn-green submit"><x-icon name="check"></x-icon> Done</button></div>';

  // node_modules/@mathigon/studio/frontend/components/free-text/free-text.ts
  var MIN_LENGTH = 40;
  var DATA_KEY = "free-text";
  var FreeText = class extends CustomElementView {
    setup($step, id, userData) {
      var _a4, _b;
      const $text = this.$(".text-area");
      const $submit = this.$(".toolbar .submit");
      let text = ((_a4 = userData == null ? void 0 : userData.data) == null ? void 0 : _a4[DATA_KEY]) || "";
      if (text) $text.html = text;
      for (const $b of this.$$(".toolbar .command")) {
        const command = $b.data.command.split(":");
        $b.on("click", () => document.execCommand(command[0], false, command[1]));
      }
      let saved = text;
      const saveChanges = throttle(() => {
        if (saved !== text) $step.storeData(DATA_KEY, text);
        saved = text;
      }, 5e3);
      $text.on("change keyup input paste", () => {
        text = $text.html.replace(/&nbsp;/g, " ").trim().slice(0, 500).trim();
        $submit.setClass("invisible", text.length < MIN_LENGTH);
        saveChanges();
      });
      if ((_b = userData == null ? void 0 : userData.scores) == null ? void 0 : _b.includes(id)) {
        $submit.remove();
      } else {
        $submit.setClass("invisible", text.length < MIN_LENGTH);
        $submit.on("click", () => {
          saveChanges();
          $step.score(id);
          $submit.exit("pop");
          this.trigger("submit");
        });
      }
    }
  };
  FreeText = __decorateClass([
    register("x-free-text", { template: free_text_default })
  ], FreeText);

  // node_modules/@mathigon/studio/frontend/components/gallery/gallery.pug
  var gallery_default = '<div class="wrapper"><div class="panel"><slot></slot></div></div><div class="nav"><button class="btn back" aria-label="Previous Step"><x-icon name="left"></x-icon></button><button class="btn next" aria-label="Next Step"><x-icon name="right"></x-icon></button><div class="dots"></div></div>';

  // node_modules/@mathigon/studio/frontend/components/gallery/gallery.ts
  var Gallery = class extends CustomElementView {
    ready() {
      const $wrapper = this.$(".wrapper");
      const $panel = this.$(".panel");
      const $slides = $panel.children;
      const $next = this.$(".next");
      const $back = this.$(".back");
      const $dotsBox = this.$(".dots");
      const $dots = $slides.map(() => $N("div", { class: "dot" }, $dotsBox));
      const slidesCount = $slides.length;
      const staticSlideWidth = +this.attr("slide-width") || void 0;
      let width2 = this.width;
      let slidesPerPage = 1;
      let slideWidth = width2;
      let activeIndex = 0;
      let translateX = 0;
      const setPosition = (offset) => {
        translateX = offset;
        $panel.translate(offset, 0);
        this.trigger("move", offset);
      };
      const makeActive = (newIndex) => {
        activeIndex = newIndex;
        for (const [i, $d] of $dots.entries()) {
          $d.setClass("on", i >= newIndex && i < newIndex + slidesPerPage);
        }
        $next.setClass("disabled", newIndex === slidesCount - slidesPerPage);
        $back.setClass("disabled", newIndex === 0);
        this.trigger("change", newIndex);
      };
      Browser.onResize(() => {
        width2 = this.width;
        slidesPerPage = staticSlideWidth ? Math.ceil(width2 / staticSlideWidth) : 1;
        slideWidth = width2 / slidesPerPage;
        for (const $s of $slides) $s.css("width", slideWidth + "px");
        $panel.css("width", slidesCount * slideWidth + "px");
        setPosition(-activeIndex * slideWidth);
        makeActive(activeIndex);
      });
      let animTiming = "quad";
      const animDuration = 500;
      let animT;
      let animStart;
      let animDistance;
      let animStartTime;
      let animCancel = false;
      const animRender = () => {
        animT = Date.now() - animStartTime;
        setPosition(animStart + animDistance * ease(animTiming, animT / animDuration));
        if (!animCancel && animT < animDuration) {
          requestAnimationFrame(animRender);
        } else {
          this.trigger("slide-end");
        }
      };
      const startAnimationTo = (newIndex) => {
        animCancel = false;
        animT = 0;
        animStart = translateX;
        animDistance = -newIndex * slideWidth - translateX;
        animStartTime = Date.now();
        makeActive(newIndex);
        animRender();
      };
      $next.on("click", () => {
        animTiming = "quad";
        if (activeIndex < slidesCount - slidesPerPage) startAnimationTo(activeIndex + 1);
      });
      $back.on("click", () => {
        animTiming = "quad";
        if (activeIndex > 0) startAnimationTo(activeIndex - 1);
      });
      let motionStartPosn;
      let pointerStart;
      let previousMotionX;
      let lastMotionX;
      slide($wrapper, {
        start: (posn) => {
          animCancel = true;
          motionStartPosn = translateX;
          pointerStart = posn.x;
          lastMotionX = previousMotionX = pointerStart;
        },
        move: (posn) => {
          previousMotionX = lastMotionX;
          lastMotionX = posn.x;
          const newPosition = motionStartPosn - pointerStart + posn.x;
          const maxScroll = -(slidesCount - slidesPerPage) * slideWidth;
          const x = newPosition > 0 ? newPosition / 4 : newPosition < maxScroll ? maxScroll + (newPosition - maxScroll) / 4 : newPosition;
          setPosition(x);
          this.css("pointer-events", "none");
        },
        end: () => {
          const lastDiff = lastMotionX - previousMotionX;
          const shift = lastDiff > 12 ? 1 : lastDiff < -12 ? -1 : 0;
          animTiming = "quad-out";
          startAnimationTo(clamp(
            Math.round(-translateX / slideWidth - shift),
            0,
            slidesCount - slidesPerPage
          ));
          setTimeout(() => this.css("pointer-events", "auto"));
        }
      });
    }
  };
  Gallery = __decorateClass([
    register("x-gallery", { template: gallery_default })
  ], Gallery);

  // node_modules/@mathigon/studio/frontend/components/gesture/gesture.pug
  var gesture_default = '<svg width="70" height="80"><path d="M20.5,7.4,27.2,24c-1.9-4.7,6-7.1,8-2.3l1.4,3.6c-1.9-4.8,6.1-7.1,8-2.3l1.3,3.1c-2-4.7,5.7-6.5,7.7-1.8,3.3,7.8,5.8,13.6,9,21.3S60.8,56.2,65,66.7L44.9,75A13.9,13.9,0,0,0,36,66.9c-7.7-2.2-11.4-8.3-18.4-14.3a44.2,44.2,0,0,0-9.5-6.5c-2.6-1.5-4.2-3.4-2.2-5.7,3.5-4.1,9.3-1.3,13.1,1.5,1.6,1.2,4.4,4.1,5.9,3.8s1.7-.8,1-2.6L12.8,10.5c-1.9-4.7,5.8-7.9,7.7-3.1Z"></path></svg>';

  // node_modules/@mathigon/studio/frontend/components/gesture/gesture.ts
  function getPosition($gesture, $element) {
    const x = $element.positionLeft - $gesture.positionLeft + $element.width / 2;
    const y = $element.positionTop - $gesture.positionTop + $element.height / 2;
    return new Point(x, y);
  }
  function parseAttr(attr) {
    return attr ? new Point(...attr.split(",").map((x) => +x)) : void 0;
  }
  var Gesture = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.doAnimation = false;
    }
    // Can be set by parent elements.
    created() {
      this.slide = parseAttr(this.attr("slide"));
      this.shift = parseAttr(this.attr("offset"));
    }
    ready() {
      this.$target = $(this.attr("target"));
      if (this.$target) {
        this.$target.on("click pointerdown focus", () => this.stop());
        if (this.hasAttr("start")) this.start();
      }
    }
    setTarget($target, slide2, shift) {
      this.$target = typeof $target === "string" ? $($target) : $target;
      if (slide2) this.slide = slide2;
      if (shift) this.slide = shift;
    }
    start(slide2) {
      if (this.doAnimation || !this.from && !this.$target) return;
      this.doAnimation = true;
      if (slide2) this.slide = slide2;
      if (this.slide || this.$end) {
        this.runSlideAnimation();
      } else {
        this.runClickAnimation();
      }
    }
    startSlide($from, $to) {
      this.$target = $from;
      this.$end = $to;
      this.start();
    }
    stop() {
      this.doAnimation = false;
    }
    runSlideAnimation() {
      return __async(this, null, function* () {
        this.show();
        let p = this.from || getPosition(this, this.$target);
        if (this.shift) p = p.add(this.shift);
        const q = this.slide ? p.add(this.slide) : getPosition(this, this.$end);
        const start = `translate(${p.x - 15}px,${p.y - 10}px)`;
        const end = `translate(${q.x - 15}px,${q.y - 10}px)`;
        yield this.animate({ transform: [start + " scale(2)", start], opacity: [0, 1] }, 300).promise;
        yield this.animate({ transform: [start, end] }, 1e3).promise;
        yield this.animate({ transform: [end, end + " scale(2)"], opacity: [1, 0] }, 300).promise;
        this.hide();
        setTimeout(() => {
          if (this.doAnimation) this.runSlideAnimation();
        }, 1e3);
      });
    }
    runClickAnimation() {
      return __async(this, null, function* () {
        this.show();
        let p = this.from || getPosition(this, this.$target);
        if (this.shift) p = p.add(this.shift);
        const posn = `translate(${p.x - 15}px,${p.y - 10}px)`;
        yield this.animate({ transform: [posn + " scale(2)", posn], opacity: [0, 1] }, 500).promise;
        yield this.animate({ transform: [posn, posn + " scale(2)"], opacity: [1, 0] }, 500, 200).promise;
        this.hide();
        setTimeout(() => {
          if (this.doAnimation) this.runClickAnimation();
        }, 1e3);
      });
    }
  };
  Gesture = __decorateClass([
    register("x-gesture", { template: gesture_default })
  ], Gesture);

  // node_modules/@mathigon/studio/frontend/components/gloss/gloss.pug
  var gloss_default = '<span class="target" tabindex="0"><slot></slot></span><div class="popup"></div>';

  // node_modules/@mathigon/studio/frontend/components/gloss/gloss.ts
  var glossary = JSON.parse($("#glossary").text);
  var bios = JSON.parse($("#bios").text);
  var WIDTH_SMALL = 600;
  var activeGloss = void 0;
  Browser.onResize(() => {
    if (activeGloss) activeGloss.hide();
  });
  var Gloss = class extends CustomElementView {
    ready() {
      this.xid = this.attr("xid");
      this.$target = this.$(".target");
      this.$popup = this.$(".popup");
      this.$popup.html = this.body() || "";
      this.setClass("left", Browser.width > WIDTH_SMALL && this.$target.bounds.left + this.$popup.width > Browser.width - 15);
      hover(this, {
        enter: () => this.show(),
        exit: () => this.hide(),
        delay: 100,
        exitDelay: 200,
        $clickTarget: this.$target,
        canFocusWithin: true,
        preventMouseover: () => Browser.width <= WIDTH_SMALL
      });
    }
    show() {
      activeGloss = this;
      this.addClass("on");
      if (Browser.width <= WIDTH_SMALL) {
        const $modal = $("#glossary-modal");
        $modal.$(".modal-body").html = this.body();
        return $modal.open();
      }
      const targetBounds = this.$target.bounds;
      const popupWidth = this.$popup.width;
      const popupHeight = this.$popup.height;
      const spaceBelow = targetBounds.top + targetBounds.height + popupHeight < Browser.height - 10;
      const spaceAbove = targetBounds.top - popupHeight > (false ? 10 : 54);
      this.setClass("top", spaceAbove && !spaceBelow);
      this.setClass("left", targetBounds.left + popupWidth > Browser.width - 15);
    }
    hide() {
      activeGloss = void 0;
      this.removeClass("on");
    }
    body() {
      const data = glossary[this.xid];
      if (!data) return console.warn("missing gloss:", this.xid);
      let body = data.text;
      if (data.image) body += `<img class="gloss-img" alt="" src="/content/shared/glossary/${data.image}"/>`;
      if (data.link && true) {
        const samePage = location.pathname === data.link.split("#")[0];
        if (!samePage) body += `<p><a href="${data.link}" class="btn btn-white btn-small">Learn more\u2026</a></p>`;
      }
      return body;
    }
  };
  Gloss = __decorateClass([
    register("x-gloss", { template: gloss_default })
  ], Gloss);
  var Bio = class extends Gloss {
    body() {
      const data = bios[this.xid];
      if (!data) return console.warn("missing bio:", this.xid);
      const image = `<img class="bio-img" alt="" src="/content/shared/bios/${this.xid}.jpg"/>`;
      const btn = data.born ? `<p><a href="/timeline/${this.xid}" class="btn btn-white btn-small" target="_blank">Timeline</a></p>` : "";
      return (data.image === false ? "" : image) + data.bio + btn;
    }
  };
  Bio = __decorateClass([
    register("x-bio", { template: gloss_default })
  ], Bio);

  // node_modules/@mathigon/studio/frontend/components/image/image.pug
  var image_default = '<div class="wrap"><img alt=""><div class="credit"></div><button class="zoom"><x-icon name="fullscreen" size="24"></x-icon></button><slot></slot></div>';

  // node_modules/@mathigon/studio/frontend/components/image/image.ts
  var SUPPORTS_AR = document.createElement("a").relList.supports("ar");
  var isOpen = false;
  var transform = { x: 0, y: 0, s: 1 };
  var $activeImg = void 0;
  var $lightbox = $N("div", { class: "lightbox-overlay" }, $body);
  var $lightboxImg = $N("div", { class: "lightbox-img" }, $lightbox);
  function openLightbox($img, srcSmall, srcLarge) {
    isOpen = true;
    $activeImg = $img;
    $lightbox.show();
    $lightboxImg.show();
    const newX = $img.bounds;
    const oldX = $lightboxImg.bounds;
    const x = newX.left + newX.width / 2 - oldX.left - oldX.width / 2;
    const y = newX.top + newX.height / 2 - oldX.top - oldX.height / 2;
    const s = Math.max(newX.width / oldX.width, newX.height / oldX.height);
    transform = { x, y, s };
    $lightboxImg.css("background-image", `url(${srcLarge}), url(${srcSmall})`);
    $lightboxImg.css("transform", `translate(${x}px, ${y}px) scale(${s})`);
    Browser.redraw();
    $lightboxImg.addClass("transitions");
    Browser.redraw();
    $img.css("visibility", "hidden");
    $lightbox.addClass("on");
    $lightboxImg.css("transform", "scale(1) translate(0,0)");
  }
  function closeLightbox() {
    if (!isOpen) return;
    isOpen = false;
    $lightbox.removeClass("on");
    $lightboxImg.setTransform(transform, 0, transform.s);
    setTimeout(() => {
      $activeImg.css("visibility", "visible");
      $lightbox.css("display", "none");
      $lightboxImg.css("transform", "none");
      $lightboxImg.removeClass("transitions");
    }, 400);
  }
  $lightbox.on("click touchmove", closeLightbox);
  $body.onKey("Escape", closeLightbox);
  $lightbox.on("scrollwheel touchmove", (e) => {
    e.preventDefault();
    e.stopPropagation();
  });
  $body.onKey("Space AllArrows PageDown PageUp", (e) => {
    if (isOpen) {
      e.preventDefault();
      e.stopPropagation();
    }
  });
  var ImageView = class extends CustomElementView {
    ready() {
      const src = this.attr("src");
      const $wrap = this.$(".wrap");
      const width2 = this.attr("width");
      const height = this.attr("height");
      this.css("width", width2 + "px");
      $wrap.css("padding-bottom", +height / +width2 * 100 + "%");
      const $img = $wrap.$("img");
      $img.setAttr("src", src);
      $img.setAttr("alt", this.attr("alt") || "");
      $img.setAttr("width", width2);
      $img.setAttr("height", height);
      if (src.endsWith(".gif")) {
        $img.on("click", () => $img.setAttr("src", src));
      }
      const $credit = $wrap.$(".credit");
      const credit = this.attr("credit");
      if (credit) {
        $credit.text = credit;
      } else {
        $credit.remove();
      }
      const $zoom = $wrap.$(".zoom");
      if (this.hasAttr("lightbox")) {
        this.addClass("interactive");
        const large = src.replace(/\.(?=[^.]*$)/, "-large.");
        this.on("click", () => openLightbox(this, src, large));
      } else {
        $zoom.remove();
      }
      if (SUPPORTS_AR && this.hasAttr("ar")) {
        const $a = $N("a", { href: this.attr("ar"), rel: "ar" });
        $wrap.prepend($a);
        $a.append($img);
      }
    }
  };
  ImageView = __decorateClass([
    register("x-img", { template: image_default })
  ], ImageView);

  // node_modules/@mathigon/studio/frontend/components/picker/picker.ts
  var Picker = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.correctCount = 0;
      this.solvedCount = 0;
      this.isSolved = false;
    }
    setup($step, id, userData) {
      var _a4;
      const $items = this.children;
      const itemsClicked = $items.map(() => false);
      for (const [i, $item] of $items.entries()) {
        const error = $item.data.error;
        const className = error ? "incorrect" : "correct";
        if (!error) this.correctCount += 1;
        $item.one("click", () => {
          if (itemsClicked[i] || this.isSolved) return;
          $step.addHint(error || "correct", { class: className });
          $item.addClass(className);
          if (!error) {
            this.solvedCount += 1;
            $step.score("picker-" + i);
            this.checkSolved();
          }
        });
      }
      const scores = ((_a4 = userData == null ? void 0 : userData.scores) == null ? void 0 : _a4.filter((x) => x.startsWith("picker-"))) || [];
      for (const score of scores) {
        const i = +score.slice(7);
        itemsClicked[i] = true;
        $items[i].addClass("correct");
      }
      this.solvedCount = scores.length;
      this.checkSolved();
    }
    checkSolved() {
      if (this.solvedCount < this.correctCount) return;
      this.addClass("solved");
      this.isSolved = true;
    }
  };
  Picker = __decorateClass([
    register("x-picker")
  ], Picker);

  // node_modules/@mathigon/studio/frontend/components/slider/slider.pug
  var slider_default = '<button class="play" aria-label="Play Slider"><x-icon name="play" size="32"></x-icon></button><div class="bar"><div class="knob"></div></div>';

  // node_modules/@mathigon/studio/frontend/components/slider/slider.ts
  var Slider = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.current = 0;
    }
    ready() {
      this.onAttr("steps", (s) => this.steps = +s);
      this.speed = +this.attr("speed") || 1;
      const $bar = this.$(".bar");
      const $knob = this.$(".knob");
      const $play = this.$(".play");
      if (this.hasAttr("no-play")) {
        $play.remove();
      } else {
        $play.on("click", () => this.play());
      }
      const continuous = this.hasAttr("continuous");
      const snap = this.hasAttr("snap") ? $bar.width / this.steps : 1e-3;
      this.drag = new Draggable($knob, { moveY: false, snap });
      this.drag.on("start", () => {
        if (this.animation) this.animation.cancel();
        this.animation = void 0;
      });
      this.drag.on("move", ({ posn }) => {
        let n = posn.x / this.drag.bounds.dx * this.steps;
        if (!continuous) n = Math.round(n);
        if (nearlyEquals(n, this.current)) return;
        this.current = n;
        this.trigger("move", n);
      });
      this.drag.on("end", () => this.trigger("slide-end"));
    }
    setup($step, goal) {
      this.bindModel($step.model);
      this.one("slide-end", () => $step.score(goal));
    }
    set(x) {
      if (nearlyEquals(x, this.current)) return;
      this.drag.setPosition(x * this.drag.bounds.dx / this.steps, 0);
    }
    play() {
      return __async(this, null, function* () {
        if (this.current >= this.steps) this.set(0);
        const duration = (1 - this.current / this.steps) * 3e3 / this.speed;
        this.moveTo(this.steps, duration);
      });
    }
    moveTo(x, duration = 600) {
      return __async(this, null, function* () {
        if (this.animation || x === this.current) return;
        const start = this.current;
        this.animation = animate((p) => {
          this.set(start + (x - start) * ease("quad", p));
        }, duration);
        yield this.animation.promise;
        this.animation = void 0;
        this.trigger("slide-end");
      });
    }
    bindVariable(model, name) {
      model[name] = 0;
      this.on("move", (n) => model[name] = n);
      model.watch(() => this.set(model[name]));
    }
  };
  Slider = __decorateClass([
    register("x-slider", { template: slider_default })
  ], Slider);

  // node_modules/@mathigon/studio/frontend/components/slideshow/slideshow.pug
  var slideshow_default = '<slot name="stage"></slot><div class="nav"><button class="btn back disabled" aria-label="Previous Step"><x-icon name="left" size="24"></x-icon></button><button class="btn next" aria-label="Next Step"><x-icon name="right" size="24"></x-icon></button><div class="dots"></div></div><div class="legend-box"><slot></slot></div>';

  // node_modules/@mathigon/studio/frontend/components/slideshow/slideshow.ts
  function blanksSolvePromise($slide) {
    const $blanks = $slide.$$("x-blank, x-blank-mc");
    if (!$blanks.length) return Promise.resolve();
    let solved = 0;
    return new Promise((resolve) => {
      for (const $b of $blanks) {
        $b.on("solve", () => {
          solved += 1;
          if (solved >= $blanks.length) resolve();
        });
      }
    });
  }
  var Slideshow = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.length = 0;
      this.current = 0;
      this.locked = false;
    }
    // Used to prevent quick double-clicking.
    ready() {
      this.$legend = this.$(".legend-box");
      this.$steps = this.$legend.children;
      this.$back = this.$(".back");
      this.$next = this.$(".next");
      const $dots = this.$(".dots");
      this.$dots = this.$steps.map(() => $N("div", { class: "dot" }, $dots));
      this.length = this.$steps.length;
      this.current = 0;
      this.$back.on("click", () => this.goBack());
      this.$next.on("click", () => this.goNext());
      this.blanks = this.$steps.map(($s) => blanksSolvePromise($s));
      this.reveals = this.$$("[slide]").map(($el) => {
        const a2 = $el.attr("slide").split("-");
        const range2 = a2.length > 1 ? [+a2[0] || 0, +a2[1] || this.length] : [+a2[0], +a2[0]];
        const options = [$el.data.animation || "fade", +$el.data.duration || 400];
        $el.data.display = "visibility";
        if (range2[0] >= 0 && !$el.hasClass("reveal")) $el.hide();
        return [$el, range2, options];
      });
      this.autoAdvance = this.attr("step") === "auto";
      this.$steps[0].show();
      this.$dots[0].addClass("on");
      this.setupSlide(0);
    }
    setup($step, _id, userData) {
      var _a4;
      const posn = (_a4 = userData == null ? void 0 : userData.scores) == null ? void 0 : _a4.filter((s) => s.startsWith("slide-")).length;
      if (posn && posn < this.$steps.length - 1) {
        this.go(posn);
        for (let i = 1; i <= posn; ++i) this.trigger("next", i);
      }
      this.on("next", (n) => $step.score("slide-" + (n - 1)));
    }
    go(x) {
      if (this.locked || x < 0 || x > this.length - 1 || x === this.current) return;
      this.locked = true;
      setTimeout(() => this.locked = false, 600);
      this.$back.setClass("disabled", x === 0);
      this.$next.setClass("disabled", x === this.length - 1);
      this.$dots[this.current].removeClass("on");
      this.$dots[x].addClass("on");
      this.$steps[x].show();
      const newHeight = this.$steps[x].height + "px";
      this.$steps[x].hide();
      this.$steps[this.current].exit("fade", 300).promise.then(() => this.$steps[x].enter("fade", 300));
      this.$legend.animate({ height: newHeight }, 600).promise.then(() => this.$legend.css("height", "auto"));
      this.setupSlide(x);
      this.current = x;
      this.trigger("step", x);
    }
    setupSlide(x) {
      this.$next.setAttr("disabled", "true");
      this.blanks[x].then(() => this.$next.removeAttr("disabled"));
      for (const [$el, range2, options] of this.reveals) {
        if ($el.hasClass("reveal")) continue;
        const isVisible = $el.css("visibility") !== "hidden";
        const show = x >= range2[0] && x <= range2[1];
        if (show && !isVisible) $el.enter(...options, 300);
        if (!show && isVisible) $el.exit(...options);
      }
    }
    goNext() {
      if (this.locked) return;
      this.go(this.current + 1);
      this.trigger("next", this.current);
    }
    goBack() {
      if (this.locked) return;
      this.go(this.current - 1);
      this.trigger("back", this.current);
    }
  };
  Slideshow = __decorateClass([
    register("x-slideshow", { template: slideshow_default })
  ], Slideshow);

  // node_modules/@mathigon/studio/frontend/components/sidebar/sidebar.ts
  var CourseSidebar = class extends CustomElementView {
    ready() {
      var _a4, _b;
      (_a4 = $(".sidebar-toggle")) == null ? void 0 : _a4.on("click", () => this.addClass("open"));
      (_b = $(".sidebar-shadow")) == null ? void 0 : _b.on("pointerdown", () => this.removeClass("open"));
      const $feedbackForm = $("#feedback form");
      const $feedbackButton = $("#feedback button");
      const $feedbackError = $("#feedback .error");
      const $feedbackSuccess = $("#feedback-success");
      const $feedbackField = $('#feedback textarea[name="message"]');
      const courseId = $("x-course").id;
      $feedbackForm == null ? void 0 : $feedbackForm.on("submit", (e) => {
        e.preventDefault();
        $feedbackButton.setAttr("disabled", "true");
        $feedbackError.hide();
        post(`/course/${courseId}/feedback`, $feedbackForm.formData).then(() => {
          $feedbackSuccess.open();
          $feedbackField.value = "";
        }).catch(() => $feedbackError.show()).then(() => $feedbackButton.removeAttr("disabled"));
      });
      const glossary2 = JSON.parse($("#glossary").text);
      const $glossaryModal = $("#glossary-search");
      const $glossBody = $glossaryModal.$(".gloss-body");
      const $glossList = $glossaryModal.$(".gloss-list");
      const $glossSearch = $glossaryModal.$(".gloss-search input");
      let $active;
      for (const g of Object.keys(glossary2).sort()) {
        const data = glossary2[g];
        const $item = $N("div", { class: "gloss-item", html: data.title, tabindex: 0 }, $glossList);
        $item.on("click", () => {
          if ($active) $active.removeClass("on");
          $active = $item;
          $item.addClass("on");
          $glossBody.html = data.text;
        });
        const search = data.title.toLowerCase();
        $glossSearch.change((v) => $item.setClass("hidden", !!v && search.indexOf(v.toLowerCase()) < 0));
      }
    }
  };
  CourseSidebar = __decorateClass([
    register("x-course-sidebar")
  ], CourseSidebar);

  // node_modules/@mathigon/studio/frontend/components/sortable/sortable.ts
  function position(items, except) {
    const cumHeights = cumulative(items.map((s) => s.h + 10));
    for (const [i, item] of items.entries()) {
      item.drag.bounds = new Bounds(0, 0, 0, last(cumHeights));
      if (item !== except) item.drag.setPosition(0, cumHeights[i - 1] || 0);
    }
  }
  function check(items) {
    return items.every((item, i) => item.index === i) || items.every((item, i) => item.index === items.length - i - 1);
  }
  var Sortable = class extends CustomElementView {
    ready() {
      this.items = this.children.map(($i) => ({
        drag: new Draggable($i, { moveX: false, useTransform: true }),
        index: +$i.data.index,
        h: 0
      }));
      for (const $i of this.children) $i.removeAttr("data-index");
      for (const item of this.items) {
        item.drag.on("drag", () => {
          this.items = sortBy(this.items, (i) => i.drag.position.y - (i === item ? 10 : 0));
          position(this.items, item);
        });
        item.drag.on("end", () => {
          position(this.items);
          if (check(this.items)) this.solve();
        });
      }
      Browser.onResize(() => {
        for (const item of this.items) item.h = item.drag.$el.height;
        const height = total(this.items.map((d) => d.h));
        this.css("height", height + this.items.length * 10 - 10 + "px");
        position(this.items);
      });
    }
    setup($step, goal, userData) {
      var _a4;
      if ((_a4 = userData == null ? void 0 : userData.scores) == null ? void 0 : _a4.includes(goal)) this.solve();
      this.one("solve", () => {
        $step.addHint("correct");
        $step.score(goal);
      });
    }
    solve() {
      this.trigger("solve");
      this.addClass("solved");
      for (const item of this.items) item.drag.disabled = true;
    }
  };
  Sortable = __decorateClass([
    register("x-sortable")
  ], Sortable);

  // node_modules/@mathigon/studio/frontend/components/step/step.ts
  function showReveal($el, noDelay = false) {
    return __async(this, null, function* () {
      if ($el.css("visibility") === "visible") return;
      $el.data.display = "visibility";
      const duration = +$el.data.duration || 400;
      const delay2 = (noDelay ? 0 : 600) + (+$el.data.delay || 0);
      yield $el.enter($el.data.animation || "fade", duration, delay2).promise;
      $el.css({ opacity: "", transform: "" });
      $el.trigger("reveal");
      $el.removeClass("reveal");
    });
  }
  var Step = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.model = observe({});
      this.isShown = false;
      this.isCompleted = false;
      this.scores = /* @__PURE__ */ new Set();
    }
    ready() {
      var _a4, _b, _c, _d;
      this.$course = this.parents("x-course")[0];
      this.$blanks = this.$$("x-blank, x-blank-mc");
      this.$components = this.$$("[goal]");
      this.userData = (_c = (_b = (_a4 = this.$course) == null ? void 0 : _a4.userData) == null ? void 0 : _b.steps) == null ? void 0 : _c[this.id];
      this.goals = words(this.attr("goals"));
      this.$reveals = this.$$(".reveal");
      const $checks = this.$$(".check[data-when]");
      for (const $el of [...this.$reveals, ...$checks]) {
        this.onScore($el.data.when, () => showReveal($el));
      }
      this.$nextBtn = this.$$(".next-step");
      for (const [i, $n] of this.$nextBtn.entries()) {
        this.onScore("next-" + i, () => $n.exit("pop"));
        $n.one("click", () => this.score("next-" + i));
      }
      for (const $t of this.$$(".step-target")) {
        if ($t.tagName === "X-TARGET") continue;
        hover($t, {
          enter: () => {
            const $targets2 = this.$$('[target~="' + $t.data.to + '"]');
            for (const $x of $targets2) $x.addClass("focus");
            this.addClass("focus");
            this.trigger("target-focus", { $targets: $targets2 });
          },
          exit: () => {
            for (const $x of this.$$(".focus")) $x.removeClass("focus");
            this.removeClass("focus");
          }
        });
      }
      for (const $var of this.$$(".var, .var-action")) {
        $var.bindModel(this.model);
      }
      if ((_d = this.$course) == null ? void 0 : _d.audio) {
        this.narration = new Narration(this.$course.audio, this);
      }
    }
    show() {
      var _a4, _b, _c;
      if (this.isShown) return;
      this.isShown = true;
      (_a4 = StepFunctions == null ? void 0 : StepFunctions[toCamelCase(this.id)]) == null ? void 0 : _a4.call(StepFunctions, this);
      for (const $c of this.$components) {
        $c.setup(this, $c.attr("goal"), this.userData);
      }
      const scores = ((_b = this.userData) == null ? void 0 : _b.scores) || [];
      for (const s of scores) this.score(s, false);
      const $gestures = this.$$("x-gesture[target]");
      setTimeout(() => {
        if (!this.isReady) for (const $g of $gestures) $g.start();
      }, 2e3);
      (_c = this.$course) == null ? void 0 : _c.log("Step", "show", this.id);
      this.trigger("show");
      this.addClass("on");
      if (this.narration) setTimeout(() => this.narration.play(), 400);
    }
    complete() {
      if (this.isCompleted) return;
      if (!this.isShown) this.show();
      this.isCompleted = true;
      for (let i = 0; i < this.$nextBtn.length; ++i) this.score("next-" + i);
      for (const $r of this.$reveals) {
        if (!$r.parents("svg").length) showReveal($r, true);
      }
      this.trigger("complete");
    }
    get isReady() {
      return this.goals.every((g) => this.scores.has(g));
    }
    get isPageLoaded() {
      return this.$course ? this.$course.isReady : true;
    }
    /** Manually score a goal for a step, and optionally move on to the next one. */
    score(goal, goNext = true) {
      if (this.scores.has(goal)) return;
      this.scores.add(goal);
      this.trigger("score-" + goal);
      this.trigger("score");
      if (this.$course) {
        this.$course.trigger("score");
        this.$course.saveProgress({ steps: { [this.id]: { scores: [goal] } } });
        this.$course.log("Step", "score", this.id + "/" + goal);
      }
      if (goNext && this.isReady && this.$course && this.$course.isReady) {
        setTimeout(() => {
          if (this.$course.$activeStep === this) this.$course.nextStep();
        }, 1200);
      }
    }
    /** Store custom data in the progress object for this step. */
    storeData(key, value) {
      var _a4;
      (_a4 = this.$course) == null ? void 0 : _a4.saveProgress({ steps: { [this.id]: { data: { [key]: value } } } });
    }
    /** Trigger a callback when one or more coals have been achieved */
    onScore(goalList, callback) {
      const goals = words(goalList);
      if (goals.every((g) => this.scores.has(g))) {
        if (callback) callback();
        return Promise.resolve();
      }
      const deferred = defer();
      const fn = () => {
        if (!goals.every((g) => this.scores.has(g))) return;
        if (callback) callback();
        deferred.resolve();
        this.off("score", fn);
      };
      this.on("score", fn);
      return deferred.promise;
    }
    /**
     * Show a message in the tutor panel. Note that no messages are shown during
     * the initial load of the page, including for all steps that have already
     * been revealed.
     */
    addHint(text, options = {}) {
      var _a4, _b, _c;
      this.trigger("hint", text);
      if (!((_a4 = this.$course) == null ? void 0 : _a4.isReady)) return { text };
      if (this.isInViewport) {
        return (_b = this.$course.$tutor) == null ? void 0 : _b.showHint(text, options);
      } else {
        this.one("enterViewport", () => {
          var _a5;
          return (_a5 = this.$course.$tutor) == null ? void 0 : _a5.showHint(text, options);
        });
        return { text: ((_c = this.$course.$tutor) == null ? void 0 : _c.hints[text]) || text };
      }
    }
    /**
     * Show a hint after a specific timeout, unless students correctly solve a
     * problem in the meantime.
     */
    delayedHint(callback, t = 1e4) {
      let timeout = setTimeout(callback, t);
      this.on("score", () => {
        clearTimeout(timeout);
        if (!this.isCompleted) timeout = setTimeout(callback, t);
      });
      this.on("complete", () => clearTimeout(timeout));
    }
    get nextStep() {
      if (!this.$course) return void 0;
      const i = this.$course.$steps.indexOf(this);
      return this.$course.$steps[i + 1];
    }
    /** Group multiple blanks together, so that students can answer in any order. */
    groupBlanks(...indices) {
      const blanks = indices.map((i) => this.$blanks[i]);
      for (const b2 of blanks) b2.linkedBlanks = blanks;
    }
  };
  Step = __decorateClass([
    register("x-step")
  ], Step);

  // node_modules/@mathigon/studio/frontend/components/tabbox/tabbox.ts
  var template = '<div class="titles"></div><div class="body"><slot></slot></div>';
  var Tabbox = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.$titles = [];
      this.active = 0;
    }
    ready() {
      const $titles = this.$(".titles");
      this.$body = this.$(".body");
      this.$tabs = this.$$(".tab");
      for (let i = 0; i < this.$tabs.length; ++i) {
        const $title = this.$tabs[i].$("h3") || $N("h3");
        $title.setAttr("tabindex", "0");
        $titles.append($title);
        this.$titles.push($title);
        $title.on("click", () => this.makeActive(i));
      }
      this.$titles[0].addClass("active");
      this.$tabs[0].show();
    }
    makeActive(i) {
      if (this.active === i) return;
      this.$titles[this.active].removeClass("active");
      this.$titles[i].addClass("active");
      this.$tabs[i].show();
      const newHeight = this.$tabs[i].outerHeight + "px";
      this.$tabs[i].hide();
      this.$tabs[this.active].exit("fade", 300).promise.then(() => this.$tabs[i].enter("fade", 300));
      this.$body.animate({ height: newHeight }, 600).promise.then(() => this.$body.css("height", "auto"));
      this.active = i;
      this.trigger("change", i);
    }
  };
  Tabbox = __decorateClass([
    register("x-tabbox", { template })
  ], Tabbox);

  // node_modules/@mathigon/studio/frontend/components/target/target.pug
  var target_default = '<defs><mask id="masking"><rect width="100%" height="100%" fill="white"></rect></mask></defs><marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="4" markerHeight="4" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z"></path></marker><rect x="0" y="0" width="100%" height="100%" mask="url(#masking)" opacity="0.8"></rect><path class="target-arrow" stroke-width="5" marker-end="url(#arrow)" opacity="0.4" stroke-linecap="round"></path>';

  // node_modules/@mathigon/studio/frontend/components/target/target.ts
  function connect(from, to, fromShift, toShift) {
    const fromPoint = new Point(from.left - 15, from.top + fromShift - 15);
    const fromRect = new Rectangle(fromPoint, from.width + 30, from.height + 30);
    const toPoint = new Point(to.left - 15, to.top + toShift - 15);
    const toRect = new Rectangle(toPoint, to.width + 30, to.height + 30);
    const path = new Segment(fromRect.center, toRect.center);
    return [intersections(path, fromRect)[0], intersections(path, toRect)[0]];
  }
  function distance(a2, b2) {
    return Math.abs(a2[0] - b2[0]) + Math.abs(a2[1] - b2[1]);
  }
  var $fixed = $$("header, x-tutor, .sidebar");
  var $targets = $N("svg", { class: "target-body", html: target_default }, $body);
  var $mask = $targets.$("mask");
  var $arrow = $targets.$(".target-arrow");
  var active = false;
  var $bounds = [];
  var Target = class extends CustomElementView {
    ready() {
      this.setAttr("tabindex", 0);
      const query = this.attr("to").replace(/_/g, " ");
      const noMargins = this.hasClass("no-margins");
      let sourceFixed = void 0;
      let start;
      let scroll;
      let showTimeout;
      const enter2 = () => {
        active = true;
        const $targets2 = $$(query);
        if (!$targets2.length) return;
        const targetFixed = $targets2[0].hasParent(...$fixed);
        if (sourceFixed === void 0) sourceFixed = this.hasParent(...$fixed);
        const sourceBounds = this.bounds;
        const bounds = $targets2.map((x) => x.bounds).filter((x) => x.width || x.height);
        scroll = 0;
        if (!targetFixed) {
          const top = Math.min(...bounds.map((x) => x.top));
          const bottom = Math.max(...bounds.map((x) => x.top + x.height));
          const scrollUp = Browser.height - 12 - bottom;
          const scrollDown = (false ? 12 : 56) - top;
          scroll = scrollUp < 0 ? scrollUp : scrollDown > 0 ? scrollDown : 0;
        }
        for (const $b of $bounds) $b.remove();
        $bounds = [sourceBounds, ...bounds].map((b2, i) => {
          const margin = !i || noMargins ? 4 : 10;
          return $N("rect", {
            x: b2.left - margin,
            y: b2.top - margin + (i || !sourceFixed ? scroll : 0),
            width: b2.width + 2 * margin,
            height: b2.height + 2 * margin,
            rx: i ? 4 : 18,
            ry: i ? 4 : 18
          }, $mask);
        });
        $arrow.points = connect(
          sourceBounds,
          bounds[0],
          sourceFixed ? 0 : scroll,
          targetFixed ? 0 : scroll
        );
      };
      const show = () => {
        if (scroll) $body.scrollBy(-scroll, 300);
        $targets.css("display", "block");
        Browser.redraw();
        delay(function() {
          $targets.css("opacity", 1);
        }, scroll ? 300 : 0);
      };
      const exit2 = (event) => {
        if (!active) return;
        if (event) {
          const moveEvent = isOneOf(event.type, "mousemove", "pointermove");
          if (moveEvent && distance(start, [event.clientX, event.clientY]) < 40) {
            return;
          }
        }
        clearTimeout(showTimeout);
        active = false;
        $targets.css("opacity", 0);
        setTimeout(() => {
          if (!active) $targets.css("display", "none");
        }, 300);
        $body.off("mousewheel mousemove touchend touchmove", exit2);
        this.off("mouseleave blur", exit2);
      };
      const bindExit = () => {
        if (scroll && !sourceFixed) {
          $body.on("mousemove", exit2);
        } else {
          this.on("mouseleave", exit2);
        }
        $body.on("mousewheel touchend touchmove", exit2);
        this.on("blur", exit2);
      };
      this.on("mouseenter touchstart focus", (e) => {
        start = [e.clientX, e.clientY];
        enter2();
        showTimeout = window.setTimeout(show, scroll ? 50 : 30);
        bindExit();
      });
      this.on("click", (e) => {
        if (active) {
          e.handled = true;
          exit2();
          setTimeout(() => $(query).trigger("click mousedown"));
        } else {
          active = true;
          scroll = 0;
          show();
          bindExit();
        }
      });
    }
  };
  Target = __decorateClass([
    register("x-target")
  ], Target);

  // node_modules/@mathigon/hilbert/dist/index.esm.js
  var ExprError = class _ExprError extends Error {
    constructor(name, message) {
      super(message);
      this.name = name;
    }
    // ---------------------------------------------------------------------------
    // Eval Errors
    static undefinedVariable(x) {
      return new _ExprError("EvalError", `Undefined variable \u201C${x}\u201D.`);
    }
    static undefinedFunction(x) {
      return new _ExprError("EvalError", `Undefined function \u201C${x}\u201D.`);
    }
    static uncallableExpression(x) {
      return new _ExprError("EvalError", `Cannot call \u201C${x}\u201D.`);
    }
    static evalLoop(x) {
      return new _ExprError("EvalError", `Loop in nested evaluation \u201C${x}\u201D.`);
    }
    // ---------------------------------------------------------------------------
    // Syntax Errors
    static invalidCharacter(x) {
      return new _ExprError("SyntaxError", `Unknown symbol \u201C${x}\u201D.`);
    }
    static conflictingBrackets(x) {
      return new _ExprError("SyntaxError", `Conflicting brackets \u201C${x}\u201D.`);
    }
    static unclosedBracket(x) {
      return new _ExprError("SyntaxError", `Unclosed bracket \u201C${x}\u201D.`);
    }
    static startOperator(x) {
      return new _ExprError("SyntaxError", `A term cannot start with a \u201C${x}\u201D.`);
    }
    static endOperator(x) {
      return new _ExprError("SyntaxError", `A term cannot end with a \u201C${x}\u201D.`);
    }
    static consecutiveOperators(x, y) {
      return new _ExprError(
        "SyntaxError",
        `A \u201C${x}\u201D cannot be followed by a \u201C${y}\u201D.`
      );
    }
    static invalidExpression() {
      return new _ExprError("SyntaxError", `This expression is invalid.`);
    }
  };
  var CONSTANTS = {
    pi: Math.PI,
    \u03C0: Math.PI,
    e: Math.E
  };
  var BRACKETS = {
    "(": ")",
    "[": "]",
    "{": "}"
  };
  var SPECIAL_OPERATORS = {
    "*": "\xB7",
    "**": "\u2217",
    "//": "//",
    "+-": "\xB1",
    "\u2013": "\u2212",
    "-": "\u2212",
    "xx": "\xD7",
    "sum": "\u2211",
    "prod": "\u220F",
    "int": "\u222B",
    "del": "\u2202",
    "grad": "\u2207",
    "aleph": "\u2135",
    "not": "\xAC",
    "AA": "\u2200",
    "EE": "\u2203",
    "'": "\u2019",
    "!=": "\u2260",
    "?=": "\u225F",
    "<=": "\u2264",
    ">=": "\u2265",
    "in": "\u2208",
    "!in": "\u2209",
    "==": "\u2261",
    "~=": "\u2245",
    "~~": "\u2248",
    "sub": "\u2282",
    "sube": "\u2286",
    "prop": "\u221D",
    "oo": "\u221E",
    "cap": "\u2229",
    "cup": "\u222A",
    "<-": "\u2190",
    "->": "\u2192",
    "=>": "\u21D2",
    "<=>": "\u21D4",
    "|->": "\u21A6",
    "uarr": "\u2191",
    "darr": "\u2193",
    "lArr": "\u21D0"
  };
  var SPECIAL_IDENTIFIERS = {
    Gamma: "\u0393",
    Delta: "\u0394",
    Theta: "\u0398",
    Lambda: "\u039B",
    Xi: "\u039E",
    Pi: "\u03A0",
    Sigma: "\u03A3",
    Phi: "\u03A6",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u025B",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    pi: "\u03C0",
    rho: "\u03C1",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    CC: "\u2102",
    NN: "\u2115",
    QQ: "\u211A",
    RR: "\u211D",
    ZZ: "\u2124"
  };
  var ALPHABET = "abcdefghijklmnopqrstuvwxyz";
  var LOWERCASE = ALPHABET.split("");
  var UPPERCASE = ALPHABET.toUpperCase().split("");
  var GREEK = Object.values(SPECIAL_IDENTIFIERS);
  var IDENTIFIER_SYMBOLS = [...LOWERCASE, ...UPPERCASE, ...GREEK, "$"];
  var SIMPLE_SYMBOLS = "|()[]{}\xF7,!?<>=*/+-\u2013\u2212~^_\u2026\xB0\u2022\u2225\u22A5'\u2220:%\u223C\u25B3";
  var COMPLEX_SYMBOLS = Object.values(SPECIAL_OPERATORS);
  var OPERATOR_SYMBOLS = [...SIMPLE_SYMBOLS, ...COMPLEX_SYMBOLS];
  var FUNCTION_NAMES = {
    "_": "sub",
    "^": "sup",
    "//": "/",
    "\xF7": "/"
  };
  var ESCAPES = {
    "<": "&lt;",
    ">": "&gt;"
  };
  function escape(char) {
    return char in ESCAPES ? ESCAPES[char] : char;
  }
  var SPECIAL_FUNCTIONS = [
    "abs",
    "round",
    "floor",
    "ceil",
    "max",
    "min",
    "mod",
    "lcm",
    "gcd",
    "gcf",
    "log",
    "exp",
    "ln",
    "sqrt",
    "root",
    "sin",
    "cos",
    "tan",
    "sec",
    "csc",
    "cot",
    "cosec",
    "cotan",
    "arcsin",
    "arccos",
    "arctan",
    "sinh",
    "cosh",
    "tanh",
    "sech",
    "csch",
    "coth",
    "cosech"
  ];
  function isSpecialFunction(fn) {
    return SPECIAL_FUNCTIONS.includes(fn);
  }
  var VOICE_STRINGS = {
    "+": "plus",
    "\u2212": "minus",
    "\xB7": "times",
    "\xD7": "times",
    "/": "over",
    "//": "divided by",
    "%": "percent",
    "!": "factorial",
    "\xB1": "plus-minus",
    "=": "equals",
    "\u2260": "does not equal",
    "\u225F": "is it equal?",
    "<": "is less than",
    ">": "is greater than",
    "\u2264": "is less than or equal to",
    "\u2265": "is greater than or equal to",
    "\u03C0": "pi",
    "\u2245": "is congruent to",
    "\u2225": "is parallel to",
    "\u22A5": "is perpendicular to"
  };
  for (const name of Object.keys(SPECIAL_IDENTIFIERS)) {
    VOICE_STRINGS[SPECIAL_IDENTIFIERS[name]] = name;
  }
  var toNumber = (x) => typeof x === "number" ? x : x[0];
  var toInterval = (x) => typeof x === "number" ? [x, x] : x;
  var ExprElement = class {
    /** Evaluates an expression using a given map of variables and functions. */
    evaluate(_vars = {}, _privateNested) {
      return NaN;
    }
    interval(vars = {}, _privateNested) {
      return toInterval(this.evaluate(vars));
    }
    /** Substitutes a new expression for a variable. */
    substitute(_vars = {}) {
      return this;
    }
    /**
     * Recursively substitutes a new expression for a variable.
     * NOTE: This function does not test for cyclical dependencies, which could
     * lead to an infinite loop. You have to manually validate expressions first!
     */
    recursiveSubstitute(vars) {
      const varList = Object.keys(vars);
      if (!this.unknowns.filter((v) => varList.includes(v)).length) return this;
      return this.substitute(vars).recursiveSubstitute(vars);
    }
    /** Returns the simplest mathematically equivalent expression. */
    get simplified() {
      return this;
    }
    /** Returns a list of all variables used in the expression (excluding defined constants). */
    get unknowns() {
      return this.variables.filter((v) => !Object.prototype.hasOwnProperty.call(CONSTANTS, v));
    }
    /** Returns a list of all variables used in the expression (including defined constants). */
    get variables() {
      return [];
    }
    /** Returns a list of all functions called by the expression. */
    get functions() {
      return [];
    }
    /** Collapses all terms into functions. */
    collapse() {
      return this;
    }
    /** Converts the expression to a plain text string. */
    toString() {
      return "";
    }
    /** Converts the expression to a MathML string. */
    toVoice(_custom = {}) {
      return "";
    }
    /** Converts the expression to a MathML string. */
    toMathML(_custom = {}) {
      return "";
    }
  };
  var LOOP_DETECTION = /* @__PURE__ */ new Set();
  function evaluateHelper(name, vars, nested = false) {
    var _a4;
    let value = (_a4 = vars[name]) != null ? _a4 : CONSTANTS[name];
    if (value === void 0) throw ExprError.undefinedVariable(name);
    if (typeof value === "string" || value instanceof ExprElement) {
      if (!nested) LOOP_DETECTION.clear();
      if (LOOP_DETECTION.has(name)) throw ExprError.evalLoop(name);
      LOOP_DETECTION.add(name);
      if (typeof value === "string") value = Expression.parse(value);
      return value.evaluate(vars, true);
    } else if (typeof value === "function") {
      return value();
    } else {
      return value;
    }
  }
  var ExprNumber = class extends ExprElement {
    constructor(n) {
      super();
      this.n = n;
    }
    evaluate() {
      return this.n;
    }
    toString() {
      return `${this.n}`;
    }
    toVoice() {
      return `${this.n}`;
    }
    toMathML() {
      return `<mn>${this.n}</mn>`;
    }
  };
  var ExprIdentifier = class extends ExprElement {
    constructor(i) {
      super();
      this.i = i;
    }
    evaluate(vars = {}, privateNested) {
      return toNumber(evaluateHelper(this.i, vars, privateNested));
    }
    interval(vars = {}, privateNested) {
      return toInterval(evaluateHelper(this.i, vars, privateNested));
    }
    toMathML() {
      const variant = isSpecialFunction(this.i) ? ' mathvariant="normal"' : "";
      return `<mi${variant}>${this.i}</mi>`;
    }
    substitute(vars = {}) {
      return vars[this.i] || this;
    }
    get variables() {
      return [this.i];
    }
    toString() {
      return this.i;
    }
    toVoice() {
      if (this.i in VOICE_STRINGS) return VOICE_STRINGS[this.i];
      if (this.i.length === 1) return `_${this.i}_`;
      return this.i;
    }
  };
  var ExprString = class extends ExprElement {
    constructor(s) {
      super();
      this.s = s;
    }
    evaluate(vars = {}, privateNested) {
      return toNumber(evaluateHelper(this.s, vars, privateNested));
    }
    toString() {
      return `"${this.s}"`;
    }
    toVoice() {
      return this.s;
    }
    toMathML() {
      return `<mtext>${this.s}</mtext>`;
    }
  };
  var ExprSpace = class extends ExprElement {
    toString() {
      return " ";
    }
    toMathML() {
      return `<mspace></mspace>`;
    }
  };
  var ExprOperator = class extends ExprElement {
    constructor(o) {
      super();
      this.o = o;
    }
    toString() {
      return this.o.replace("//", "/");
    }
    toVoice() {
      return VOICE_STRINGS[this.o] || this.o;
    }
    get functions() {
      return [this.o];
    }
    toMathML() {
      const op = escape(this.toString());
      return `<mo value="${op}">${op}</mo>`;
    }
  };
  var WHOLE = [-Infinity, Infinity];
  var EMPTY2 = [NaN, NaN];
  var HALF_PI = Math.PI / 2;
  var TWO_PI2 = Math.PI * 2;
  var int = (a2, b2) => [a2 - Number.EPSILON, b2 + Number.EPSILON];
  var range = (...args) => int(Math.min(...args), Math.max(...args));
  var width = (a2) => Math.abs(a2[1] - a2[0]);
  var isEmpty = (a2) => isNaN(a2[0]) || isNaN(a2[1]);
  var isInfinite = (a2) => !isFinite(a2[0]) && a2[0] === a2[1];
  var contains = (a2, v) => isBetween(v, a2[0] - Number.EPSILON, a2[1] + Number.EPSILON);
  var hasZero = (a2) => contains(a2, 0);
  var evaluate2 = {
    add: (...args) => args.reduce((a2, b2) => a2 + b2, 0),
    sub: (...args) => args.length > 1 ? args[0] - args[1] : -args[0],
    mul: (...args) => args.reduce((a2, b2) => a2 * b2, 1),
    div: (a2, b2) => a2 / b2,
    abs: (a2) => Math.abs(a2),
    round: (a2) => Math.round(a2),
    floor: (a2) => Math.floor(a2),
    ceil: (a2) => Math.ceil(a2),
    max: (...args) => Math.max(...args),
    min: (...args) => Math.min(...args),
    mod: (a2, b2) => a2 % b2,
    lcm: (...args) => lcm(...args),
    gcd: (...args) => gcd(...args),
    gcf: (...args) => gcd(...args),
    sup: (a2, b2) => Math.pow(a2, b2),
    log: (a2, b2) => Math.log(a2) / (b2 === void 0 ? 1 : Math.log(b2)),
    exp: (a2) => Math.exp(a2),
    ln: (a2) => Math.log(a2),
    sqrt: (a2) => Math.sqrt(a2),
    root: (a2, b2) => Math.pow(a2, 1 / b2),
    sin: (a2) => Math.sin(a2),
    cos: (a2) => Math.cos(a2),
    tan: (a2) => Math.tan(a2),
    sec: (a2) => 1 / Math.cos(a2),
    csc: (a2) => 1 / Math.sin(a2),
    cot: (a2) => 1 / Math.tan(a2),
    cosec: (a2) => evaluate2.csc(a2),
    cotan: (a2) => evaluate2.cot(a2),
    arcsin: (a2) => Math.asin(a2),
    arccos: (a2) => Math.acos(a2),
    arctan: (a2) => Math.atan(a2),
    sinh: (a2) => Math.sinh(a2),
    cosh: (a2) => Math.cosh(a2),
    tanh: (a2) => Math.tanh(a2),
    sech: (a2) => 1 / Math.cosh(a2),
    csch: (a2) => 1 / Math.sinh(a2),
    coth: (a2) => 1 / Math.tanh(a2),
    cosech: (a2) => evaluate2.csch(a2)
  };
  function pow(a2, b2) {
    if (a2[0] > 0) {
      if (b2[0] >= 0) return int(a2[0] ** b2[0], a2[1] ** b2[1]);
      return range(a2[0] ** b2[0], a2[0] ** b2[1], a2[1] ** b2[0], a2[1] ** b2[1]);
    }
    const k = b2[0];
    if (Number.isInteger(k) && k === b2[1]) {
      if (k === 0) return [hasZero(a2) ? 0 : 1, 1];
      if (k % 2) return int(a2[0] ** k, a2[1] ** k);
      if (hasZero(a2)) return [0, Math.max(a2[0] ** k, a2[1] ** k)];
      return range(a2[1] ** k, a2[0] ** k);
    }
    return EMPTY2;
  }
  function intervalMod(a2, m = TWO_PI2) {
    const d = Math.floor(a2[0] / m) * m;
    return [a2[0] - d, a2[1] - d];
  }
  var interval = {
    add: (...args) => int(total(args.map((a2) => a2[0])), total(args.map((a2) => a2[1]))),
    sub: (a2, b2) => b2 !== void 0 ? int(a2[0] - b2[1], a2[1] - b2[0]) : int(-a2[1], -a2[0]),
    mul: (a2, ...b2) => {
      if (b2.length > 1) b2 = [interval.mul(...b2)];
      return range(a2[0] * b2[0][0], a2[0] * b2[0][1], a2[1] * b2[0][0], a2[1] * b2[0][1]);
    },
    div: (a2, b2) => hasZero(b2) ? WHOLE : range(a2[0] / b2[0], a2[0] / b2[1], a2[1] / b2[0], a2[1] / b2[1]),
    abs: (a2) => {
      if (hasZero(a2)) return int(0, Math.max(-a2[0], a2[1]));
      return range(Math.abs(a2[0]), Math.abs(a2[1]));
    },
    round: (a2) => int(Math.round(a2[0]), Math.round(a2[1])),
    floor: (a2) => int(Math.floor(a2[0]), Math.floor(a2[1])),
    ceil: (a2) => int(Math.ceil(a2[0]), Math.ceil(a2[1])),
    max: (...args) => int(Math.max(...args.map((a2) => a2[0])), Math.max(...args.map((a2) => a2[1]))),
    min: (...args) => int(Math.min(...args.map((a2) => a2[0])), Math.min(...args.map((a2) => a2[1]))),
    mod: (a2, b2) => {
      if (isEmpty(a2) || isEmpty(b2)) return EMPTY2;
      let n = a2[0] / (a2[0] < 0 ? b2[0] : b2[1]);
      n = n < 0 ? Math.ceil(n) : Math.floor(n);
      return interval.sub(a2, interval.mul(b2, [n, n]));
    },
    lcm: (...args) => range(lcm(...args.map((a2) => a2[0]))),
    // TODO Review this!
    gcd: (...args) => range(gcd(...args.map((a2) => a2[0]))),
    // TODO Review this!
    gcf: (...args) => interval.gcd(...args),
    sup: (a2, b2) => pow(a2, b2),
    log: (a2, b2) => {
      if (b2 !== void 0) interval.div(interval.log(a2), interval.log(b2));
      return int(a2[0] <= 0 ? -Infinity : Math.log(a2[0]), Math.log(a2[1]));
    },
    exp: (a2) => pow([Math.E, Math.E], a2),
    ln: (a2) => interval.log(a2),
    sqrt: (a2) => pow(a2, [0.5, 0.5]),
    root: (a2, b2) => pow(a2, interval.div([1, 1], b2)),
    sin: (a2) => interval.cos(interval.sub(a2, [HALF_PI, HALF_PI])),
    cos: (a2) => {
      if (isEmpty(a2) || isInfinite(a2)) return EMPTY2;
      if (width(a2) >= TWO_PI2 - Number.EPSILON) return [-1, 1];
      a2 = intervalMod(a2);
      if (a2[0] > Math.PI + Number.EPSILON) return interval.sub(interval.cos(interval.sub(a2, [Math.PI, Math.PI])));
      if (a2[1] < Math.PI - Number.EPSILON) return int(Math.cos(a2[1]), Math.cos(a2[0]));
      if (a2[1] < TWO_PI2 - Number.EPSILON) return int(-1, Math.max(Math.cos(a2[1]), Math.cos(a2[0])));
      return int(-1, 1);
    },
    tan: (a2) => {
      if (isEmpty(a2) || isInfinite(a2)) return EMPTY2;
      a2 = intervalMod(a2, Math.PI);
      if (a2[0] > HALF_PI + Number.EPSILON) a2 = interval.sub(a2, [Math.PI, Math.PI]);
      if (a2[0] < -HALF_PI + Number.EPSILON || a2[1] > HALF_PI - Number.EPSILON) return WHOLE;
      return int(Math.tan(a2[0]), Math.tan(a2[1]));
    },
    sec: (a2) => interval.div([1, 1], interval.cos(a2)),
    csc: (a2) => interval.div([1, 1], interval.sin(a2)),
    cot: (a2) => interval.div([1, 1], interval.tan(a2)),
    cosec: (a2) => interval.csc(a2),
    cotan: (a2) => interval.cot(a2),
    arcsin: (a2) => {
      if (isEmpty(a2) || a2[1] < -1 || a2[0] > 1) return EMPTY2;
      return int(a2[0] <= -1 ? -HALF_PI : Math.asin(a2[0]), a2[1] >= 1 ? HALF_PI : Math.asin(a2[1]));
    },
    arccos: (a2) => {
      if (isEmpty(a2) || a2[1] < -1 || a2[0] > 1) return EMPTY2;
      return int(a2[1] >= 1 ? 0 : Math.acos(a2[1]), a2[0] <= -1 ? Math.PI : Math.acos(a2[0]));
    },
    arctan: (a2) => int(Math.atan(a2[0]), Math.atan(a2[1])),
    sinh: (a2) => int(Math.sinh(a2[0]), Math.sinh(a2[1])),
    cosh: (a2) => {
      if (a2[1] < 0) return int(Math.cosh(a2[1]), Math.cosh(a2[0]));
      if (a2[0] > 0) return int(Math.cosh(a2[0]), Math.cosh(a2[1]));
      return int(1, Math.cosh(Math.max(-a2[0], a2[1])));
    },
    tanh: (a2) => int(Math.tanh(a2[0]), Math.tanh(a2[1])),
    sech: (a2) => interval.div([1, 1], interval.cosh(a2)),
    csch: (a2) => interval.div([1, 1], interval.sinh(a2)),
    coth: (a2) => interval.div([1, 1], interval.tanh(a2)),
    cosech: (a2) => interval.csch(a2)
  };
  var PRECEDENCE = words("+ \u2212 * \xD7 \xB7 / \xF7 // sup sub subsup");
  var SUBSUP = words("sub sup subsup");
  var COMMA = '<mo value="," lspace="0">,</mo>';
  function needsBrackets(expr, parentFn) {
    if (!PRECEDENCE.includes(parentFn)) return false;
    if (expr instanceof ExprTerm) return true;
    if (!(expr instanceof ExprFunction)) return false;
    if (!PRECEDENCE.includes(expr.fn)) return false;
    if (SUBSUP.includes(expr.fn) && SUBSUP.includes(parentFn)) return true;
    return PRECEDENCE.indexOf(parentFn) > PRECEDENCE.indexOf(expr.fn);
  }
  function addMFence(expr, fn, string) {
    return needsBrackets(expr, fn) ? `<mfenced>${string}</mfenced>` : string;
  }
  function addMRow(expr, string) {
    const needsRow = expr instanceof ExprTerm || expr instanceof ExprFunction;
    return needsRow ? `<mrow>${string}</mrow>` : string;
  }
  function supVoice(a2) {
    return a2 === "2" ? "squared" : a2 === "3" ? "cubed" : `to the power of ${a2}`;
  }
  var ExprFunction = class _ExprFunction extends ExprElement {
    constructor(fn, args = []) {
      super();
      this.fn = fn;
      this.args = args;
    }
    evaluate(vars = {}) {
      const args = this.args.map((a2) => a2.evaluate(vars));
      if (this.fn in vars) {
        const fn = vars[this.fn];
        if (typeof fn === "function") return fn(...args);
        if (typeof fn === "number" && args.length === 1) return evaluate2.mul(fn, args[0]);
        throw ExprError.uncallableExpression(this.fn);
      }
      if (this.fn === "+") return evaluate2.add(...args);
      if (this.fn === "\u2212") return evaluate2.sub(...args);
      if (["*", "\xB7", "\xD7"].includes(this.fn)) return evaluate2.mul(...args);
      if (this.fn === "/") return evaluate2.div(...args);
      if (this.fn === "sup") return evaluate2.sup(...args);
      if (isSpecialFunction(this.fn)) return evaluate2[this.fn](...args);
      if (this.fn === "(") return args[0];
      throw ExprError.undefinedFunction(this.fn);
    }
    interval(vars = {}) {
      const args = this.args.map((a2) => a2.interval(vars));
      if (this.fn in vars) {
        const fn = vars[this.fn];
        if (typeof fn === "function") return repeat(fn(...args.map((a2) => a2[0])), 2);
        if (typeof fn === "number" && args.length === 1) return interval.mul([fn, fn], args[0]);
        if (Array.isArray(fn) && args.length === 1) return interval.mul(fn, args[0]);
        throw ExprError.uncallableExpression(this.fn);
      }
      if (this.fn === "+") return interval.add(...args);
      if (this.fn === "\u2212") return interval.sub(...args);
      if (["*", "\xB7", "\xD7"].includes(this.fn)) return interval.mul(...args);
      if (this.fn === "/") return interval.div(...args);
      if (this.fn === "sup") return interval.sup(...args);
      if (isSpecialFunction(this.fn)) return interval[this.fn](...args);
      if (this.fn === "(") return args[0];
      throw ExprError.undefinedFunction(this.fn);
    }
    substitute(vars = {}) {
      return new _ExprFunction(this.fn, this.args.map((a2) => a2.substitute(vars)));
    }
    collapse() {
      if (this.fn === "(") return this.args[0].collapse();
      return new _ExprFunction(this.fn, this.args.map((a2) => a2.collapse()));
    }
    get simplified() {
      return this;
    }
    get variables() {
      return unique(flatten(this.args.map((a2) => a2.variables)));
    }
    get functions() {
      return unique([this.fn, ...flatten(this.args.map((a2) => a2.functions))]);
    }
    toString() {
      const args = this.args.map((a2) => needsBrackets(a2, this.fn) ? `(${a2.toString()})` : a2.toString());
      if (this.fn === "\u2212") {
        return args.length > 1 ? args.join(" \u2212 ") : `\u2212${args[0]}`;
      }
      if (this.fn === "sup") return args.join("^");
      if (this.fn === "sub") return args.join("_");
      if (this.fn === "subsup") return `${args[0]}_${args[1]}^${args[2]}`;
      if (words("+ * \xD7 \xB7 / = < > \u2264 \u2265 \u2248 \u225F \u2260").includes(this.fn)) {
        return args.join(` ${this.fn} `);
      }
      if (isOneOf(this.fn, "(", "[", "{")) {
        return this.fn + this.args.join(", ") + BRACKETS[this.fn];
      }
      if (isOneOf(this.fn, "!", "%")) return args[0] + this.fn;
      return `${this.fn}(${args.join(", ")})`;
    }
    toMathML(custom = {}) {
      const args = this.args.map((a2) => a2.toMathML(custom));
      const argsF = this.args.map((a2, i) => addMFence(a2, this.fn, args[i]));
      if (this.fn in custom) {
        const argsX = args.map((a2, i) => ({
          toString: () => a2,
          val: this.args[i]
        }));
        return custom[this.fn](...argsX);
      }
      if (this.fn === "\u2212") {
        return argsF.length > 1 ? argsF.join('<mo value="\u2212">\u2212</mo>') : `<mo rspace="0" value="\u2212">\u2212</mo>${argsF[0]}`;
      }
      if (isOneOf(this.fn, "+", "=", "<", ">", "\u2264", "\u2265", "\u2248", "\u225F", "\u2260")) {
        const fn = escape(this.fn);
        return argsF.join(`<mo value="${fn}">${fn}</mo>`);
      }
      if (isOneOf(this.fn, "*", "\xD7", "\xB7")) {
        let str = argsF[0];
        for (let i = 1; i < argsF.length - 1; ++i) {
          const showTimes = this.args[0] instanceof ExprNumber && this.args[1] instanceof ExprNumber;
          str += (showTimes ? `<mo value="\xD7">\xD7</mo>` : "") + argsF[1];
        }
        return str;
      }
      if (this.fn === "//") return argsF.join(`<mo value="/">/</mo>`);
      if (this.fn === "sqrt") return `<msqrt>${argsF[0]}</msqrt>`;
      if (isOneOf(this.fn, "/", "root")) {
        const el = this.fn === "/" ? "mfrac" : "mroot";
        const args1 = this.args.map((a2, i) => addMRow(a2, args[i]));
        return `<${el}>${args1.join("")}</${el}>`;
      }
      if (isOneOf(this.fn, "sup", "sub")) {
        const args1 = [
          addMRow(this.args[0], argsF[0]),
          addMRow(this.args[1], args[1])
        ];
        return `<m${this.fn}>${args1.join("")}</m${this.fn}>`;
      }
      if (this.fn === "subsup") {
        const args1 = [
          addMRow(this.args[0], argsF[0]),
          addMRow(this.args[1], args[1]),
          addMRow(this.args[2], args[2])
        ];
        return `<msubsup>${args1.join("")}</msubsup>`;
      }
      if (isOneOf(this.fn, "(", "[", "{")) {
        return `<mfenced open="${this.fn}" close="${BRACKETS[this.fn]}">${argsF.join(COMMA)}</mfenced>`;
      }
      if (isOneOf(this.fn, "!", "%")) {
        return `${argsF[0]}<mo value="${this.fn}" lspace="0">${this.fn}</mo>`;
      }
      if (this.fn === "abs") {
        return `<mfenced open="|" close="|">${argsF.join(COMMA)}</mfenced>`;
      }
      if (this.fn === "bar") {
        return `<mover>${addMRow(this.args[0], argsF[0])}<mo value="\u203E">\u203E</mo></mover>`;
      }
      if (this.fn === "vec") {
        return `<mover>${addMRow(this.args[0], argsF[0])}<mo value="\u2192">\u2192</mo></mover>`;
      }
      const variant = isSpecialFunction(this.fn) ? ' mathvariant="normal"' : "";
      return `<mi${variant}>${this.fn}</mi><mfenced>${argsF.join(COMMA)}</mfenced>`;
    }
    toVoice(custom = {}) {
      const args = this.args.map((a2) => a2.toVoice(custom));
      const joined = args.join(" ");
      if (this.fn in custom) {
        const argsX = args.map((a2, i) => ({
          toString: () => a2,
          val: this.args[i]
        }));
        return custom[this.fn](...argsX);
      }
      if (isOneOf(this.fn, "(", "[", "{")) return joined;
      if (this.fn === "sqrt") return `square root of ${joined}`;
      if (this.fn === "%") return `${joined} percent`;
      if (this.fn === "!") return `${joined} factorial`;
      if (this.fn === "/") return `${args[0]} over ${args[1]}`;
      if (this.fn === "//") return `${args[0]} divided by ${args[1]}`;
      if (this.fn === "sub") return joined;
      if (this.fn === "subsup") return `${args[0]} ${args[1]} ${supVoice(args[2])}`;
      if (this.fn === "sup") return `${args[0]} ${supVoice(args[1])}`;
      if (VOICE_STRINGS[this.fn]) return args.join(` ${VOICE_STRINGS[this.fn]} `);
      if (isSpecialFunction(this.fn)) return `${this.fn} ${joined}`;
      return `${this.fn} of ${joined}`;
    }
  };
  var ExprTerm = class extends ExprElement {
    constructor(items) {
      super();
      this.items = items;
    }
    evaluate(vars = {}) {
      return this.collapse().evaluate(vars);
    }
    interval(vars = {}) {
      return this.collapse().interval(vars);
    }
    substitute(vars = {}) {
      return this.collapse().substitute(vars);
    }
    get simplified() {
      return this.collapse().simplified;
    }
    get variables() {
      return unique(join(...this.items.map((i) => i.variables)));
    }
    get functions() {
      return this.collapse().functions;
    }
    toString() {
      return this.items.map((i) => i.toString()).join(" ");
    }
    toMathML(custom = {}) {
      return this.items.map((i) => i.toMathML(custom)).join("");
    }
    toVoice(custom = {}) {
      return this.items.map((i) => i.toVoice(custom)).join(" ");
    }
    collapse() {
      return collapseTerm(this.items).collapse();
    }
  };
  function createToken(buffer, type) {
    if (type === 2) return new ExprString(buffer);
    if (!buffer || !type) return;
    if (type === 1 && buffer.length > 1) return new ExprSpace();
    if (type === 3) {
      if (isNaN(+buffer)) throw ExprError.invalidExpression();
      return new ExprNumber(+buffer);
    }
    if (type === 4) {
      if (buffer in SPECIAL_IDENTIFIERS) {
        return new ExprIdentifier(SPECIAL_IDENTIFIERS[buffer]);
      } else if (buffer in SPECIAL_OPERATORS) {
        return new ExprOperator(SPECIAL_OPERATORS[buffer]);
      } else {
        return new ExprIdentifier(buffer);
      }
    }
    if (type === 5) {
      if (buffer in SPECIAL_OPERATORS) {
        return new ExprOperator(SPECIAL_OPERATORS[buffer]);
      } else {
        return new ExprOperator(buffer);
      }
    }
  }
  function tokenize(str) {
    const tokens = [];
    let buffer = "";
    let type = 0;
    for (const s of str) {
      if (s === '"') {
        const newType = type === 2 ? 0 : 2;
        const token2 = createToken(buffer, type);
        if (token2) tokens.push(token2);
        buffer = "";
        type = newType;
        continue;
      } else if (type === 2) {
        buffer += s;
        continue;
      }
      const sType = s.match(/[0-9.]/) ? 3 : IDENTIFIER_SYMBOLS.includes(s) ? 4 : OPERATOR_SYMBOLS.includes(s) ? 5 : s.match(/\s/) ? 1 : 0;
      if (!sType) throw ExprError.invalidCharacter(s);
      if (!type || type === 3 && sType !== 3 || type === 4 && sType !== 4 && sType !== 3 || type === 5 && !(buffer + s in SPECIAL_OPERATORS) || type === 1 && sType !== 1) {
        const token2 = createToken(buffer, type);
        if (token2) tokens.push(token2);
        buffer = "";
        type = sType;
      }
      buffer += s;
    }
    const token = createToken(buffer, type);
    if (token) tokens.push(token);
    return tokens;
  }
  function makeTerm(items) {
    if (items.length > 1) return new ExprTerm(items);
    if (items[0] instanceof ExprOperator) return new ExprTerm(items);
    return items[0];
  }
  function splitArray(items, check2) {
    const result = [[]];
    for (const i of items) {
      if (check2(i)) {
        result.push([]);
      } else {
        last(result).push(i);
      }
    }
    return result;
  }
  function isOperator(expr, fns) {
    return expr instanceof ExprOperator && words(fns).includes(expr.o);
  }
  function removeBrackets(expr) {
    return expr instanceof ExprFunction && expr.fn === "(" ? expr.args[0] : expr;
  }
  function findBinaryFunction(tokens, fn) {
    if (isOperator(tokens[0], fn)) throw ExprError.startOperator(tokens[0]);
    if (isOperator(last(tokens), fn)) throw ExprError.endOperator(last(tokens));
    for (let i = 1; i < tokens.length - 1; ++i) {
      if (!isOperator(tokens[i], fn)) continue;
      const token = tokens[i];
      const a2 = tokens[i - 1];
      const b2 = tokens[i + 1];
      if (a2 instanceof ExprOperator) {
        throw ExprError.consecutiveOperators(a2.o, token.o);
      }
      if (b2 instanceof ExprOperator) {
        throw ExprError.consecutiveOperators(token.o, b2.o);
      }
      const token2 = tokens[i + 2];
      if (fn === "^ _" && isOperator(token, "_ ^") && isOperator(token2, "_ ^") && token.o !== token2.o) {
        const c = tokens[i + 3];
        if (c instanceof ExprOperator) throw ExprError.consecutiveOperators(token2.o, c.o);
        const args = [removeBrackets(a2), removeBrackets(b2), removeBrackets(c)];
        if (token.o === "^") [args[1], args[2]] = [args[2], args[1]];
        tokens.splice(i - 1, 5, new ExprFunction("subsup", args));
        i -= 4;
      } else {
        const fn2 = FUNCTION_NAMES[token.o] || token.o;
        const args = [removeBrackets(a2), removeBrackets(b2)];
        tokens.splice(i - 1, 3, new ExprFunction(fn2, args));
        i -= 2;
      }
    }
  }
  function prepareTerm(tokens) {
    findBinaryFunction(tokens, "^ _");
    findBinaryFunction(tokens, "/");
    return makeTerm(tokens);
  }
  function matchBrackets(tokens, context) {
    const stack = [[]];
    const safeVariables = ["\u03C0", ...(context == null ? void 0 : context.variables) || []];
    for (const t of tokens) {
      const lastOpen = last(stack).length ? last(stack)[0].o : void 0;
      if (isOperator(t, ") ] }")) {
        if (!isOperator(t, BRACKETS[lastOpen])) {
          throw ExprError.conflictingBrackets(t.o);
        }
        const closed = stack.pop();
        const term = last(stack);
        const lastTerm = last(term);
        const isFn = isOperator(t, ")") && lastTerm instanceof ExprIdentifier && !safeVariables.includes(lastTerm.i);
        const fnName = isFn ? term.pop().i : closed[0].o;
        const args = splitArray(closed.slice(1), (a2) => isOperator(a2, ","));
        term.push(new ExprFunction(fnName, args.map(prepareTerm)));
      } else if (isOperator(t, "( [ {")) {
        stack.push([t]);
      } else {
        last(stack).push(t);
      }
    }
    if (stack.length > 1) {
      throw ExprError.unclosedBracket(last(stack)[0].o);
    }
    return prepareTerm(stack[0]);
  }
  function findAssociativeFunction(tokens, symbol, implicit = false) {
    const result = [];
    let buffer = [];
    let lastWasSymbol = false;
    function clearBuffer() {
      if (lastWasSymbol) throw ExprError.invalidExpression();
      if (!buffer.length) return;
      result.push(buffer.length > 1 ? new ExprFunction(symbol[0], buffer) : buffer[0]);
      buffer = [];
    }
    for (const t of tokens) {
      if (isOperator(t, symbol)) {
        if (lastWasSymbol || !buffer.length) throw ExprError.invalidExpression();
        lastWasSymbol = true;
      } else if (t instanceof ExprOperator) {
        clearBuffer();
        result.push(t);
        lastWasSymbol = false;
      } else {
        const noImplicit = !implicit || t instanceof ExprNumber;
        if (buffer.length && !lastWasSymbol && noImplicit) throw ExprError.invalidExpression();
        buffer.push(t);
        lastWasSymbol = false;
      }
    }
    clearBuffer();
    return result;
  }
  function collapseTerm(tokens) {
    tokens = tokens.filter((t) => !(t instanceof ExprSpace));
    if (!tokens.length) throw ExprError.invalidExpression();
    const comp = tokens.findIndex((t) => isOperator(t, "= < > \u2264 \u2265 \u225F \u2260"));
    if (comp === 0) throw ExprError.startOperator(tokens[0]);
    if (comp === tokens.length - 1) throw ExprError.endOperator(tokens[0]);
    if (comp > 0) {
      const left = collapseTerm(tokens.slice(0, comp));
      const right = collapseTerm(tokens.slice(comp + 1));
      return new ExprFunction(tokens[comp].o, [left, right]);
    }
    if (isOperator(tokens[0], "%!")) throw ExprError.startOperator(tokens[0]);
    for (let i = 0; i < tokens.length; ++i) {
      if (!isOperator(tokens[i], "%!")) continue;
      tokens.splice(i - 1, 2, new ExprFunction(tokens[i].o, [tokens[i - 1]]));
      i -= 1;
    }
    findBinaryFunction(tokens, "// \xF7");
    for (let i = 1; i < tokens.length; ++i) {
      const t = tokens[i];
      if (t instanceof ExprFunction && t.fn === "/") {
        const s = tokens[i - 1];
        if (s instanceof ExprNumber) {
          tokens.splice(i - 1, 2, new ExprFunction("+", [s, t]));
          i -= 1;
        } else if (!(s instanceof ExprOperator)) {
          throw ExprError.consecutiveOperators(s.toString(), t.toString());
        }
      }
    }
    tokens = findAssociativeFunction(tokens, "\xD7 * \xB7", true);
    if (isOperator(tokens[0], "\u2212 \xB1")) {
      tokens.splice(0, 2, new ExprFunction(tokens[0].o, [tokens[1]]));
    }
    findBinaryFunction(tokens, "\u2212 \xB1");
    if (isOperator(tokens[0], "+")) tokens = tokens.slice(1);
    tokens = findAssociativeFunction(tokens, "+");
    if (tokens.length > 1) throw ExprError.invalidExpression();
    return tokens[0];
  }
  function parse2(str, collapse = false, context) {
    const expr = matchBrackets(tokenize(str), context);
    return collapse ? expr.collapse() : expr;
  }
  function numEquals(expr1, expr2) {
    try {
      const vars = unique([...expr1.variables, ...expr2.variables]);
      const fn1 = expr1.collapse();
      const fn2 = expr2.collapse();
      let matches2 = 0;
      for (let i = 0; i < 5; ++i) {
        const substitution = {};
        for (const v of vars) substitution[v] = CONSTANTS[v] || Math.random() * 5;
        const a2 = fn1.evaluate(substitution);
        const b2 = fn2.evaluate(substitution);
        if (isNaN(a2) || isNaN(b2)) continue;
        if (!nearlyEquals(a2, b2)) return false;
        matches2 += 1;
      }
      return !!matches2;
    } catch (e) {
      return false;
    }
  }
  var Expression = {
    numEquals,
    parse: cache(parse2)
  };

  // node_modules/@mathigon/studio/frontend/components/tutor/tutor.pug
  var tutor_default = '<div class="toasts"><div class="msg-wrap"><button class="msg archie" aria-label="Virtual Tutor"><slot name="icon"></slot></button></div></div><div class="chat" data-display="flex"><div class="chat-header"><slot name="header"></slot><button class="close"><x-icon name="close" size="24"></x-icon></button></div><div class="chat-body"></div><div class="chat-footer"><div class="input" contenteditable></div><button class="hint"><x-icon name="lightbulb" size="24"></x-icon></button></div></div>';

  // node_modules/@mathigon/studio/frontend/components/tutor/tutor.ts
  var MATHS_REGEX = /[0-9+\-*/()^\s]+/g;
  var correctImg = loop(random_exports.shuffle([
    "happy",
    "spongebob",
    "sloth",
    "party",
    "robot",
    "excited",
    "cute",
    "highfive1",
    "applause",
    "highfive2"
  ]));
  var incorrectImg = loop(random_exports.shuffle([
    "minions",
    "panther",
    "dog",
    "snape",
    "what",
    "door",
    "horrible"
  ]));
  function createMsgElement(content, kind, options = {}) {
    const $wrap = $N("div", { class: "msg-wrap", "data-display": "flex" });
    const $bubble = $N("div", { class: "msg " + kind }, $wrap);
    if (options.class) $bubble.addClass(options.class);
    if (!options.visible) $wrap.hide();
    if (isOneOf(kind, "hint", "question")) {
      $bubble.html = content;
    } else if (kind === "img") {
      $bubble.css("background-image", `url(${content})`);
    } else if (kind === "video") {
      $N("iframe", { src: content, allowfullscreen: true }, $bubble);
    }
    return $wrap;
  }
  var Tutor = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.recentMessages = [];
      this.isOpen = false;
      this.queuePromise = Promise.resolve();
    }
    ready() {
      var _a4;
      this.$course = this.parents("x-course")[0];
      this.hints = this.$course ? JSON.parse(this.$course.$("#hints").text) : {};
      const user = window.user;
      this.correct = loop(random_exports.shuffle(this.hints.correct || []));
      this.incorrect = loop(random_exports.shuffle(this.hints.incorrect || []));
      this.$toasts = this.$(".toasts");
      this.$chat = this.$(".chat");
      this.$chatBody = this.$(".chat-body");
      this.$toasts.on("click", (e) => {
        if (!e.handled) this.open();
      });
      this.$(".close").on("click", () => this.close());
      const $footer = this.$(".chat-footer");
      this.$query = $footer.$(".input");
      this.$query.onKey("Enter", (e) => {
        e.preventDefault();
        this.askQuestion(this.$query.text.trim());
        this.$query.text = "";
      });
      this.$query.on("focus", () => $footer.addClass("focus"));
      this.$query.on("blur", () => $footer.removeClass("focus"));
      this.$(".hint").on("click", () => {
        this.queue(this.hints.tutorial1);
        this.queue(user ? this.hints.tutorial2 : this.hints.account);
      });
      if (this.$course && ((_a4 = this.$course.userData) == null ? void 0 : _a4.messages)) {
        for (const m of this.$course.userData.messages) {
          this.$chatBody.append(
            createMsgElement(m.content, m.kind || "hint", { visible: true })
          );
        }
      }
      const showWelcome = false ? window.showWelcomeMessage : !Browser.getCookie("sessionWelcome");
      if (showWelcome && this.$course) {
        if (true) Browser.setCookie("sessionWelcome", 1, 60 * 60 * 4);
        const t = (/* @__PURE__ */ new Date()).getHours();
        const time = t < 12 ? "Morning" : t < 18 ? "Afternoon" : "Evening";
        if (user) {
          setTimeout(() => this.showHint(`welcome${time}Named`, { variables: { name: user.shortName } }), 3e3);
        } else if (Browser.getCookie("welcome")) {
          setTimeout(() => this.showHint(`welcome${time}`), 3e3);
          if (true) setTimeout(() => this.queue(this.hints.account), 4500);
        } else {
          Browser.setCookie("welcome", 1);
          setTimeout(() => this.queue(this.hints.welcome), 3e3);
          if (true) setTimeout(() => this.queue(this.hints.tutorial1), 4500);
        }
      }
    }
    // ---------------------------------------------------------------------------
    open() {
      if (this.isOpen) return;
      this.isOpen = true;
      this.$chat.enter("slide-up", 200);
      this.$chatBody.scrollTop = this.$chatBody.scrollHeight;
      this.trigger("open");
    }
    close() {
      if (!this.isOpen) return;
      this.isOpen = false;
      this.$query.blur();
      this.trigger("close");
      this.$chat.exit("slide-down", 200);
    }
    queue(content, kind = "hint", options = {}) {
      this.queuePromise = this.queuePromise.then(() => {
        this.display(content, kind, options);
        return wait(500);
      });
    }
    display(content, kind = "hint", options = {}) {
      let timeout = options.timeout || 8e3;
      if (Browser.width < 640) timeout *= 0.7;
      const toast = options.toast == void 0 ? true : options.toast;
      if (toast && !this.isOpen) {
        const $toast = createMsgElement(content, kind, options);
        $toast.setAttr("role", "alert");
        this.$toasts.append($toast);
        $toast.enter("reveal-right");
        setTimeout(() => $toast.exit("reveal-right", 400, 0, true), timeout);
        this.on("open", () => $toast.exit("reveal", 200, 0, true));
      }
      const $chat = createMsgElement(content, kind, { class: options.class, visible: !this.isOpen });
      this.$chatBody.append($chat);
      if (this.isOpen) {
        $chat.enter("reveal", 300);
        animate(() => this.$chatBody.scrollTop = this.$chatBody.scrollHeight, 200);
      }
    }
    // ---------------------------------------------------------------------------
    showHint(msg, options = {}) {
      if (isOneOf(msg, "correct", "incorrect")) {
        const content2 = msg === "correct" ? this.correct() : this.incorrect();
        const timeout = msg === "correct" ? 3e3 : 5e3;
        this.queue(content2, "hint", { class: options.class || msg, timeout });
        if (Math.random() < 0.2) {
          const img = msg === "correct" ? correctImg() : incorrectImg();
          const prefix = false ? "../.." : "";
          this.queue(`${prefix}/images/gifs/${img}.gif`, "img", { timeout });
        }
        return { text: content2 };
      }
      let content = this.hints[msg] || msg;
      if (options.variables) {
        for (const [key, value] of Object.entries(options.variables)) {
          content = content.replace(new RegExp("\\$" + key, "g"), value);
        }
      }
      if (!options.force && this.recentMessages.includes(msg)) {
        return { text: content };
      }
      this.recentMessages.push(msg);
      setTimeout(() => this.recentMessages.shift(), 1e4);
      if (options.store !== false && this.$course) {
        this.$course.saveProgress({ hints: [{ content, kind: "hint" }] });
      }
      this.queue(content, "hint", { class: options.class });
      return { text: content };
    }
    askQuestion(query) {
      if (!query) return;
      this.queue(query, "question");
      if (this.$course) this.$course.log("Tutor", "ask", query);
      const equation = (query.match(MATHS_REGEX) || []).filter((x) => x.length >= 3 && !x.match(/^[\s0-9]+$/));
      if (equation.length) {
        try {
          const expr = Expression.parse(equation[0], true);
          const result = Expression.parse("=" + expr.evaluate());
          return this.queue(`<span class="math">${expr.toMathML()}${result.toMathML()}</span>`);
        } catch (e) {
          console.log("Parse Error:", equation[0]);
        }
      }
      this.$chatBody.addClass("loading");
      post(this.attr("api"), { query }).then((res) => {
        this.$chatBody.removeClass("loading");
        const data = JSON.parse(res);
        for (const msg of data) this.queue(msg.content, msg.kind);
      }).catch((error) => {
        this.$chatBody.removeClass("loading");
        this.queue(this.hints.serverError);
        console.error("Tutor Error:", error);
      });
    }
  };
  Tutor = __decorateClass([
    register("x-tutor", { template: tutor_default })
  ], Tutor);

  // node_modules/@mathigon/studio/frontend/components/variable/variable.pug
  var variable_default = '<div class="left" tabindex="0"><x-icon name="left" size="14"></x-icon></div><div class="content"><slot></slot></div><div class="right" tabindex="0"><x-icon name="right" size="14"></x-icon></div><div class="bubble"><div class="bubble-box"><div class="progress"></div></div><div class="bubble-arrow"></div></div>';

  // node_modules/@mathigon/studio/frontend/components/variable/variable.ts
  var $overlay = $N("div", { class: "var-overlay" }, $body);
  var Variable = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.valueChange = false;
    }
    ready() {
      const bind = this.attr("bind");
      if (!bind) return;
      const [name, first, info] = bind.split("|");
      [this.min, this.max, this.step] = info.split(",").map((x) => +x);
      this.name = name;
      this.model = this.getParentModel();
      this.$(".content").bindModel(this.model);
      this.$progress = this.$(".progress");
      this.setValue(+first);
      const sensitivity = 20 * (Browser.isMobile ? 1.5 : 1) / clamp((this.max - this.min) / this.step / 12, 1, 3);
      let startPosition = 0;
      let startValue = 0;
      for (const $a of this.$$(".left, .right")) {
        const change = $a.hasClass("left") ? -this.step : this.step;
        $a.on("click", () => {
          this.setValue(this.value + change);
          this.trigger("slide-end");
        });
      }
      slide(this, {
        start: (posn) => {
          startPosition = posn.x;
          startValue = this.value;
          this.addClass("on");
          this.valueChange = false;
          $overlay.show();
          $html.addClass("grabbing");
        },
        move: (posn) => {
          const change = (posn.x - startPosition) / sensitivity;
          this.setValue(startValue + round(change) * this.step);
        },
        end: () => {
          this.removeClass("on");
          if (this.valueChange) this.trigger("slide-end");
          $overlay.hide();
          $html.removeClass("grabbing");
        }
      });
    }
    setup($step, goal) {
      this.one("slide-end", () => $step.score(goal));
    }
    setValue(v) {
      const value = round(clamp(v, this.min, this.max), 2);
      if (value === this.value) return;
      this.value = value;
      this.valueChange = true;
      if (this.model) this.model[this.name] = value;
      const range2 = this.max - this.min;
      this.$progress.css("width", 116 * (value - this.min) / range2 + "px");
    }
  };
  Variable = __decorateClass([
    register("x-var", { template: variable_default })
  ], Variable);

  // node_modules/@mathigon/studio/frontend/components/video/play-btn.pug
  var play_btn_default = '<button class="play-btn-box" aria-label="Play"><x-icon name="play" size="44"></x-icon></button>';

  // node_modules/@mathigon/studio/frontend/components/video/play-btn.ts
  var PlayBtn = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.visible = true;
    }
    ready() {
      this.on("click", () => {
        this.play();
        setTimeout(() => this.trigger("play"), 400);
      });
    }
    play() {
      if (!this.visible) return;
      this.visible = false;
      this.exit("pop", 400);
    }
    reset() {
      if (this.visible) return;
      this.visible = true;
      setTimeout(() => this.enter("pop"), 400);
    }
  };
  PlayBtn = __decorateClass([
    register("x-play-btn", { template: play_btn_default })
  ], PlayBtn);
  var PlayToggle = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.playing = false;
    }
    ready() {
      this.$icon = this.$("x-icon");
      this.$("button").on("click", () => this.toggle());
    }
    toggle() {
      if (this.playing) {
        this.pause();
      } else {
        this.play();
      }
    }
    play() {
      if (this.playing) return;
      this.playing = true;
      this.$icon.setAttr("name", "pause");
      this.trigger("play");
    }
    pause() {
      if (!this.playing) return;
      this.playing = false;
      this.$icon.setAttr("name", "play");
      this.trigger("pause");
    }
  };
  PlayToggle = __decorateClass([
    register("x-play-toggle", { template: '<button class="icon-btn"><x-icon name="play"></x-icon></button>' })
  ], PlayToggle);

  // node_modules/@mathigon/studio/frontend/components/video/video.pug
  var video_default = '<div class="video-wrap"><video playsinline></video></div><div class="credit"></div><x-play-btn></x-play-btn><div class="controls"><div class="shadow"></div><button class="play-pause-btn" tabindex="0" aria-label="Play video"><div class="play-icon"><x-icon name="play" size="32"></x-icon></div><div class="pause-icon"><x-icon name="pause" size="32"></x-icon></div></button><div class="timeline"><div class="bar"><div class="background"></div><div class="buffer"></div><div class="progress"></div></div><div class="handle"></div></div><div class="timecode"></div></div>';

  // node_modules/@mathigon/studio/frontend/components/video/video.ts
  function formatTime(time) {
    const m = Math.floor(time / 60);
    const s = Math.floor(time % 60);
    return m + ":" + (s < 10 ? "0" : "") + s;
  }
  var Video = class extends CustomElementView {
    ready() {
      const src = this.attr("src");
      const $wrap = this.$(".video-wrap");
      const $video = this.$("video");
      const width2 = this.attr("width");
      const height = this.attr("height");
      this.css("width", width2 + "px");
      $wrap.css("padding-bottom", +height / +width2 * 100 + "%");
      $video.setAttr("poster", this.attr("poster") || src.replace(/mp4$/, "jpg"));
      if (this.hasAttr("loop")) $video._el.loop = true;
      if (!this.hasAttr("audio")) $video._el.muted = true;
      $video._el.preload = this.attr("preload") === "no" ? "metadata" : "auto";
      $N("source", { src, type: "video/mp4" }, $video);
      if (this.hasAttr("credit")) {
        this.$(".credit").text = this.attr("credit");
      }
      const $timelineBar = this.$(".bar");
      const $progressBar = this.$(".progress");
      const $bufferBar = this.$(".buffer");
      const $timecode = this.$(".timecode");
      const drag = new Draggable(this.$(".handle"), { $parent: $timelineBar, moveY: false });
      const video = this.video = $video._el;
      let timelineWidth = this.width - 110;
      Browser.onResize(() => timelineWidth = this.width - 110);
      $video.on("canplay", () => {
        $timecode.text = formatTime(+video.duration);
      });
      $video.on("timeupdate", () => {
        const playedPercent = video.currentTime / video.duration;
        $progressBar.css("width", playedPercent * 100 + "%");
        $timecode.text = formatTime(+video.currentTime);
        drag.setPosition(playedPercent * timelineWidth, 0);
        this.trigger("timeupdate", video.currentTime);
      });
      $video.on("progress", () => {
        if (video.buffered.length <= 0 || video.duration <= 0) return;
        const bufferedEnd = video.buffered.end(video.buffered.length - 1);
        const bufferedPercent = bufferedEnd / video.duration * 100;
        $bufferBar.css("width", bufferedPercent + "%");
      });
      $video.on("ended", () => {
        video.pause();
        this.removeClass("playing");
        this.trigger("end");
      });
      const togglePlayPause = () => video.paused ? this.play() : this.pause();
      const setPosition = (x) => this.setTime(x / timelineWidth * video.duration);
      if (this.hasAttr("hover")) {
        $video.on("mouseover touchstart", () => this.play());
        $video.on("mouseout touchend touchcancel", () => this.pause());
      } else {
        $video.on("click", togglePlayPause);
      }
      if (this.hasAttr("controls")) {
        this.$(".controls").show();
        this.$(".play-pause-btn").on("click", togglePlayPause);
        drag.on("start", () => this.pause());
        drag.on("drag", ({ posn }) => setPosition(posn.x));
        $timelineBar.on("click", (e) => setPosition(e.offsetX));
      }
    }
    setTime(t) {
      this.video.currentTime = t;
    }
    play() {
      this.video.play();
      this.addClass("playing");
      this.trigger("play");
    }
    pause() {
      this.video.pause();
      this.removeClass("playing");
    }
  };
  Video = __decorateClass([
    register("x-video", { template: video_default })
  ], Video);

  // node_modules/@mathigon/studio/frontend/course.ts
  var Course = class extends CustomElementView {
    constructor() {
      super(...arguments);
      this.isCompleted = false;
      this.isReady = false;
    }
    created() {
      this.userData = window.progressData || JSON.parse(this.$("#userdata").text) || {};
      this.$steps = this.$$("x-step");
      for (const $s of this.$steps) $s.on("score", () => this.trigger("score"));
      if (this.data.audio) this.audio = new AudioSegment(this.data.audio);
    }
    ready() {
      this.$footer = this.$("footer");
      this.$skipStep = this.$footer.$(".skip-step");
      this.$progress = this.$(".sidebar-row.active x-progress");
      this.$tutor = this.$("x-tutor");
      this.$stepsWrap = this.$(".steps");
      const stepFromHash = this.findStep(Browser.getHash());
      const stepFromDb = this.findStep(this.userData.activeStep);
      this.$activeStep = stepFromDb || this.$steps[0];
      for (const $step of this.$steps) {
        $step.show();
        if ($step === this.$activeStep) break;
        $step.complete();
      }
      if (this.userData.completed || Browser.getHash() === "full" || this.data.reveal) {
        this.complete();
      } else {
        while (this.$activeStep && this.$activeStep.isReady && !this.isCompleted) {
          this.nextStep();
        }
      }
      if (stepFromHash || stepFromDb && !this.userData.completed) {
        this.goToStep(stepFromHash || stepFromDb, false);
      }
      if (this.$(".section-dev")) this.complete();
      const $reveal = this.$(".reveal-banner");
      setTimeout(() => {
        if (this.isCompleted) return;
        $reveal.removeClass("off");
        this.on("score complete", () => $reveal.addClass("off"));
      }, 1500);
      $reveal.$(".complete").one("click", () => this.complete());
      $body.onKey("Space", (e) => {
        e.preventDefault();
        this.nextStep();
        $reveal.addClass("off");
      });
      this.$footer.$(".skip").on("click", () => this.nextStep());
      this.$footer.$(".show-all").on("click", () => this.complete());
      this.$footer.show();
      this.isReady = true;
      setTimeout(() => this.addClass("ready"));
    }
    // ---------------------------------------------------------------------------
    // Step Navigation
    nextStep() {
      if (this.isCompleted) return;
      let $step = this.$activeStep;
      const prevHeight = this.$stepsWrap.height;
      do {
        $step.complete();
        $step = this.$steps[this.$steps.indexOf($step) + 1];
        if (!$step) return this.complete(true);
        $step.show();
      } while ($step.isReady);
      this.$stepsWrap.animate({ height: [prevHeight + "px", "auto"] }, 800);
      this.$activeStep = $step;
      this.saveProgress({ activeStep: $step.id });
    }
    goToStep($step, animated = true) {
      const prevHeight = this.$stepsWrap.height;
      for (const $s of this.$steps) {
        if (!$s.isShown) this.$activeStep = $s;
        $s.show();
        if ($step.isShown && !$s.isReady) break;
        $s.complete();
      }
      const targetScroll = $step.positionTop - Math.max(50, (Browser.height - $step.height) / 2);
      if (animated) {
        this.$stepsWrap.animate({ height: [prevHeight + "px", "auto"] }, 800);
        $body.scrollTo(targetScroll);
      } else {
        $body.scrollTop = targetScroll;
      }
      const $last = last(this.$steps);
      if ($last.isShown && $last.isReady) return this.complete();
      if (this.$activeStep) this.saveProgress({ activeStep: this.$activeStep.id });
    }
    complete(animated = false) {
      if (this.isCompleted) return;
      this.isCompleted = true;
      this.$steps.forEach(($step) => $step.complete());
      this.$activeStep = void 0;
      const $nextSection = this.$footer.$(".next-section");
      if (animated) {
        this.$skipStep.exit("fade", 200);
        if ($nextSection) $nextSection.enter("pop");
      } else {
        this.$skipStep.hide();
        if ($nextSection) $nextSection.show();
      }
      this.trigger("complete");
      this.saveProgress({ completed: true });
      this.log("Course", "complete");
    }
    // ---------------------------------------------------------------------------
    // Utilities
    findStep(id) {
      for (const $s of this.$steps) {
        if ($s.id === id) return $s;
      }
    }
    saveProgress(data) {
      if (!this.isReady) return;
      const scores = total(this.$steps.map((s) => s.scores.size));
      const progress = scores / +this.data.goals || 0;
      if (false) {
        data.progress = progress;
        window.ReactNativeWebView.postMessage(JSON.stringify(data));
      }
      if (true) {
        this.$progress.setProgress(progress);
        deferredPost(`/course/${this.id}/${this.data.section}`, data);
      }
    }
    log(category, action, value) {
      if (window.ga && this.isReady) {
        const actionStr = action + (value ? ":" + value : "");
        window.ga("send", "event", category, actionStr, this.id);
      }
    }
  };
  Course = __decorateClass([
    register("x-course")
  ], Course);
})();